{"version":3,"file":"kite.min.js","sources":["../../node_modules/grunt-requirejs/node_modules/almond/almond.js","../../js/kite.js","../../common/assert/js/assert.js","../../common/dot/js/dot.js","../../common/phet-core/js/extend.js","../../common/phet-core/js/inherit.js","../../common/dot/js/Util.js","../../common/dot/js/Vector2.js","../../common/dot/js/Bounds2.js","../../common/dot/js/Ray2.js","../../common/dot/js/Vector4.js","../../common/dot/js/Vector3.js","../../common/dot/js/Matrix4.js","../../common/dot/js/Matrix3.js","../../common/dot/js/Transform3.js","../../js/segments/Segment.js","../../js/segments/Line.js","../../js/segments/Arc.js","../../js/util/Subpath.js","../../js/../parser/svgPath.js","../../js/util/LineStyles.js","../../js/segments/Quadratic.js","../../js/segments/Cubic.js","../../js/segments/EllipticalArc.js","../../js/Shape.js","../../js/main.js","../../common/dot/js/Complex.js","../../common/dot/js/ConvexHull2.js","../../common/dot/js/Dimension2.js","../../common/dot/js/EigenvalueDecomposition.js","../../common/dot/js/LinearFunction.js","../../common/dot/js/LUDecomposition.js","../../common/phet-core/js/isArray.js","../../common/dot/js/SingularValueDecomposition.js","../../common/dot/js/QRDecomposition.js","../../common/dot/js/Matrix.js","../../common/dot/js/Permutation.js","../../common/dot/js/Ray3.js","../../common/dot/js/Transform4.js","../../common/dot/js/main.js","../../common/phet-core/js/callSuper.js","../../common/phet-core/js/collect.js","../../common/phet-core/js/escapeHTML.js","../../common/phet-core/js/inheritPrototype.js","../../common/phet-core/js/loadScript.js","../../common/phet-core/js/main.js","../../js/production-config.js"],"names":[],"mappings":"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AA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EAIA,MAAA,IAAA,OAAA,oDAIA,YAAA,SAAA,GACA,GAAA,GAAA,EAAA,KAaA,OAZA,MAAA,OAAA,EAAA,gBAAA,EAAA,OAAA,EAAA,iBACA,EAAA,EAAA,gBAEA,KAAA,OAAA,EAAA,SAAA,EAAA,OAAA,EAAA,UACA,EAAA,EAAA,SAEA,KAAA,OAAA,EAAA,WACA,EAAA,EAAA,MAEA,EAAA,OAAA,EAAA,WACA,EAAA,KAAA,MAEA,GAAA,GAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA;EAGA,aAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CACA,OAAA,IAAA,GAAA,QAAA,EAAA,EAAA,EAAA,IAGA,aAAA,SAAA,GACA,MAAA,MAAA,aAAA,EAAA,aAAA,aAGA,sBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CACA,OAAA,IAAA,GAAA,QAAA,EAAA,EAAA,EAAA,IAGA,sBAAA,SAAA,GACA,MAAA,MAAA,sBAAA,EAAA,aAAA,aAGA,qBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CACA,OAAA,IAAA,GAAA,QAAA,EAAA,EAAA,IAGA,YAAA,WACA,MAAA,MAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAGA,SAAA,WACA,MAAA,MAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,KACA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,KACA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,KACA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,OAGA,YAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,MAAA,KAAA,MAAA,KAAA,QACA,QAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,MAAA,KAAA,MAAA,KAAA,QAEA,cAAA,WACA,KAAA,SAAA,WACA,KAAA,IAAA,OAAA,qCAMA,EAAA,SAAA,GAAA,GACA,EAAA,SAAA,gBAEA,ICvVA,EAAA,eAAA,UAAA,UAAA,cAAA,cAAA,eAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WAEA,EAAA,EAAA,SAEA,GAAA,eACA,EAAA,eACA,EAAA,eAEA,EAAA,QAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAGA,KAAA,QAAA,GAAA,GAAA,GAEA,KAAA,SAAA,SAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EACA,GAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,EACA,GAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,EACA,GAEA,IAAA,GAAA,EAAA,OAEA,GAAA,OAIA,MAAA,EACA,SAAA,EACA,eAAA,EACA,QAAA,EACA,OAAA,EAKA,IAAA,GAAA,EAAA,KAgvBA,OA9uBA,GAAA,SAAA,WACA,MAAA,IAAA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,WAGA,EAAA,YAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,iBAGA,EAAA,sBAAA,SAAA,GAAA,MAAA,GAAA,YAAA,EAAA,EAAA,EAAA,IAEA,EAAA,QAAA,SAAA,EAAA,GAIA,MAFA,GAAA,SAAA,EAAA,EAAA,EAEA,GAAA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,UAEA,EAAA,MAAA,EAAA,QAEA,EAAA,OAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,MAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAIA,EAAA,kBAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,GACA,EAAA,EAAA,CAEA,OAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,QAKA,EAAA,UAAA,SAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GAAA,EAAA,EAAA,EACA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,QAGA,EAAA,UAAA,SAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,GACA,EAAA,EAAA,EACA,EAAA,QAGA,EAAA,UAAA,SAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GAAA,GAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,SAIA,EAAA,UAAA,EAAA,UAEA,EAAA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,SAIA,EAAA,WAAA,SAAA,EAAA,GAEA,GAKA,GAAA,EAAA,EALA,EAAA,EACA,EAAA,EAEA,EAAA,KAIA,EAAA,EAAA,MAAA,EAKA,IAJA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,GAAA,EAAA,EAGA,EAAA,EAAA,EAAA,CACA,GAAA,GAAA,EAAA,EAIA,EAAA,GAAA,GAAA,QACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAKA,GAFA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,QAAA,OAGA,EAAA,QAAA,OAIA,EAAA,EAAA,EAAA,EACA,EAAA,QAAA,OAGA,EAAA,QAAA,MAIA,IAAA,GAAA,EAAA,MAAA,EAOA,OANA,GAAA,EAAA,MAAA,GAEA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAAA,GAEA,EAAA,SAAA,KAAA,EAAA,UACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAKA,GAAA,GAAA,EAAA,EAAA,EAAA,CAQA,OAPA,GAAA,GAAA,EAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAEA,EAAA,SACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAKA,EAAA,WACA,YAAA,EAOA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IAEA,SAAA,WACA,MAAA,MAAA,OAAA,EAAA,QAAA,IAAA,KAAA,OAAA,IAAA,KAAA,OAAA,IAAA,KAAA,OAGA,SAAA,WACA,MAAA,UAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QAGA,eAAA,WACA,MAAA,MAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAEA,GAAA,eAAA,MAAA,MAAA,kBAEA,eAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,MAAA,KAAA,QAEA,GAAA,eAAA,MAAA,MAAA,kBAGA,eAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OACA,KAAA,KAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,SAEA,GAAA,eAAA,MAAA,MAAA,kBAGA,YAAA,WACA,GAAA,GAAA,KAAA,aAAA,EAAA,QAAA,QAAA,MAAA,KAAA,aAAA,EAAA,QAAA,MACA,OAAA,MAAA,MAAA,EAAA,EAAA,EAAA,IAEA,GAAA,YAAA,MAAA,MAAA,eAEA,UAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,EACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,EACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,EACA,EAAA,EAAA,EAAA,IAGA,SAAA,WACA,MAAA,MAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,KACA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,MAAA,KACA,KAAA,MAAA,IAAA,KAAA,MAAA,IAAA,KAAA,OAGA,YAAA,WACA,GAAA,GAAA,SAAA,gBAAA,6BAAA,OAAA,iBAUA,OAPA,GAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,MAEA,GAGA,gBAAA,WAQA,MAAA,UAAA,KAAA,QAAA,GAAA,QAAA,IAAA,IAAA,KAAA,QAAA,GAAA,QAAA,IAAA,IAAA,KAAA,QAAA,GAAA,QAAA,IAAA,IAAA,KAAA,QAAA,GAAA,QAAA,IAAA,IAAA,KAAA,QAAA,GAAA,QAAA,IAAA,IAAA,KAAA,QAAA,GAAA,QAAA,IAAA,KAEA,GAAA,gBAAA,MAAA,MAAA,mBAEA,gBAAA,WAIA,QAAA,GAAA,GAEA,MAAA,GAAA,QAAA,IAGA,OAAA,KAAA,MACA,IAAA,GAAA,SACA,MAAA,EACA,KAAA,GAAA,eACA,MAAA,aAAA,EAAA,KAAA,QAAA,IAAA,IAAA,KAAA,QAAA,GAAA,GACA,KAAA,GAAA,QACA,MAAA,SAAA,EAAA,KAAA,QAAA,KAAA,KAAA,QAAA,KAAA,KAAA,QAAA,GAAA,GAAA,IAAA,EAAA,KAAA,QAAA,KAAA,GACA,SACA,MAAA,UAAA,EAAA,KAAA,QAAA,IAAA,IAAA,EAAA,KAAA,QAAA,IAAA,IAAA,EAAA,KAAA,QAAA,IAAA,IAAA,EAAA,KAAA,QAAA,IAAA,IAAA,EAAA,KAAA,QAAA,IAAA,IAAA,EAAA,KAAA,QAAA,IAAA,MAGA,GAAA,gBAAA,MAAA,MAAA,mBAGA,sBAAA,WACA,GAAA,GAAA,KAAA,iBAGA,QAEA,sBAAA,IACA,8BAAA,SAEA,oBAAA,EAAA,iBACA,iBAAA,EAAA,iBACA,gBAAA,EACA,eAAA,EACA,UAAA,EACA,mBAAA,WACA,uBAAA,aAGA,GAAA,sBAAA,MAAA,MAAA,yBAGA,OAAA,SAAA,GACA,MAAA,MAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OACA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OACA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAIA,cAAA,SAAA,EAAA,GACA,MAAA,MAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAAA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAAA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAAA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAAA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAAA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAAA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAOA,KAAA,WACA,MAAA,IAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,OAIA,KAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAIA,MAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAIA,WAAA,WACA,MAAA,IAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EAAA,UAAA,KAAA,OAAA,EAAA,QAAA,KAAA,KAAA,SAIA,QAAA,WACA,MAAA,IAAA,IACA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,QAIA,SAAA,WACA,GAAA,EAEA,QAAA,KAAA,MACA,IAAA,GAAA,SACA,MAAA,KACA,KAAA,GAAA,eACA,MAAA,IAAA,GAAA,EAAA,GAAA,KAAA,MACA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,EAAA,EAAA,eACA,KAAA,GAAA,QACA,MAAA,IAAA,GAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,EAAA,KAAA,MAAA,EACA,EAAA,EAAA,EAAA,KAAA,MAAA,EAAA,QACA,KAAA,GAAA,OAEA,GADA,EAAA,KAAA,iBACA,IAAA,EACA,MAAA,IAAA,KACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EACA,EAAA,EAAA,EAAA,EAAA,OAGA,MAAA,IAAA,OAAA,kDAGA,KAAA,GAAA,MAEA,GADA,EAAA,KAAA,iBACA,IAAA,EACA,MAAA,IAAA,KACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EACA,EAAA,MAGA,MAAA,IAAA,OAAA,kDAGA,SACA,KAAA,IAAA,OAAA,uCAAA,KAAA,QAIA,YAAA,SAAA,GAEA,GAAA,KAAA,OAAA,EAAA,UAAA,EAAA,OAAA,EAAA,SACA,MAAA,MAAA,OAAA,EAAA,SAAA,EAAA,IAGA,IAAA,KAAA,OAAA,EAAA,KAAA,CAEA,GAAA,KAAA,OAAA,EAAA,eAEA,MAAA,IAAA,GAAA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,EAAA,EAAA,eACA,IAAA,KAAA,OAAA,EAAA,QAEA,MAAA,IAAA,GAAA,KAAA,MAAA,EAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,MAAA,EACA,EAAA,EAAA,EAAA,EAAA,SAIA,MAAA,MAAA,OAAA,EAAA,OAAA,EAAA,OAAA,EAAA,MAIA,GAAA,GAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,EAAA,EAAA,EAAA,EAAA,QAIA,GAAA,GAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAOA,aAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,KACA,OAAA,IAAA,GAAA,QAAA,EAAA,IAGA,aAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CACA,OAAA,IAAA,GAAA,QAAA,EAAA,EAAA,IAGA,sBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CACA,OAAA,IAAA,GAAA,QAAA,EAAA,IAIA,qBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CACA,OAAA,IAAA,GAAA,QAAA,EAAA,IAOA,cAAA,WAIA,MAHA,MAAA,SAAA,WACA,KAAA,IAAA,OAAA,mCAEA,MAGA,SAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAaA,MAZA,MAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EAGA,KAAA,KAAA,SAAA,EAAA,IAAA,GAAA,IAAA,GAAA,IAAA,EAAA,EAAA,OAAA,EAAA,MAAA,EACA,MAGA,YAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,MAAA,MAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGA,IAAA,SAAA,GACA,MAAA,MAAA,SACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAIA,SAAA,SAAA,GACA,MAAA,MAAA,SACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAIA,UAAA,WACA,MAAA,MAAA,SACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,OAAA,EAAA,UAAA,KAAA,OAAA,EAAA,QAAA,KAAA,KAAA,SAIA,OAAA,WACA,MAAA,MAAA,UACA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,QAIA,OAAA,WACA,GAAA,EAEA,QAAA,KAAA,MACA,IAAA,GAAA,SACA,MAAA,KACA,KAAA,GAAA,eACA,MAAA,MAAA,SAAA,EAAA,GAAA,KAAA,MACA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,EAAA,EAAA,eACA,KAAA,GAAA,QACA,MAAA,MAAA,SAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,EAAA,KAAA,MAAA,EACA,EAAA,EAAA,EAAA,KAAA,MAAA,EAAA,QACA,KAAA,GAAA,OAEA,GADA,EAAA,KAAA,iBACA,IAAA,EACA,MAAA,MAAA,WACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EACA,EAAA,EAAA,EAAA,EAAA,OAGA,MAAA,IAAA,OAAA,kDAGA,KAAA,GAAA,MAEA,GADA,EAAA,KAAA,iBACA,IAAA,EACA,MAAA,MAAA,WACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EACA,EAAA,MAGA,MAAA,IAAA,OAAA,kDAGA,SACA,KAAA,IAAA,OAAA,uCAAA,KAAA,QAIA,eAAA,SAAA,GAEA,GAAA,KAAA,OAAA,EAAA,UAAA,EAAA,OAAA,EAAA,SACA,MAAA,MAAA,OAAA,EAAA,SAAA,EAAA,IAGA,IAAA,KAAA,OAAA,EAAA,KAAA,CAEA,GAAA,KAAA,OAAA,EAAA,eAEA,MAAA,MAAA,SAAA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,EAAA,EAAA,eACA,IAAA,KAAA,OAAA,EAAA,QAEA,MAAA,MAAA,SAAA,KAAA,MAAA,EAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,MAAA,EACA,EAAA,EAAA,EAAA,EAAA,SAIA,MAAA,MAAA,OAAA,EAAA,OAAA,EAAA,OAAA,EAAA,MAIA,KAAA,SAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,EAAA,EAAA,EAAA,EAAA,QAIA,KAAA,SAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAOA,gBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,KAGA,OAFA,GAAA,KAAA,GACA,EAAA,KAAA,GACA,GAGA,gBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CAIA,OAHA,GAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,GAGA,yBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CAGA,OAFA,GAAA,KAAA,GACA,EAAA,KAAA,GACA,GAGA,wBAAA,SAAA,GACA,GAAA,GAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,EAAA,KAAA,MAAA,EAAA,CAGA,OAFA,GAAA,KAAA,GACA,EAAA,KAAA,GACA,GAIA,mBAAA,SAAA,GACA,EAAA,aAEA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,KAKA,sBAAA,SAAA,GACA,KAAA,OAAA,EAAA,UACA,EAAA,UAEA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,GACA,KAAA,QAAA,MAOA,EAAA,SAAA,GAAA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,UACA,EAAA,SAAA,gBAEA,EAAA,aAAA,GAAA,GAAA,GAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,QACA,EAAA,aAAA,gBAEA,EAAA,aAAA,GAAA,GAAA,EAAA,EAAA,EACA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,QACA,EAAA,aAAA,gBAEA,EAAA,SACA,MAAA,SAAA,GACA,QAAA,IAAA,EAAA,cAIA,ICpxBA,EAAA,kBAAA,UAAA,gBAAA,UAAA,cAAA,cAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,OAEA,EAAA,EAAA,UAEA,GAAA,eACA,EAAA,eACA,EAAA,YAGA,EAAA,WAAA,SAAA,GACA,KAAA,aAGA,KAAA,IAAA,SAAA,EAAA,EAAA,QAAA,SAAA,GAEA,IAAA,GAAA,EAAA,UA+MA,OA7MA,GAAA,WACA,YAAA,EAMA,IAAA,SAAA,GAEA,GAAA,EAAA,YAAA,GAAA,QAEA,IAEA,GAFA,EAAA,KAAA,OACA,EAAA,KAAA,UAAA,MAIA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,UAAA,GAAA,OAAA,EAAA,EAWA,KARA,KAAA,OAAA,EAGA,KAAA,QAAA,KACA,KAAA,iBAAA,KACA,KAAA,kBAAA,KAGA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,UAAA,GAAA,MAAA,EAAA,IAIA,QAAA,SAAA,GACA,KAAA,IAAA,EAAA,YAAA,KAAA,UAGA,OAAA,SAAA,GACA,KAAA,IAAA,KAAA,OAAA,YAAA,KAGA,iBAAA,SAAA,GACA,KAAA,QAAA,EAAA,SAGA,gBAAA,SAAA,GACA,KAAA,OAAA,EAAA,SAGA,qBAAA,SAAA,GACA,EAAA,aAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,QAQA,KAAA,WACA,GAAA,GAAA,GAAA,GAAA,KAAA,OACA,GAAA,QAAA,KAAA,QACA,EAAA,iBAAA,KAAA,iBACA,EAAA,kBAAA,KAAA,mBAIA,SAAA,WACA,GAAA,GAAA,GAAA,GAAA,KAAA,OAAA,OACA,GAAA,QAAA,KAAA,QAAA,KAAA,QAAA,OAAA,KACA,EAAA,iBAAA,KAAA,iBAAA,KAAA,iBAAA,OAAA,KACA,EAAA,kBAAA,KAAA,kBAAA,KAAA,kBAAA,OAAA,MAGA,UAAA,WACA,MAAA,MAAA,QAGA,WAAA,WAIA,MAHA,QAAA,KAAA,UACA,KAAA,QAAA,KAAA,OAAA,YAEA,KAAA,SAGA,oBAAA,WAIA,MAHA,QAAA,KAAA,mBACA,KAAA,iBAAA,KAAA,OAAA,cAEA,KAAA,kBAGA,qBAAA,WAIA,MAHA,QAAA,KAAA,oBACA,KAAA,kBAAA,KAAA,aAAA,cAEA,KAAA,mBAGA,WAAA,WACA,MAAA,MAAA,OAAA,OAAA,EAAA,QAAA,MAAA,UAGA,SAAA,WACA,MAAA,MAAA,OAAA,YAQA,mBAAA,SAAA,GACA,MAAA,MAAA,OAAA,aAAA,IAIA,gBAAA,SAAA,GAEA,MAAA,MAAA,mBAAA,GAAA,MAAA,KAAA,mBAAA,EAAA,QAAA,QAIA,iBAAA,SAAA,GACA,MAAA,MAAA,aAAA,sBAAA,IAGA,gBAAA,SAAA,GACA,MAAA,MAAA,gBAAA,GAAA,GAAA,QAAA,EAAA,IAAA,GAGA,gBAAA,SAAA,GACA,MAAA,MAAA,gBAAA,GAAA,GAAA,QAAA,EAAA,IAAA,GAGA,iBAAA,SAAA,GACA,MAAA,GAAA,YAAA,KAAA,SAGA,eAAA,SAAA,GACA,MAAA,GAAA,YAAA,KAAA,SAGA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,mBAAA,EAAA,KAAA,KAAA,gBAAA,EAAA,KAAA,eAOA,iBAAA,SAAA,GACA,MAAA,MAAA,aAAA,aAAA,IAGA,cAAA,SAAA,GAEA,MAAA,MAAA,iBAAA,GAAA,MAAA,KAAA,iBAAA,EAAA,QAAA,QAGA,eAAA,SAAA,GACA,MAAA,MAAA,OAAA,sBAAA,IAGA,cAAA,SAAA,GACA,MAAA,MAAA,cAAA,GAAA,GAAA,QAAA,EAAA,IAAA,GAGA,cAAA,SAAA,GACA,MAAA,MAAA,cAAA,GAAA,GAAA,QAAA,EAAA,IAAA,GAGA,eAAA,SAAA,GACA,MAAA,GAAA,YAAA,KAAA,eAGA,aAAA,SAAA,GACA,MAAA,GAAA,YAAA,KAAA,eAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,iBAAA,EAAA,KAAA,KAAA,cAAA,EAAA,KAAA,eAQA,qBAAA,SAAA,GACA,GAAA,GAAA,EAAA,SAAA,KAAA,UAAA,IACA,KAAA,UAAA,KAAA,IAIA,yBAAA,SAAA,GACA,GAAA,GAAA,EAAA,SAAA,KAAA,UAAA,IACA,KAAA,UAAA,QAAA,IAGA,wBAAA,SAAA,GACA,GAAA,EAAA,EAAA,SAAA,KAAA,UAAA,IACA,KAAA,UAAA,OAAA,EAAA,QAAA,KAAA,UAAA,GAAA,KAIA,ICjOA,EAAA,yBAAA,UAAA,gBAAA,YAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,QAEA,EAAA,EAAA,aAEA,EAAA,EAAA,WAyBA,GAAA,QAAA,YACA,IAAA,GAAA,EAAA,OAiCA,OA/BA,GAAA,WACA,YAAA,EAGA,aAAA,SAAA,EAAA,GAIA,IAAA,GAFA,GAAA,KACA,KACA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAEA,GAAA,GAAA,EAAA,GACA,EAAA,EAAA,WAAA,EAAA,EACA,IAAA,EAAA,IAAA,EAAA,QACA,EAAA,KAAA,EAAA,IACA,EAAA,EAAA,EAGA,KAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,GAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAIA,MADA,GAAA,KAAA,GACA,GAIA,uBAAA,WACA,MAAA,MAAA,aAAA,KAAA,0BAIA,IClEA,EAAA,sBAAA,UAAA,gBAAA,YAAA,oBAAA,cAAA,WAAA,yBAAA,SAAA,GAGA,EAAA,iBAAA,QAEA,EAAA,YAEA,IAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,YAAA,qBAEA,EAAA,EAAA,wBAwHA,OAtHA,GAAA,KAAA,SAAA,EAAA,GAIA,MAHA,MAAA,MAAA,EACA,KAAA,IAAA,EAEA,EAAA,OAAA,EAAA,IACA,KAAA,SAAA,EACA,SAGA,KAAA,aAAA,EAAA,MAAA,GAAA,aACA,KAAA,WAAA,KAAA,aAGA,KAAA,OAAA,EAAA,QAAA,UAAA,GAAA,UAAA,GAJA,SAMA,EAAA,EAAA,EAAA,MAEA,WAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,KAAA,IAAA,MAAA,KAAA,OAAA,MAAA,KAGA,UAAA,WAEA,MAAA,MAAA,cAGA,YAAA,WACA,MAAA,IAGA,mBAAA,WACA,MAAA,KAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,GAGA,WAAA,SAAA,GACA,GAAA,GAAA,KAAA,WAAA,gBAAA,UAAA,MAAA,EAAA,EACA,QAAA,GAAA,GAAA,KAAA,KAAA,MAAA,KAAA,GAAA,KAAA,IAAA,KAAA,MAGA,YAAA,SAAA,GACA,GAAA,GAAA,KAAA,aAAA,gBAAA,MAAA,EAAA,EACA,QAAA,GAAA,GAAA,KAAA,KAAA,IAAA,KAAA,GAAA,KAAA,MAAA,KAAA,MAIA,qBAAA,WAAA,UAEA,WAAA,SAAA,GACA,GAAA,GAAA,KAAA,WAAA,EACA,QACA,GAAA,GAAA,KAAA,KAAA,MAAA,GACA,GAAA,GAAA,KAAA,EAAA,KAAA,OAIA,iBAAA,WACA,KAAA,IAAA,OAAA,gDAGA,aAAA,SAAA,GACA,GAAA,MAEA,EAAA,KAAA,MACA,EAAA,KAAA,IAEA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,IAAA,KAAA,EAAA,KAEA,KAAA,SAAA,EAAA,KAAA,SAAA,EAAA,GAEA,MAAA,EAIA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,MAAA,EAEA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,MAAA,EAIA,IAAA,GAAA,EAAA,MAAA,EAAA,KAAA,IAAA,EAAA,IACA,IAAA,EAAA,EACA,MAAA,EAIA,IAAA,GAAA,EAAA,MAAA,GACA,EAAA,EAAA,eAOA,OANA,GAAA,MACA,SAAA,EACA,MAAA,EAAA,gBAAA,GACA,OAAA,EAAA,IAAA,EAAA,KAAA,EAAA,EAAA,UAAA,EACA,KAAA,EAAA,IAAA,gBAAA,IAAA,GAAA,EAAA,EAAA,KAEA,GAIA,oBAAA,SAAA,GACA,GAAA,GAAA,KAAA,aAAA,EACA,OAAA,GAAA,OACA,EAAA,GAAA,KAEA,GAKA,eAAA,SAAA,GACA,EAAA,OAAA,KAAA,IAAA,EAAA,KAAA,IAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,aAAA,KAAA,OAAA,EAAA,aAAA,KAAA,SAIA,EAAA,OCnIA,EAAA,qBAAA,UAAA,gBAAA,YAAA,oBAAA,cAAA,cAAA,WAAA,yBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,OAEA,GAAA,YAEA,IAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,YAEA,EAAA,EAAA,wBAmTA,OAjTA,GAAA,IAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAqEA,QAAA,GAAA,GACA,EAAA,cAAA,KAEA,EAAA,OAAA,EAAA,OAAA,UAAA,EAAA,KAAA,EAAA,YAAA,EAAA,MArDA,GAlBA,EAAA,IAEA,GAAA,EACA,GAAA,KAAA,GACA,GAAA,KAAA,IAGA,KAAA,OAAA,EACA,KAAA,OAAA,EACA,KAAA,WAAA,EACA,KAAA,SAAA,EACA,KAAA,cAAA,EAEA,KAAA,MAAA,KAAA,gBAAA,GACA,KAAA,IAAA,KAAA,gBAAA,GACA,KAAA,aAAA,KAAA,eAAA,GACA,KAAA,WAAA,KAAA,eAAA,GAEA,GAAA,GAAA,IAAA,EAEA,MADA,MAAA,SAAA,EACA,MAQA,MAAA,eAJA,KAAA,cAGA,KAAA,WAAA,KAAA,SACA,KAAA,SACA,KAAA,WAAA,KAAA,SACA,KAAA,SAAA,EAAA,KAAA,GAGA,KAAA,WAKA,KAAA,WAAA,KAAA,SACA,KAAA,SACA,KAAA,WAAA,KAAA,SACA,KAAA,SAAA,EAAA,KAAA,GAGA,KAAA,WAKA,GAAA,KAAA,GAAA,EAAA,GAAA,GAAA,KAAA,IAAA,GAAA,EAAA,GAAA,GAAA,KAAA,IAAA,6FACA,GAAA,KAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,8FAEA,GAAA,EAAA,GAAA,EAAA,KAAA,IAAA,GAAA,EAAA,GAAA,EAAA,KAAA,GAGA,KAAA,gBAAA,KAAA,cAAA,KAAA,WAAA,KAAA,SAAA,KAAA,SAAA,KAAA,WACA,KAAA,gBAAA,IACA,KAAA,iBAAA,EAAA,KAAA,IAEA,GAAA,EAAA,KAAA,iBAAA,GAGA,KAAA,OAAA,EAAA,QACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,IAGA,IAAA,GAAA,IASA,KAAA,IAEA,EAAA,GACA,EAAA,KAAA,GAAA,GACA,EAAA,KAAA,IACA,EAAA,EAAA,KAAA,GAAA,KAGA,EAAA,EAAA,EAAA,KAGA,SAAA,SAAA,GAEA,MAAA,MAAA,WAAA,KAAA,eACA,EAAA,gBAAA,EAAA,KAAA,WAAA,EAAA,KAAA,GAAA,KAAA,YACA,EAAA,kBAAA,EAAA,KAAA,WAAA,KAAA,WAAA,EAAA,KAAA,KAGA,SAAA,SAAA,GACA,OAAA,KAAA,SAAA,GAAA,KAAA,aAAA,KAAA,eAAA,KAAA,aAGA,QAAA,SAAA,GACA,MAAA,MAAA,YAAA,KAAA,eAAA,KAAA,YAAA,GAGA,WAAA,SAAA,GACA,MAAA,MAAA,gBAAA,KAAA,QAAA,KAGA,UAAA,SAAA,GACA,MAAA,MAAA,eAAA,KAAA,QAAA,KAGA,YAAA,WACA,OAAA,KAAA,cAAA,GAAA,GAAA,KAAA,QAGA,gBAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,YAAA,KAAA,OAAA,KAGA,eAAA,SAAA,GACA,GAAA,GAAA,EAAA,YAAA,EAAA,EAEA,OAAA,MAAA,cAAA,EAAA,gBAAA,EAAA,gBAAA,WAIA,cAAA,SAAA,GAGA,GAAA,GAAA,KAAA,cAAA,EAAA,KAAA,SAAA,EAAA,KAAA,WAGA,EAAA,EAAA,kBAAA,EAAA,EAAA,EAAA,KAAA,GAEA,OAAA,IAAA,KAAA,iBAGA,mBAAA,WAIA,GAEA,GAFA,EAAA,IACA,EAAA,KAAA,cAAA,IAAA,GAEA,IAAA,KAAA,gBAAA,EAAA,KAAA,GAAA,EAEA,MADA,GAAA,KAAA,gBAAA,KAAA,GAAA,IAAA,IACA,KAAA,KAAA,OAAA,IAAA,KAAA,OAAA,MAAA,EAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,CAMA,IAAA,IAAA,KAAA,WAAA,KAAA,UAAA,EACA,EAAA,KAAA,OAAA,KAAA,EAAA,YAAA,KAAA,OAAA,GAEA,GAAA,GAEA,IAAA,GAAA,KAAA,KAAA,OAAA,IAAA,KAAA,OAAA,MAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,IAAA,EAAA,EACA,EAAA,KAAA,KAAA,OAAA,IAAA,KAAA,OAAA,MAAA,EAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,CAEA,OAAA,GAAA,IAAA,GAIA,WAAA,SAAA,GACA,OAAA,GAAA,GAAA,IAAA,KAAA,OAAA,KAAA,QAAA,KAAA,cAAA,EAAA,IAAA,EAAA,EAAA,KAAA,WAAA,KAAA,SAAA,KAAA,iBAGA,YAAA,SAAA,GACA,OAAA,GAAA,GAAA,IAAA,KAAA,OAAA,KAAA,QAAA,KAAA,cAAA,GAAA,GAAA,EAAA,EAAA,KAAA,SAAA,KAAA,YAAA,KAAA,iBAIA,qBAAA,WACA,GAAA,GAAA,KACA,IAUA,OATA,GAAA,MAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,GAAA,SAAA,GACA,GAAA,EAAA,cAAA,GAAA,CACA,GAAA,GAAA,EAAA,SAAA,GACA,EAAA,KACA,GAAA,GAAA,EAAA,EAAA,GACA,EAAA,KAAA,MAIA,EAAA,QAGA,WAAA,SAAA,GAEA,GAAA,GAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,EACA,QACA,GAAA,GAAA,IAAA,KAAA,OAAA,KAAA,OAAA,EAAA,EAAA,KAAA,eACA,GAAA,GAAA,IAAA,KAAA,OAAA,KAAA,OAAA,EAAA,EAAA,KAAA,iBAIA,iBAAA,WACA,KAAA,IAAA,OAAA,4CAGA,aAAA,SAAA,GACA,GAAA,MAGA,EAAA,EAKA,EAAA,EAAA,IAAA,MAAA,KAAA,QACA,EAAA,EAAA,IAAA,IAAA,GACA,EAAA,EAAA,mBACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,KAAA,OAAA,KAAA,OACA,IAAA,EAAA,EAEA,MAAA,EAEA,IAAA,GAAA,EAAA,IAAA,IAAA,KAAA,QAAA,EAAA,IAAA,IAAA,EAAA,KACA,EAAA,KAAA,KAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,CAEA,IAAA,EAAA,EAEA,MAAA,EAGA,IAAA,GAAA,EAAA,gBAAA,GACA,EAAA,EAAA,MAAA,KAAA,QAAA,YAEA,IAAA,EAAA,EAEA,KAAA,cAAA,EAAA,UACA,EAAA,MACA,SAAA,EACA,MAAA,EACA,OAAA,EAAA,UACA,KAAA,KAAA,cAAA,GAAA,QAIA,CAEA,GAAA,GAAA,EAAA,gBAAA,GACA,EAAA,EAAA,MAAA,KAAA,QAAA,YAEA,MAAA,cAAA,EAAA,UACA,EAAA,MACA,SAAA,EACA,MAAA,EACA,OAAA,EACA,KAAA,KAAA,cAAA,EAAA,KAGA,KAAA,cAAA,EAAA,UACA,EAAA,MACA,SAAA,EACA,MAAA,EACA,OAAA,EAAA,UACA,KAAA,KAAA,cAAA,GAAA,IAKA,MAAA,IAIA,oBAAA,SAAA,GACA,GAAA,GAAA,EACA,EAAA,KAAA,aAAA,EAIA,OAHA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,EAAA,OAEA,GAGA,eAAA,SAAA,GACA,EAAA,IAAA,KAAA,OAAA,EAAA,KAAA,OAAA,EAAA,KAAA,OAAA,KAAA,WAAA,KAAA,SAAA,KAAA,gBAIA,YAAA,SAAA,GAEA,GAAA,GAAA,EAAA,aAAA,EAAA,YAAA,EAAA,KAAA,aAAA,MAAA,EAAA,aAAA,EAAA,OAAA,QACA,EAAA,EAAA,aAAA,EAAA,YAAA,EAAA,KAAA,WAAA,MAAA,EAAA,aAAA,EAAA,OAAA,QAGA,EAAA,EAAA,kBAAA,EAAA,KAAA,eAAA,KAAA,cAEA,EAAA,EAAA,gBACA,IAAA,EAAA,IAAA,EAAA,EAAA,CACA,GAAA,GAAA,EAAA,EAAA,KAAA,OACA,EAAA,EAAA,EAAA,KAAA,MACA,OAAA,IAAA,GAAA,cAAA,EAAA,aAAA,KAAA,QAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAEA,GAAA,GAAA,EAAA,EAAA,KAAA,MACA,OAAA,IAAA,GAAA,IAAA,EAAA,aAAA,KAAA,QAAA,EAAA,EAAA,EAAA,MAKA,EAAA,MC5TA,EAAA,qBAAA,UAAA,gBAAA,cAAA,cAAA,WAAA,YAAA,qBAAA,qBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,OAEA,GAAA,cACA,IAAA,GAAA,EAAA,eACA,EAAA,EAAA,YAAA,qBAEA,EAAA,EAAA,YAEA,GAAA,sBACA,EAAA,qBAGA,EAAA,QAAA,SAAA,EAAA,EAAA,GACA,KAAA,SAAA,MAGA,KAAA,OAAA,IAAA,GAAA,EAAA,OAAA,EAAA,IAAA,EAAA,SAAA,GAAA,MAAA,GAAA,QAAA,OAAA,EAAA,EAAA,OAAA,GAAA,SACA,KAAA,SAAA,EAGA,KAAA,iBAAA,KACA,KAAA,0BAAA,EACA,KAAA,eAAA,KAEA,IAAA,GAAA,EAAA,OAuRA,OAtRA,GAAA,WACA,KAAA,WACA,MAAA,IAAA,GAAA,KAAA,SAAA,MAAA,GAAA,KAAA,OAAA,MAAA,GAAA,KAAA,SAGA,WAAA,WACA,KAAA,0BAAA,GAGA,SAAA,SAAA,GAGA,MAFA,MAAA,OAAA,KAAA,GAEA,MAGA,WAAA,SAAA,GAWA,MAVA,GAAA,UACA,GAAA,EAAA,EAAA,MAAA,WAAA,6BACA,GAAA,EAAA,EAAA,IAAA,WAAA,2BACA,GAAA,EAAA,EAAA,aAAA,WAAA,oCACA,GAAA,EAAA,EAAA,WAAA,WAAA,kCACA,GAAA,EAAA,EAAA,OAAA,WAAA,EAAA,OAAA,WAAA,4CACA,KAAA,SAAA,KAAA,GACA,KAAA,cAGA,MAGA,MAAA,WACA,KAAA,QAAA,GAGA,UAAA,WACA,MAAA,MAAA,OAAA,QAGA,cAAA,WACA,MAAA,GAAA,MAAA,KAAA,SAGA,aAAA,WACA,MAAA,GAAA,KAAA,KAAA,SAGA,gBAAA,WACA,MAAA,GAAA,MAAA,KAAA,WAGA,eAAA,WACA,MAAA,GAAA,KAAA,KAAA,WAGA,WAAA,WACA,MAAA,MAAA,SAAA,OAAA,GAGA,SAAA,WACA,MAAA,MAAA,QAGA,kBAAA,WACA,OAAA,KAAA,gBAAA,cAAA,KAAA,eAAA,OAGA,kBAAA,WAEA,MADA,IAAA,EAAA,KAAA,oBAAA,+DACA,GAAA,GAAA,QAAA,KAAA,KAAA,eAAA,KAAA,kBAGA,eAAA,SAAA,GACA,GAAA,KAAA,aAAA,CACA,GAAA,GAAA,KAAA,kBAAA,KACA,GAAA,OAAA,EAAA,EAAA,EAAA,GAEA,EAAA,KAAA,KAAA,SAAA,SAAA,GACA,EAAA,eAAA,KAGA,KAAA,QACA,EAAA,cAKA,YAAA,SAAA,GACA,MAAA,IAAA,GACA,EAAA,IAAA,KAAA,SAAA,SAAA,GAAA,MAAA,GAAA,YAAA,KACA,EAAA,IAAA,KAAA,OAAA,SAAA,GAAA,MAAA,GAAA,aAAA,KACA,KAAA,SAIA,cAAA,WACA,MAAA,GAAA,OAAA,KAAA,SAAA,SAAA,EAAA,GACA,MAAA,GAAA,MAAA,EAAA,SACA,EAAA,UAIA,QAAA,SAAA,GAmBA,QAAA,GAAA,EAAA,EAAA,GAEA,GAAA,GAAA,EAAA,KAAA,EAAA,gBAAA,UAAA,MAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,gBAAA,UAAA,MAAA,EAAA,IAEA,EAAA,EAAA,OAAA,OAAA,GAAA,GAAA,QAAA,KAAA,EAAA,GAGA,MAAA,EAAA,gBAAA,IAAA,GAAA,GA2BA,MAAA,EA1BA,QAAA,EAAA,UACA,IAAA,QACA,GAAA,GAAA,EAAA,QAAA,KAAA,GAAA,EACA,EAAA,EAAA,QAAA,KAAA,GAAA,CACA,QAAA,GAAA,GAAA,QAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GACA,KAAA,QACA,GAAA,GAAA,EAAA,aAAA,EAAA,UAEA,IADA,EAAA,KAAA,GAAA,KACA,EAAA,KAAA,IAAA,EAAA,IAAA,EAAA,YAAA,EAAA,KAAA,GAAA,KAAA,CAEA,GAAA,GAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GACA;OACA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,GAAA,GAAA,QAAA,KAAA,EAAA,IAIA,MAAA,EAGA,KAAA,QACA,MAAA,IAUA,QAAA,GAAA,EAAA,GACA,GAAA,GAAA,EAAA,KAAA,EAAA,gBAAA,OAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,gBAAA,MAAA,EAAA,GAEA,QAAA,EAAA,SACA,IAAA,OACA,OAAA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,KAAA,QACA,GAAA,GAAA,EAAA,OACA,QAAA,GAAA,GAAA,QAAA,IAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GAAA,GAAA,GACA,KAAA,SACA,GAAA,GAAA,EAAA,gBAAA,UAAA,MAAA,EAAA,GACA,EAAA,EAAA,gBAAA,MAAA,EAAA,GACA,EAAA,EAAA,MAAA,EAAA,GAEA,EAAA,EAAA,KAAA,GAAA,KAAA,GACA,EAAA,EAAA,KAAA,GAAA,KAAA,EACA,QACA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,GAAA,GAAA,QAAA,KAAA,EAAA,KAWA,QAAA,GAAA,GACA,EAAA,KAAA,EAAA,SAAA,GAAA,EAAA,KAAA,KAEA,QAAA,GAAA,GACA,EAAA,KAAA,EAAA,SAAA,GAAA,EAAA,KAAA,KA5FA,IAAA,KAAA,aACA,MAAA,IAAA,EAQA,IALA,SAAA,IACA,EAAA,GAAA,GAAA,YAIA,KAAA,0BAAA,KAAA,eAAA,OAAA,GACA,MAAA,MAAA,gBAGA,IAqEA,GArEA,EAAA,EAAA,UAsEA,KACA,KACA,EAAA,KAAA,kBACA,EAAA,KAAA,iBAUA,EAAA,EAAA,IAAA,OAAA,EAAA,OAEA,EAAA,EAAA,KAAA,GAAA,GAAA,QAAA,KAAA,KAAA,SAAA,KAAA,SAAA,OAAA,GAAA,IAAA,KAAA,SAAA,GAAA,MAGA,KAAA,EAAA,EAAA,EAAA,KAAA,SAAA,OAAA,IACA,EAAA,GACA,EAAA,EAAA,KAAA,SAAA,GAAA,MAAA,KAAA,SAAA,EAAA,GAAA,WAAA,KAAA,SAAA,GAAA,cAAA,IAEA,EAAA,KAAA,SAAA,GAAA,WAAA,GAIA,KAAA,EAAA,KAAA,SAAA,OAAA,EAAA,GAAA,EAAA,IACA,EAAA,KAAA,SAAA,OAAA,GACA,EAAA,EAAA,KAAA,SAAA,GAAA,IAAA,KAAA,SAAA,EAAA,GAAA,aAAA,UAAA,KAAA,SAAA,GAAA,WAAA,WAAA,IAEA,EAAA,KAAA,SAAA,GAAA,YAAA,GAGA,IAAA,EAmCA,OAlCA,MAAA,QACA,GAEA,EAAA,EAAA,EAAA,IAAA,EAAA,WAAA,EAAA,eACA,EAAA,EAAA,EAAA,IAAA,EAAA,aAAA,UAAA,EAAA,WAAA,cAGA,EAAA,EAAA,EAAA,MAAA,EAAA,WAAA,EAAA,eACA,EAAA,EAAA,WAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,WAAA,EAAA,eAGA,EAAA,EAAA,EAAA,IAAA,EAAA,aAAA,UAAA,EAAA,WAAA,YACA,EAAA,EAAA,YAAA,IACA,EAAA,EAAA,EAAA,MAAA,EAAA,aAAA,UAAA,EAAA,WAAA,aAEA,GACA,GAAA,GAAA,EAAA,MAAA,GACA,GAAA,GAAA,EAAA,MAAA,KAGA,GACA,GAAA,GAAA,EACA,OAAA,EAAA,EAAA,IAAA,EAAA,aACA,OAAA,GACA,OAAA,EAAA,EAAA,MAAA,EAAA,aAAA,YACA,MAAA,IAIA,KAAA,iBAAA,EACA,KAAA,0BAAA,EACA,KAAA,eAAA,GAAA,GAAA,WAAA,GAEA,IAyBA,EAAA,UC3TA,EAAA,0BAAA,UAAA,aAAA,SAAA,GAUA,QAAA,GAAA,GAWA,MAAA,IAAA,EACA,QAAA,MAAA,QACA,QAAA,KAAA,OACA,QAAA,QAAA,OACA,QAAA,MAAA,OACA,QAAA,MAAA,OACA,QAAA,MAAA,OACA,QAAA,MAAA,OACA,QAAA,uCAAA,QACA,IA5BA,GAAA,GAAA,EAAA,YA+BA,GAAA,SAOA,MAAA,SAAA,EAAA,GAqFA,QAAA,GAAA,GACA,EAAA,IAIA,EAAA,IACA,EAAA,EACA,MAGA,EAAA,KAAA,IAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EACA,EAAA,CAMA,KAJA,EAAA,EACA,EAAA,EACA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,IAAA,OAAA,EAGA,GAFA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,MAGA,GAAA,KACA,EAAA,CAQA,OANA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAKA,IAHA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAkBA,OAhBA,QAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAKA,IAHA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,OANA,QAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,OAAA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAKA,IAHA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAkBA,OAhBA,QAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,EA2BA,OAzBA,GAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,YASA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,GAAA,IAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,GAAA,IAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GACA,CA6BA,OA3BA,GAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,SAIA,OAAA,IACA,EAAA,WAAA,OAAA,IAAA,UAAA,EAAA,IAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,SAAA,MAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,iBAAA,MAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,mBAAA,MAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,2BAAA,MAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,iBAAA,MAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,yBAAA,MAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,eAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,uBAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,qBAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,6BAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA8BA,OA5BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,mBAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,2BAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA8BA,OA5BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,yBAAA,MAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,iCAAA,MAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAaA,IAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,kBAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAYA,GAXA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,IAAA,SAAA,GAAA,OAAA,IAAA,0BAAA,KAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAwCA,OAtCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,CAiFA,OA/EA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,MAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA8BA,OA5BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GACA,CAoBA,OAlBA,GAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,YAAA,EAAA,KAAA,EAAA,IAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,UAAA,EAAA,KAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EACA,EAAA,CAgDA,OA9CA,GAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,YAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,UAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GACA,CAoCA,OAlCA,GAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,EAAA,WAAA,OAAA,GAAA,IAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,EAAA,WAAA,OAAA,GAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EACA,CAIA,IAFA,EAAA,EACA,EAAA,IACA,OAAA,EAEA,IADA,KACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,QAGA,GAAA,IAEA,IAAA,OAAA,EAGA,GAFA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,MAGA,GAAA,KACA,EAAA,CAEA,IAAA,OAAA,EAGA,GAFA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,OAGA,GAAA,KACA,EAAA,CAGA,OAAA,GAGA,QAAA,KACA,GAAA,EAWA,OATA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,EAGA,QAAA,KACA,GAAA,GAAA,EACA,EAAA,CA+CA,OA7CA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAqEA,OAnEA,GAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,IAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAiDA,OA/CA,GAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,SAIA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,MAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,EAsBA,OApBA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,SAIA,EAGA,QAAA,KACA,GAAA,GAAA,EACA,EAAA,CA0BA,OAxBA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAEA,EAAA,KACA,EAAA,KAGA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,KAEA,EAGA,QAAA,KACA,GAAA,EAWA,OATA,SAAA,KAAA,EAAA,OAAA,KACA,EAAA,EAAA,OAAA,GACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,UAGA,EAGA,QAAA,KACA,GAAA,EA4CA,OA1CA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,IAAA,EAAA,WAAA,IACA,EAAA,IACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,UAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,KACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,UAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,KACA,MAEA,EAAA,KACA,IAAA,GACA,EAAA,aAMA,EAIA,QAAA,GAAA,GACA,EAAA,MAIA,KAAA,GAFA,GAAA,KACA,KACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,KAAA,IACA,EAAA,KAAA,EAAA,IACA,EAAA,EAAA,GAGA,OAAA,GAGA,QAAA,KAYA,IAAA,GAJA,GAAA,EACA,EAAA,EACA,GAAA,EAEA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,GAAA,IAAA,CACA,GAAA,GAAA,EAAA,OAAA,EACA,QAAA,GACA,GAAA,IACA,EAAA,EACA,GAAA,GACA,OAAA,GAAA,WAAA,GAAA,WAAA,GACA,IACA,EAAA,EACA,GAAA,IAEA,IACA,GAAA,GAIA,OAAA,KAAA,EAAA,OAAA,GAIA,QAAA,GAAA,EAAA,GACA,GAAA,KACA,IAAA,EAAA,iBAAA,SACA,MAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAIA,IAAA,EAAA,OAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,MACA,IAAA,EAAA,iBAAA,SACA,MAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAIA,OAAA,GA7yEA,GAAA,IACA,QAAA,EACA,0BAAA,EACA,yBAAA,EACA,eAAA,EACA,cAAA,EACA,OAAA,EACA,uBAAA,EACA,UAAA,EACA,OAAA,EACA,uBAAA,EACA,iBAAA,EACA,iCAAA,EACA,eAAA,EACA,+BAAA,EACA,QAAA,EACA,wBAAA,EACA,gBAAA,EACA,cAAA,EACA,8BAAA,EACA,sBAAA,EACA,uBAAA,EACA,uCAAA,EACA,+BAAA,EACA,6BAAA,EACA,6CAAA,EACA,cAAA,EACA,8BAAA,EACA,sBAAA,EACA,eAAA,EACA,kBAAA,EACA,OAAA,EACA,KAAA,EACA,SAAA,EACA,MAAA,EACA,sBAAA,EACA,mBAAA,EACA,SAAA,EACA,KAAA,EACA,cAAA,EACA,MAAA,EACA,IAAA,EAGA,IAAA,SAAA,GACA,GAAA,SAAA,EAAA,GACA,KAAA,IAAA,OAAA,sBAAA,EAAA,GAAA,SAGA,GAAA,SAGA,IAAA,GAAA,EACA,EAAA,EACA,EAAA,EACA,KA0vEA,EAAA,EAAA,IA0BA,IAAA,OAAA,GAAA,IAAA,EAAA,OAAA,CACA,GAAA,IAAA,KAAA,IAAA,EAAA,GACA,GAAA,GAAA,EAAA,OAAA,EAAA,OAAA,IAAA,KACA,GAAA,GAEA,MAAA,IAAA,MAAA,YACA,EAAA,GACA,GACA,GACA,GAAA,KACA,GAAA,QAIA,MAAA,IAIA,SAAA,WAAA,MAAA,MAAA,SAEA,IAAA,GAAA,EAAA,OAqCA,OAjCA,GAAA,YAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,QAAA,GAAA,EAAA,GACA,GAAA,GAAA,CAEA,QAAA,EAAA,QACA,IAAA,GACA,EAAA,cACA,MACA,KAAA,GACA,EAAA,EAAA,EACA,MACA,SACA,EAAA,EAAA,MAAA,EAAA,EAAA,OAAA,GAAA,KAAA,MACA,OACA,EAAA,EAAA,OAAA,GAKA,MAFA,GAAA,EAAA,EAAA,GAAA,eAEA,YAAA,EAAA,QAAA,EAAA,UAGA,KAAA,KAAA,cACA,KAAA,SAAA,EACA,KAAA,MAAA,EACA,KAAA,QAAA,EAAA,EAAA,GACA,KAAA,OAAA,EACA,KAAA,KAAA,EACA,KAAA,OAAA,GAGA,EAAA,YAAA,UAAA,MAAA,UAEA,ICv6EA,EAAA,wBAAA,UAAA,gBAAA,aAAA,SAAA,GAGA,EAAA,iBAAA,OAEA,IAAA,GAAA,EAAA,YAEA,GAAA,WAAA,SAAA,GACA,SAAA,IACA,MAEA,KAAA,UAAA,SAAA,EAAA,UAAA,EAAA,UAAA,EACA,KAAA,QAAA,SAAA,EAAA,QAAA,EAAA,QAAA,OACA,KAAA,SAAA,SAAA,EAAA,SAAA,EAAA,SAAA,QACA,KAAA,SAAA,SAAA,EAAA,SAAA,EAAA,SAAA,KACA,KAAA,eAAA,SAAA,EAAA,eAAA,EAAA,eAAA,EACA,KAAA,WAAA,SAAA,EAAA,WAAA,EAAA,WAAA,GAEA,IAAA,GAAA,EAAA,UAuCA,OAtCA,GAAA,WACA,YAAA,EAEA,OAAA,SAAA,GACA,GAAA,GAAA,KAAA,YAAA,EAAA,WACA,KAAA,UAAA,EAAA,SACA,KAAA,WAAA,EAAA,UACA,KAAA,aAAA,EAAA,YACA,KAAA,iBAAA,EAAA,cACA,KAAA,EACA,OAAA,CAMA,KAAA,KAAA,WAAA,EAAA,SAEA,OAAA,CAGA,IAAA,KAAA,SAAA,CACA,GAAA,KAAA,SAAA,SAAA,EAAA,SAAA,OACA,OAAA,CAEA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,SAAA,OAAA,IACA,GAAA,KAAA,SAAA,KAAA,EAAA,SAAA,GACA,OAAA,CAGA,QAAA,EAGA,OAAA,IAKA,EAAA,aCvDA,EAAA,2BAAA,UAAA,gBAAA,YAAA,oBAAA,cAAA,cAAA,WAAA,yBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,OAEA,GAAA,YAEA,IAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,YAAA,wBAEA,EAAA,EAAA,wBA2NA,OAzNA,GAAA,UAAA,SAAA,EAAA,EAAA,EAAA,GAKA,GAJA,KAAA,MAAA,EACA,KAAA,QAAA,EACA,KAAA,IAAA,EAEA,EAAA,OAAA,IAAA,EAAA,OAAA,GAEA,MADA,MAAA,SAAA,EACA,MAGA,IAAA,EAGA,KAAA,EAAA,CAIA,GAAA,GAAA,EAAA,OAAA,GACA,EAAA,EAAA,OAAA,EAEA,IAAA,GAAA,IAAA,GAIA,KAAA,aAAA,EAAA,EAAA,MAAA,GAAA,aAAA,EAAA,MAAA,GAAA,aACA,KAAA,WAAA,EAAA,EAAA,MAAA,GAAA,aAAA,EAAA,MAAA,GAAA,aAGA,KAAA,OAAA,GAAA,GAAA,KAAA,IAAA,EAAA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,EAAA,EAAA,GAGA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,KAAA,IACA,KAAA,WAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAEA,EAAA,GAAA,EAAA,IACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,WAAA,KAAA,cAGA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,KAAA,IACA,KAAA,WAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAEA,EAAA,GAAA,EAAA,IACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,WAAA,KAAA,iBAIA,EAAA,EAAA,EAAA,WAEA,OAAA,EAGA,WAAA,SAAA,GACA,GAAA,GAAA,EAAA,CACA,OAAA,MAAA,MAAA,MAAA,EAAA,GAAA,KAAA,KAAA,QAAA,MAAA,EAAA,EAAA,IAAA,KAAA,KAAA,IAAA,MAAA,EAAA,KAIA,UAAA,SAAA,GACA,MAAA,MAAA,QAAA,MAAA,KAAA,OAAA,MAAA,GAAA,EAAA,IAAA,KAAA,KAAA,IAAA,MAAA,KAAA,SAAA,MAAA,EAAA,KAGA,YAAA,SAAA,GAGA,GAAA,GAAA,IACA,IAAA,KAAA,IAAA,EAAA,IAAA,GAAA,EAAA,CACA,GAAA,GAAA,GAAA,EACA,EAAA,EAAA,KAAA,MAAA,KAAA,IACA,EAAA,KAAA,QACA,EAAA,EAAA,KAAA,IAAA,KAAA,MACA,EAAA,EAAA,MAAA,GACA,EAAA,EAAA,YACA,GAAA,EAAA,GAAA,GAAA,EAAA,gBAAA,aAAA,IAAA,EAAA,MAAA,GACA,OAAA,IAAA,KAAA,OAAA,IAAA,KAAA,OAAA,EAAA,GAEA,MAAA,MAAA,WAAA,GAAA,GAAA,GAAA,YAAA,IAOA,SAAA,SAAA,EAAA,GAOA,IAAA,GAJA,IAAA,MAGA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,QAAA,EAAA,IAAA,EAAA,SAAA,GACA,MAAA,GAAA,WAAA,IAAA,KAIA,IAAA,GAAA,EAAA,IAAA,EAAA,SAAA,GAAA,MAAA,GAAA,kBAAA,IAOA,OALA,KACA,EAAA,UACA,EAAA,EAAA,IAAA,EAAA,SAAA,GAAA,MAAA,GAAA,UAAA,MAGA,GAGA,WAAA,SAAA,EAAA,GAEA,GAAA,GAAA,KAAA,MAAA,MAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,MAAA,KAAA,IAAA,GACA,EAAA,EAAA,MAAA,EAAA,EACA,QACA,GAAA,GAAA,UAAA,KAAA,MAAA,EAAA,EAAA,GACA,GAAA,GAAA,UAAA,EAAA,EAAA,KAAA,IAAA,KAIA,SAAA,WACA,MAAA,IAAA,GAAA,UAAA,KAAA,IAAA,KAAA,QAAA,KAAA,QAGA,kBAAA,SAAA,GACA,MAAA,IAAA,GAAA,UACA,KAAA,MAAA,MAAA,KAAA,MAAA,OAAA,KAAA,SAAA,KAAA,IAAA,MAAA,KAAA,OAAA,KAAA,QAAA,MAAA,KAAA,QAAA,gBAAA,aAAA,MAAA,IACA,KAAA,QAAA,KAAA,KAAA,IAAA,MAAA,KAAA,OAAA,gBAAA,aAAA,MAAA,IACA,KAAA,IAAA,MAAA,KAAA,IAAA,OAAA,KAAA,SAAA,KAAA,IAAA,MAAA,KAAA,OAAA,KAAA,IAAA,MAAA,KAAA,UAAA,gBAAA,aAAA,MAAA,MAIA,mBAAA,WACA,MAAA,KAAA,KAAA,QAAA,EAAA,IAAA,KAAA,QAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,GAGA,WAAA,SAAA,GACA,MAAA,MAAA,UAAA,EAAA,GAAA,IAGA,YAAA,SAAA,GACA,MAAA,MAAA,SAAA,EAAA,GAAA,IAGA,qBAAA,WACA,GAAA,MACA,EAAA,KAOA,OANA,UAAA,KAAA,YAAA,KAAA,WAAA,GAAA,KAAA,WAAA,EAAA,GACA,EAAA,KAAA,KAAA,YAEA,SAAA,KAAA,YAAA,KAAA,WAAA,GAAA,KAAA,WAAA,EAAA,GACA,EAAA,KAAA,KAAA,YAEA,EAAA,QAGA,iBAAA,WACA,KAAA,IAAA,OAAA,qDAIA,aAAA,SAAA,GACA,GAAA,GAAA,KACA,KAGA,EAAA,EAAA,WAAA,EAAA,IAAA,SAAA,YAAA,EAAA,aAAA,EAAA,IAAA,GAAA,EAAA,IAAA,IAEA,EAAA,EAAA,aAAA,KAAA,OACA,EAAA,EAAA,aAAA,KAAA,SACA,EAAA,EAAA,aAAA,KAAA,KAGA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAEA,EAAA,EAAA,EAAA,EAAA,EAoBA,OAlBA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,GAAA,GAAA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,WAAA,GACA,EAAA,EAAA,UAAA,GAAA,aACA,EAAA,EAAA,gBACA,EAAA,EAAA,MAAA,EAAA,IAGA,GAAA,IAAA,EAAA,KAAA,GACA,EAAA,MACA,SAAA,EAAA,YACA,MAAA,EACA,OAAA,EAAA,IAAA,EAAA,KAAA,EAAA,EAAA,UAAA,EACA,KAAA,EAAA,IAAA,gBAAA,IAAA,GAAA,EAAA,EAAA,QAKA,GAGA,oBAAA,SAAA,GACA,GAAA,GAAA,EACA,EAAA,KAAA,aAAA,EAIA,OAHA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,EAAA,OAEA,GAIA,eAAA,SAAA,GACA,EAAA,iBAAA,KAAA,QAAA,EAAA,KAAA,QAAA,EAAA,KAAA,IAAA,EAAA,KAAA,IAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,UAAA,EAAA,aAAA,KAAA,OAAA,EAAA,aAAA,KAAA,SAAA,EAAA,aAAA,KAAA,SAIA,EAAA,YCrOA,EAAA,uBAAA,UAAA,gBAAA,YAAA,oBAAA,cAAA,cAAA,cAAA,WAAA,WAAA,wBAAA,2BAAA,SAAA,GAGA,EAAA,iBAAA,QAEA,EAAA,YAEA,IAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,YAAA,wBACA,EAAA,EAAA,YAAA,oBAEA,EAAA,EAAA,wBAsSA,OArSA,GAAA,2BAEA,EAAA,MAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAyDA,QAAA,GAAA,EAAA,EAAA,EAAA,GAEA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,EAAA,CAEA,OAAA,GAAA,EAAA,EAAA,GAxDA,GANA,KAAA,MAAA,EACA,KAAA,SAAA,EACA,KAAA,SAAA,EACA,KAAA,IAAA,GAGA,EAAA,CAIA,GAAA,EAAA,OAAA,EAAA,IAAA,EAAA,OAAA,EAAA,IAAA,EAAA,OAAA,EAAA,GAEA,MADA,MAAA,SAAA,EACA,MAGA,MAAA,aAAA,KAAA,UAAA,GAAA,aACA,KAAA,WAAA,KAAA,UAAA,GAAA,aAGA,KAAA,EAAA,EAAA,MAAA,GAAA,aACA,KAAA,EAAA,KAAA,EAAA,eAEA,IAAA,GAAA,EAAA,MAAA,IAAA,KAAA,EAAA,MAAA,IAAA,KAAA,EAAA,MAAA,KAAA,KAAA,GACA,EAAA,EAAA,MAAA,GAAA,KAAA,EAAA,MAAA,KAAA,KAAA,EAAA,MAAA,IACA,EAAA,EAAA,MAAA,IAAA,KAAA,EAAA,MAAA,IAGA,EAAA,EAAA,gBACA,EAAA,EAAA,gBACA,EAAA,EAAA,IAAA,EAIA,IAFA,KAAA,OAAA,IAAA,EAAA,IAAA,GAAA,GACA,KAAA,aAAA,KAAA,MAAA,KAAA,MAAA,EAAA,GAAA,EAAA,IAAA,GAAA,GACA,KAAA,cAAA,EAAA,CACA,GAAA,GAAA,KAAA,KAAA,KAAA,aACA,MAAA,aAAA,KAAA,MAAA,EACA,KAAA,aAAA,KAAA,MAAA,EAGA,GAAA,KAAA,UAAA,CAGA,GAAA,GAAA,KAAA,WAAA,KAAA,OAAA,EACA,MAAA,eAAA,GAAA,GAAA,UAAA,EAAA,GAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,KAAA,GACA,KAAA,aAAA,GAAA,GAAA,UAAA,EAAA,GAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,KAAA,GAGA,KAAA,OAAA,EAAA,QACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,IAgBA,IAAA,GAAA,IACA,MAAA,UAAA,EAAA,KAAA,MAAA,EAAA,KAAA,SAAA,EAAA,KAAA,SAAA,EAAA,KAAA,IAAA,GACA,EAAA,KAAA,KAAA,UAAA,SAAA,GACA,GAAA,GAAA,GAAA,IACA,EAAA,OAAA,EAAA,OAAA,UAAA,EAAA,WAAA,OAGA,KAAA,UAAA,EAAA,KAAA,MAAA,EAAA,KAAA,SAAA,EAAA,KAAA,SAAA,EAAA,KAAA,IAAA,GACA,EAAA,KAAA,KAAA,UAAA,SAAA,GACA,GAAA,GAAA,GAAA,IACA,EAAA,OAAA,EAAA,OAAA,UAAA,EAAA,WAAA,OAIA,KAAA,YACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,WAAA,KAAA,WAGA,EAAA,EAAA,EAAA,OAEA,OAAA,EAEA,QAAA,WACA,GAAA,GAAA,IACA,OAAA,MAAA,UAAA,KAAA,OAAA,YAAA,GAAA,KAAA,OAAA,GAAA,KAAA,OAAA,GAIA,WAAA,SAAA,GACA,GAAA,GAAA,EAAA,CACA,OAAA,MAAA,MAAA,MAAA,EAAA,EAAA,GAAA,KAAA,KAAA,SAAA,MAAA,EAAA,EAAA,EAAA,IAAA,KAAA,KAAA,SAAA,MAAA,EAAA,EAAA,EAAA,IAAA,KAAA,KAAA,IAAA,MAAA,EAAA,EAAA,KAIA,UAAA,SAAA,GACA,GAAA,GAAA,EAAA,CACA,OAAA,MAAA,MAAA,MAAA,GAAA,EAAA,GAAA,KAAA,KAAA,SAAA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,KAAA,KAAA,SAAA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,KAAA,KAAA,IAAA,MAAA,EAAA,EAAA,KAGA,YAAA,SAAA,GAGA,GAAA,GAAA,IACA,IAAA,KAAA,IAAA,EAAA,IAAA,GAAA,EAAA,CACA,GAAA,GAAA,GAAA,EACA,EAAA,EAAA,KAAA,MAAA,KAAA,IACA,EAAA,EAAA,KAAA,SAAA,KAAA,SACA,EAAA,EAAA,KAAA,SAAA,KAAA,SACA,EAAA,EAAA,MAAA,GACA,EAAA,EAAA,YACA,GAAA,EAAA,GAAA,GAAA,EAAA,gBAAA,aAAA,IAAA,EAAA,MAAA,GACA,OAAA,IAAA,KAAA,OAAA,IAAA,KAAA,OAAA,EAAA,GAEA,MAAA,MAAA,WAAA,GAAA,GAAA,GAAA,YAAA,IAIA,KAAA,SAAA,GACA,GAAA,GAAA,EAAA,MAAA,KAAA,MACA,OAAA,IAAA,GAAA,EAAA,IAAA,KAAA,GAAA,EAAA,IAAA,KAAA,KAGA,WAAA,SAAA,EAAA,GAGA,GAAA,GAAA,KAAA,MAAA,MAAA,KAAA,SAAA,GACA,EAAA,KAAA,SAAA,MAAA,KAAA,IAAA,GACA,EAAA,KAAA,SAAA,MAAA,KAAA,SAAA,GACA,EAAA,EAAA,MAAA,EAAA,GACA,EAAA,EAAA,MAAA,EAAA,GACA,EAAA,EAAA,MAAA,EAAA,EACA,QACA,GAAA,GAAA,MAAA,KAAA,MAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,MAAA,EAAA,EAAA,EAAA,KAAA,IAAA,KAIA,SAAA,SAAA,EAAA,GASA,IAAA,GAJA,GAAA,GAEA,KACA,KACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,GAAA,EAAA,EACA,KACA,EAAA,EAAA,GAGA,EAAA,KAAA,KAAA,WAAA,GAAA,KAAA,KAAA,UAAA,GAAA,gBAAA,aAAA,MAAA,KACA,EAAA,GACA,EAAA,KAAA,GAAA,GAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAIA,MAAA,IAGA,mBAAA,WACA,MAAA,KAAA,KAAA,SAAA,EAAA,IAAA,KAAA,SAAA,EAAA,IAAA,KAAA,SAAA,EAAA,IAAA,KAAA,SAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,GAGA,WAAA,SAAA,GACA,MAAA,MAAA,UAAA,EAAA,GAAA,IAGA,YAAA,SAAA,GACA,MAAA,MAAA,SAAA,EAAA,GAAA,IAGA,qBAAA,WACA,GAAA,GAAA,KAAA,UAAA,OAAA,KAAA,WACA,IAUA,OATA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,GAAA,KACA,GAAA,GAAA,EAAA,EAAA,GAEA,EAAA,MAAA,EAAA,SAAA,GAAA,MAAA,MAAA,IAAA,EAAA,GAAA,KACA,EAAA,KAAA,KAIA,EAAA,QAGA,iBAAA,WACA,KAAA,IAAA,OAAA,iDAIA,aAAA,SAAA,GACA,GAAA,GAAA,KACA,KAGA,EAAA,EAAA,WAAA,EAAA,IAAA,SAAA,YAAA,EAAA,aAAA,EAAA,IAAA,GAAA,EAAA,IAAA,IAEA,EAAA,EAAA,aAAA,KAAA,OACA,EAAA,EAAA,aAAA,KAAA,UACA,EAAA,EAAA,aAAA,KAAA,UACA,EAAA,EAAA,aAAA,KAAA,KAGA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAEA,EAAA,EAAA,EAAA,EAAA,EAAA,EAoBA,OAlBA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,GAAA,GAAA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,WAAA,GACA,EAAA,EAAA,UAAA,GAAA,aACA,EAAA,EAAA,gBACA,EAAA,EAAA,MAAA,EAAA,IAGA,GAAA,IAAA,EAAA,KAAA,GACA,EAAA,MACA,SAAA,EAAA,YACA,MAAA,EACA,OAAA,EAAA,IAAA,EAAA,KAAA,EAAA,EAAA,UAAA,EACA,KAAA,EAAA,IAAA,gBAAA,IAAA,GAAA,EAAA,EAAA,QAKA,GAGA,oBAAA,SAAA,GACA,GAAA,GAAA,EACA,EAAA,KAAA,aAAA,EAIA,OAHA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,EAAA,OAEA,GAIA,eAAA,SAAA,GACA,EAAA,cAAA,KAAA,SAAA,EAAA,KAAA,SAAA,EAAA,KAAA,SAAA,EAAA,KAAA,SAAA,EAAA,KAAA,IAAA,EAAA,KAAA,IAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,MAAA,EAAA,aAAA,KAAA,OAAA,EAAA,aAAA,KAAA,UAAA,EAAA,aAAA,KAAA,UAAA,EAAA,aAAA,KAAA,SAoCA,EAAA,QCxTA,EAAA,+BAAA,UAAA,gBAAA,YAAA,oBAAA,cAAA,cAAA,cAAA,iBAAA,WAAA,WAAA,wBAAA,qBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,OAEA,GAAA,YAEA,IAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,kBACA,EAAA,EAAA,YAAA,UACA,EAAA,EAAA,YAEA,EAAA,EAAA,wBAsVA,OArVA,GAAA,qBAIA,EAAA,cAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAmGA,QAAA,GAAA,GACA,EAAA,cAAA,KAEA,EAAA,OAAA,EAAA,OAAA,UAAA,EAAA,gBAAA,KAvFA,GAdA,EAAA,IAEA,GAAA,EACA,EAAA,KAAA,GAAA,EACA,EAAA,KAAA,GAAA,EACA,GAAA,GAEA,EAAA,IAEA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,GAEA,EAAA,EAAA,CAEA,GAAA,KAAA,GAAA,EACA,GAAA,KAAA,GAAA,EACA,GAAA,KAAA,GAAA,CAGA,IAAA,GAAA,CACA,GAAA,EACA,EAAA,EAkBA,GAfA,KAAA,OAAA,EACA,KAAA,QAAA,EACA,KAAA,QAAA,EACA,KAAA,SAAA,EACA,KAAA,WAAA,EACA,KAAA,SAAA,EACA,KAAA,cAAA,EAEA,KAAA,cAAA,EAAA,cAAA,qBAAA,EAAA,EAAA,EAAA,GAEA,KAAA,MAAA,KAAA,gBAAA,GACA,KAAA,IAAA,KAAA,gBAAA,GACA,KAAA,aAAA,KAAA,eAAA,GAAA,aACA,KAAA,WAAA,KAAA,eAAA,GAAA,aAEA,IAAA,GAAA,IAAA,GAAA,IAAA,EAEA,MADA,MAAA,SAAA,EACA,MAGA,IAAA,EAAA,EAEA,KAAA,IAAA,OAAA,4CAQA,MAAA,eAJA,KAAA,cAGA,KAAA,WAAA,KAAA,SACA,KAAA,SACA,KAAA,WAAA,KAAA,SACA,KAAA,SAAA,EAAA,KAAA,GAGA,KAAA,WAKA,KAAA,WAAA,KAAA,SACA,KAAA,SACA,KAAA,WAAA,KAAA,SACA,KAAA,SAAA,EAAA,KAAA,GAGA,KAAA,WAKA,GAAA,KAAA,GAAA,EAAA,GAAA,GAAA,KAAA,IAAA,GAAA,EAAA,GAAA,GAAA,KAAA,IAAA,wGACA,GAAA,KAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,yGAEA,GAAA,EAAA,GAAA,EAAA,KAAA,IAAA,GAAA,EAAA,GAAA,EAAA,KAAA,GAGA,KAAA,gBAAA,KAAA,cAAA,KAAA,WAAA,KAAA,SAAA,KAAA,SAAA,KAAA,WACA,KAAA,gBAAA,IACA,KAAA,iBAAA,EAAA,KAAA,IAEA,GAAA,EAAA,KAAA,iBAAA,GAGA,KAAA,eAAA,GAAA,GAAA,IAAA,EAAA,KAAA,EAAA,EAAA,EAAA,GAEA,KAAA,OAAA,EAAA,QACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,UAAA,KAAA,IAGA;GAAA,GAAA,IASA,IAAA,IAAA,EAAA,CAGA,GAAA,GAAA,KAAA,OAAA,EAAA,GAAA,KAAA,IAAA,IACA,EAAA,KAAA,KAAA,EAAA,EAAA,KAAA,IAAA,GAGA,MAAA,uBACA,EACA,EAAA,KAAA,GACA,EACA,EAAA,KAAA,IAGA,EAAA,KAAA,KAAA,sBAAA,KAGA,EAAA,EAAA,EAAA,eAGA,SAAA,SAAA,GAEA,MAAA,MAAA,WAAA,KAAA,eACA,EAAA,gBAAA,EAAA,KAAA,WAAA,EAAA,KAAA,GAAA,KAAA,YACA,EAAA,kBAAA,EAAA,KAAA,WAAA,KAAA,WAAA,EAAA,KAAA,KAGA,SAAA,SAAA,GACA,OAAA,KAAA,SAAA,GAAA,KAAA,aAAA,KAAA,eAAA,KAAA,aAGA,QAAA,SAAA,GACA,MAAA,MAAA,YAAA,KAAA,eAAA,KAAA,YAAA,GAGA,WAAA,SAAA,GACA,MAAA,MAAA,gBAAA,KAAA,QAAA,KAGA,UAAA,SAAA,GACA,MAAA,MAAA,eAAA,KAAA,QAAA,KAGA,YAAA,SAAA,GAEA,GAAA,GAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,KAAA,IAAA,GACA,EAAA,KAAA,QAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,QAAA,KAAA,cAAA,GAAA,GAAA,KAAA,QAAA,KAAA,QAAA,GAGA,gBAAA,SAAA,GACA,MAAA,MAAA,cAAA,mBAAA,EAAA,YAAA,EAAA,KAGA,eAAA,SAAA,GACA,GAAA,GAAA,KAAA,cAAA,iBAAA,EAAA,YAAA,EAAA,GAEA,OAAA,MAAA,cAAA,EAAA,gBAAA,EAAA,gBAAA,WAIA,cAAA,SAAA,GAGA,GAAA,GAAA,KAAA,cAAA,EAAA,KAAA,SAAA,EAAA,KAAA,WAGA,EAAA,GAAA,EAAA,KAAA,GAMA,OAJA,GAAA,IACA,GAAA,EAAA,KAAA,IAGA,GAAA,KAAA,iBAIA,SAAA,SAAA,EAAA,GAMA,IAAA,GAJA,GAAA,GAEA,KACA,KACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,GAAA,EAAA,EACA,KACA,EAAA,EAAA,EAEA,IAAA,GAAA,KAAA,QAAA,EAEA,GAAA,KAAA,KAAA,gBAAA,GAAA,KAAA,KAAA,eAAA,GAAA,gBAAA,aAAA,MAAA,KACA,EAAA,GACA,EAAA,KAAA,GAAA,GAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAIA,MAAA,IAGA,mBAAA,WAGA,GAEA,GAFA,EAAA,IACA,EAAA,KAAA,cAAA,IAAA,IAEA,EAAA,EAAA,KAAA,SACA,IAAA,KAAA,gBAAA,EAAA,KAAA,GAAA,EAEA,MADA,GAAA,KAAA,gBAAA,KAAA,GAAA,IAAA,IACA,KAAA,KAAA,QAAA,IAAA,KAAA,QAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,CAMA,IAAA,IAAA,KAAA,WAAA,KAAA,UAAA,EACA,EAAA,KAAA,gBAAA,EAEA,GAAA,GAEA,IAAA,GAAA,KAAA,KAAA,QAAA,IAAA,KAAA,QAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,IAAA,EAAA,EACA,EAAA,KAAA,KAAA,QAAA,IAAA,KAAA,QAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,CAEA,OAAA,GAAA,IAAA,GAIA,WAAA,SAAA,GACA,MAAA,MAAA,UAAA,EAAA,GAAA,IAGA,YAAA,SAAA,GACA,MAAA,MAAA,SAAA,EAAA,GAAA,IAIA,qBAAA,WACA,GAAA,GAAA,KACA,IAUA,OATA,GAAA,KAAA,KAAA,sBAAA,SAAA,GACA,GAAA,EAAA,cAAA,GAAA,CACA,GAAA,GAAA,EAAA,SAAA,GACA,EAAA,KACA,GAAA,GAAA,EAAA,EAAA,GACA,EAAA,KAAA,MAIA,EAAA,QAGA,WAAA,SAAA,GAEA,GAAA,GAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,EACA,QACA,GAAA,GAAA,cAAA,KAAA,OAAA,KAAA,QAAA,KAAA,QAAA,KAAA,SAAA,EAAA,EAAA,KAAA,eACA,GAAA,GAAA,cAAA,KAAA,OAAA,KAAA,QAAA,KAAA,QAAA,KAAA,SAAA,EAAA,EAAA,KAAA,iBAIA,iBAAA,WACA,KAAA,IAAA,OAAA,yDAGA,aAAA,SAAA,GAEA,GAAA,GAAA,KAAA,cACA,EAAA,EAAA,YAAA,GACA,EAAA,KAAA,eAAA,aAAA,EAEA,OAAA,GAAA,IAAA,EAAA,SAAA,GACA,GAAA,GAAA,EAAA,mBAAA,EAAA,MACA,QACA,SAAA,EAAA,IAAA,SAAA,GACA,MAAA,EACA,OAAA,EAAA,eAAA,EAAA,QACA,KAAA,EAAA,SAMA,oBAAA,SAAA,GAEA,GAAA,GAAA,KAAA,cAAA,YAAA,EACA,OAAA,MAAA,eAAA,oBAAA,IAIA,eAAA,SAAA,GACA,EAAA,QACA,EAAA,QAAA,KAAA,OAAA,EAAA,KAAA,OAAA,EAAA,KAAA,QAAA,KAAA,QAAA,KAAA,SAAA,KAAA,WAAA,KAAA,SAAA,KAAA,gBAGA,KAAA,cAAA,YAAA,sBAAA,GACA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,WAAA,KAAA,SAAA,KAAA,eACA,KAAA,cAAA,aAAA,sBAAA,KAIA,YAAA,SAAA,GACA,GAAA,GAAA,EAAA,aAAA,EAAA,YAAA,KAAA,QAAA,KAAA,WAAA,MAAA,EAAA,aAAA,EAAA,OACA,EAAA,EAAA,aAAA,EAAA,YAAA,KAAA,QAAA,KAAA,SAAA,KAAA,GAAA,IAAA,MAAA,EAAA,aAAA,EAAA,OACA,EAAA,EAAA,QACA,EAAA,EAAA,YACA,EAAA,EAAA,YAEA,EAAA,EAAA,iBAAA,EAIA,EAAA,GAAA,KAAA,cAAA,KAAA,cACA,EAAA,GAAA,KAAA,WAAA,KAAA,WACA,EAAA,GAAA,KAAA,SAAA,KAAA,QAEA,OAAA,IAAA,GAAA,cAAA,EAAA,aAAA,KAAA,QAAA,EAAA,EAAA,EAAA,EAAA,EAAA,MAMA,EAAA,cAAA,qBAAA,SAAA,EAAA,EAAA,EAAA,GACA,MAAA,IAAA,GAAA,EAAA,YAAA,EAAA,EAAA,EAAA,GACA,YAAA,EAAA,UAAA,IACA,YAAA,EAAA,QAAA,EAAA,MAGA,EAAA,gBCzVA,EAAA,cAAA,UAAA,gBAAA,gBAAA,YAAA,cAAA,cAAA,WAAA,cAAA,iBAAA,WAAA,WAAA,oBAAA,yBAAA,uBAAA,oBAAA,sBAAA,8BAAA,qBAAA,2BAAA,SAAA,GA4BA,QAAA,GAAA,EAAA,GAAA,MAAA,IAAA,GAAA,EAAA,GACA,QAAA,GAAA,EAAA,GAAA,MAAA,IAAA,GAAA,EAAA,GA1BA,GAAA,GAAA,EAAA,iBAAA,OACA,GAAA,iBAAA,cAAA,EAEA,IAAA,GAAA,EAAA,aAGA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,WACA,GAAA,eACA,EAAA,kBACA,EAAA,YAAA,UACA,EAAA,YAAA,oBAEA,IAAA,GAAA,EAAA,qBAEA,EAAA,EAAA,yBACA,GAAA,wBACA,EAAA,qBACA,EAAA,uBACA,EAAA,+BACA,EAAA,sBACA,EAAA,2BAUA,EAAA,MAAA,QAAA,GAAA,EAAA,GAEA,KAAA,SAAA,gBAAA,GAAA,KACA,GAAA,EAAA,IAAA,KAAA,SAAA,QAAA,UAAA,KAAA,SAAA,GAAA,YAAA,MAGA,KAAA,OAAA,GAAA,EAAA,OAEA,IAAA,GAAA,IACA,IAAA,gBAAA,KACA,GAAA,EAAA,gBAAA,GAAA,qDAGA,EAAA,KAAA,EAAA,MAAA,GAAA,SAAA,GACA,GAAA,EAAA,SAAA,EAAA,UAAA,EAAA,KAAA,UAAA,EAAA,IAAA,mCACA,EAAA,EAAA,KAAA,MAAA,EAAA,EAAA,SAIA,IAAA,GAAA,EAAA,KA0gBA,OAxgBA,GAAA,WACA,YAAA,EAEA,OAAA,SAAA,EAAA,GAAA,MAAA,MAAA,YAAA,EAAA,EAAA,KACA,eAAA,SAAA,EAAA,GAAA,MAAA,MAAA,oBAAA,EAAA,EAAA,KACA,oBAAA,SAAA,GAAA,MAAA,MAAA,YAAA,KAAA,mBAAA,KAAA,KACA,YAAA,SAAA,GACA,MAAA,MAAA,YAAA,GAAA,GAAA,SAAA,SAAA,KAGA,OAAA,SAAA,EAAA,GAAA,MAAA,MAAA,YAAA,EAAA,EAAA,KACA,eAAA,SAAA,EAAA,GAAA,MAAA,MAAA,oBAAA,EAAA,EAAA,KACA,oBAAA,SAAA,GAAA,MAAA,MAAA,YAAA,KAAA,mBAAA,KAAA,KACA,YAAA,SAAA,GAEA,GAAA,KAAA,cAAA,CACA,GAAA,GAAA,KAAA,iBAAA,eACA,EAAA,EACA,EAAA,GAAA,GAAA,QAAA,KAAA,EAAA,EACA,MAAA,iBAAA,SAAA,GACA,EAAA,UACA,KAAA,iBAAA,WAAA,GACA,KAAA,OAAA,KAAA,OAAA,UAAA,GAAA,UAAA,GACA,GAAA,GAAA,MAAA,KAAA,OAAA,cAGA,MAAA,OAAA,EAGA,OAAA,OAGA,iBAAA,SAAA,GAAA,MAAA,MAAA,OAAA,EAAA,KAAA,mBAAA,IACA,yBAAA,SAAA,GAAA,MAAA,MAAA,eAAA,EAAA,IAEA,eAAA,SAAA,GAAA,MAAA,MAAA,OAAA,KAAA,mBAAA,EAAA,IACA,uBAAA,SAAA,GAAA,MAAA,MAAA,eAAA,EAAA,IAEA,iBAAA,SAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,sBAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KACA,yBAAA,SAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,8BAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KACA,8BAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,kBACA,OAAA,MAAA,sBAAA,EAAA,KAAA,GAAA,EAAA,KAAA,KAGA,uBAAA,SAAA,EAAA,GAAA,MAAA,MAAA,sBAAA,KAAA,iCAAA,EAAA,EAAA,KACA,+BAAA,SAAA,EAAA,GAAA,MAAA,MAAA,sBAAA,KAAA,iCAAA,EAAA,EAAA,GAAA,KAAA,KAAA,sBACA,sBAAA,SAAA,EAAA,GAEA,KAAA,OAAA,EACA,IAAA,GAAA,KAAA,iBAAA,eACA,EAAA,GAAA,GAAA,QAAA,UAAA,EAAA,EAAA,EAOA,OANA,MAAA,iBAAA,SAAA,GACA,EAAA,UACA,KAAA,iBAAA,WAAA,GACA,KAAA,OAAA,KAAA,OAAA,MAAA,EAAA,SAGA,MAGA,aAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,kBAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KACA,qBAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,0BAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KACA,0BAAA,SAAA,EAAA,EAAA,GACA,GAAA,GAAA,KAAA,kBACA,OAAA,MAAA,kBAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,EAAA,KAAA,KAEA,mBAAA,SAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,kBAAA,KAAA,6BAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KACA,2BAAA,SAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,kBAAA,KAAA,6BAAA,EAAA,EAAA,GAAA,KAAA,KAAA,oBAAA,EAAA,EAAA,GAAA,KAAA,KAAA,sBACA,kBAAA,SAAA,EAAA,EAAA,GAEA,KAAA,OAAA,EACA,IAAA,GAAA,KAAA,iBAAA,eACA,EAAA,GAAA,GAAA,QAAA,MAAA,EAAA,EAAA,EAAA,EAeA,OAbA,GAAA,UAEA,EAAA,WACA,KAAA,iBAAA,WAAA,EAAA,gBACA,KAAA,iBAAA,WAAA,EAAA,eAEA,KAAA,iBAAA,WAAA,GAGA,KAAA,OAAA,KAAA,OAAA,MAAA,EAAA,SAEA,KAAA,iBAAA,SAAA,GAEA,MAGA,IAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,SAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IACA,SAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAGA,GAAA,GAAA,GAAA,GAAA,QAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAGA,EAAA,EAAA,MACA,EAAA,EAAA,GAsBA,OAnBA,MAAA,eAAA,KAAA,iBAAA,YAAA,IAAA,EAAA,OAAA,KAAA,iBAAA,eAAA,IACA,KAAA,iBAAA,WAAA,GAAA,GAAA,QAAA,KAAA,KAAA,iBAAA,eAAA,IAGA,KAAA,eACA,KAAA,WAAA,GAAA,GAAA,SAIA,KAAA,iBAAA,SAAA,GACA,KAAA,iBAAA,SAAA,GAEA,EAAA,UACA,KAAA,iBAAA,WAAA,GAGA,KAAA,OAAA,KAAA,OAAA,MAAA,EAAA,SAGA,MAGA,cAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,MAAA,MAAA,mBAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,mBAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAGA,GAAA,GAAA,GAAA,GAAA,QAAA,cAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAGA,EAAA,EAAA,MACA,EAAA,EAAA,GAsBA,OAnBA,MAAA,eAAA,KAAA,iBAAA,YAAA,IAAA,EAAA,OAAA,KAAA,iBAAA,eAAA,IACA,KAAA,iBAAA,WAAA,GAAA,GAAA,QAAA,KAAA,KAAA,iBAAA,eAAA,IAGA,KAAA,eACA,KAAA,WAAA,GAAA,GAAA,SAIA,KAAA,iBAAA,SAAA,GACA,KAAA,iBAAA,SAAA,GAEA,EAAA,UACA,KAAA,iBAAA,WAAA,GAGA,KAAA,OAAA,KAAA,OAAA,MAAA,EAAA,SAGA,MAGA,MAAA,WACA,GAAA,KAAA,cAAA,CACA,GAAA,GAAA,KAAA,iBACA,EAAA,GAAA,GAAA,OAEA,GAAA,QACA,KAAA,WAAA,GACA,EAAA,SAAA,EAAA,iBAEA,MAAA,OAIA,wBAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,KAAA,kBACA,OAAA,MAAA,gBAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAEA,gBAAA,WACA,KAAA,IAAA,OAAA,kCAQA,OAAA,SAAA,EAAA,EAAA,GACA,GAAA,gBAAA,GAAA,CAEA,GAAA,GAAA,CAEA,OADA,GAAA,EACA,KAAA,SAAA,EAAA,EAAA,EAAA,EAAA,KAAA,IAAA,GAGA,MAAA,MAAA,SAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,IASA,QAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAGA,GAAA,gBAAA,GAAA,CAEA,GAAA,GAAA,CAIA,OAHA,GAAA,EACA,EAAA,EACA,EAAA,EACA,KAAA,mBAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,GAGA,MAAA,MAAA,mBAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,IAIA,KAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,GAAA,GAAA,OAeA,OAdA,MAAA,WAAA,GACA,EAAA,SAAA,EAAA,EAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,IACA,EAAA,WAAA,GAAA,GAAA,QAAA,KAAA,EAAA,OAAA,GAAA,EAAA,OAAA,KACA,EAAA,WAAA,GAAA,GAAA,QAAA,KAAA,EAAA,OAAA,GAAA,EAAA,OAAA,KACA,EAAA,WAAA,GAAA,GAAA,QAAA,KAAA,EAAA,OAAA,GAAA,EAAA,OAAA,KACA,EAAA,QACA,KAAA,WAAA,GAAA,GAAA,SACA,KAAA,iBAAA,SAAA,EAAA,EAAA,IACA,KAAA,OAAA,KAAA,OAAA,gBAAA,EAAA,GAAA,gBAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,MAAA,KAAA,OAAA,SAEA,MAIA,UAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,CAiBA,OAfA,KAAA,EAEA,KAAA,IAAA,EAAA,EAAA,GAAA,KAAA,GAAA,EAAA,GAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,GAAA,GACA,IAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,KAAA,IAAA,GACA,IAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,GAAA,GACA,QAGA,KAAA,cAAA,EAAA,EAAA,EAAA,EAAA,GAAA,KAAA,GAAA,EAAA,GAAA,GACA,cAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,GAAA,GACA,cAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,KAAA,IAAA,GACA,cAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,GAAA,GACA,QAEA,MAGA,KAAA,WAEA,MAAA,IAAA,GAAA,EAAA,IAAA,KAAA,SAAA,SAAA,GAAA,MAAA,GAAA,SAAA,KAAA,SAIA,eAAA,SAAA,GACA,EAAA,KAAA,KAAA,SAAA,SAAA,GACA,EAAA,eAAA,MAKA,WAAA,WACA,GAAA,KAgBA,OAfA,GAAA,KAAA,KAAA,SAAA,SAAA,GACA,GAAA,EAAA,aAAA,CAEA,GAAA,GAAA,EAAA,kBAAA,KACA,IAAA,EAAA,EAAA,OAAA,EAAA,gBAAA,MACA,IAAA,GAAA,KAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAEA,IAAA,EAAA,IAAA,EAAA,SAAA,SAAA,GAAA,MAAA,GAAA,uBAAA,KAAA,KAEA,EAAA,aACA,GAAA,MAEA,EAAA,KAAA,MAGA,EAAA,KAAA,MAIA,YAAA,SAAA,GACA,GAAA,GAAA,EAAA,IAAA,KAAA,SAAA,SAAA,GAAA,MAAA,GAAA,YAAA,KACA,EAAA,EAAA,OAAA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,MAAA,EAAA,kBAAA,EAAA,QACA,OAAA,IAAA,GAAA,EAAA,IAKA,cAAA,SAAA,GACA,MAAA,GACA,KAAA,OAAA,MAAA,KAAA,gBAAA,GAAA,QAEA,KAAA,QAIA,cAAA,SAAA,GAEA,GAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAEA,OAAA,KAAA,KAAA,oBAAA,IAGA,aAAA,SAAA,GACA,GAAA,KAgBA,OAfA,GAAA,KAAA,KAAA,SAAA,SAAA,GACA,EAAA,eACA,EAAA,KAAA,EAAA,SAAA,SAAA,GACA,EAAA,KAAA,EAAA,aAAA,GAAA,SAAA,GACA,EAAA,KAAA,OAIA,EAAA,qBACA,EAAA,KAAA,EAAA,oBAAA,aAAA,GAAA,SAAA,GACA,EAAA,KAAA,QAKA,EAAA,OAAA,EAAA,SAAA,GAAA,MAAA,GAAA,YAGA,oBAAA,SAAA,GACA,GAAA,GAAA,CAeA,OAbA,GAAA,KAAA,KAAA,SAAA,SAAA,GACA,EAAA,eACA,EAAA,KAAA,EAAA,SAAA,SAAA,GACA,GAAA,EAAA,oBAAA,KAIA,EAAA,sBACA,GAAA,EAAA,oBAAA,oBAAA,OAKA,GAGA,iBAAA,SAAA,GACA,GAAA,IAAA,CAcA,OAZA,GAAA,KAAA,KAAA,SAAA,SAAA,GACA,EAAA,eACA,EAAA,KAAA,EAAA,SAAA,SAAA,GACA,EAAA,GAAA,EAAA,iBAAA,KAIA,EAAA,sBACA,EAAA,GAAA,EAAA,oBAAA,iBAAA,OAIA,GAKA,gBAAA,SAAA,GACA,GAAA,GAAA,EAAA,QAAA,EAAA,IAAA,KAAA,SAAA,SAAA,GAAA,MAAA,GAAA,QAAA,MACA,EAAA,EAAA,OAAA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,MAAA,EAAA,kBAAA,EAAA,QACA,OAAA,IAAA,GAAA,EAAA,IAGA,SAAA,WAEA,MAAA,oBAAA,KAAA,aAAA,OAOA,OAAA,SAAA,GACA,KAAA,gBACA,KAAA,WAAA,GAAA,IACA,KAAA,iBAAA,SAAA,KAIA,WAAA,SAAA,GAGA,MAFA,MAAA,SAAA,KAAA,GAEA,MAGA,YAAA,WACA,MAAA,MAAA,SAAA,OAAA,GAGA,eAAA,WACA,MAAA,GAAA,KAAA,KAAA,WAIA,aAAA,WACA,MAAA,MAAA,cAAA,KAAA,iBAAA,eAAA,MAGA,eAAA,WACA,IAAA,KAAA,cAAA,MAAA,KAEA,IAAA,GAAA,KAAA,gBACA,OAAA,GAAA,aAEA,EAAA,iBAFA,MAMA,+BAAA,WACA,GAAA,GAAA,KAAA,eAEA,EAAA,KAAA,gBACA,OAAA,IAAA,YAAA,GAAA,QAAA,UAEA,EAAA,KAAA,EAAA,MAAA,EAAA,UAFA,GAMA,2BAAA,WACA,GAAA,GAAA,KAAA,eAEA,EAAA,KAAA,gBACA,OAAA,IAAA,YAAA,GAAA,QAAA,MAEA,EAAA,KAAA,EAAA,MAAA,EAAA,WAFA,GAKA,iBAAA,WACA,GAAA,GAAA,KAAA,cACA,OAAA,GAAA,EAAA,EAAA,OAQA,EAAA,UAAA,SAAA,EAAA,EAAA,EAAA,GACA,OAAA,GAAA,IAAA,KAAA,EAAA,EAAA,EAAA,IAEA,EAAA,KAAA,EAAA,UAKA,EAAA,UAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,GAAA,IAAA,UAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAEA,EAAA,eAAA,EAAA,UAEA,EAAA,OAAA,SAAA,GACA,OAAA,GAAA,IAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,OAIA,EAAA,YAAA,SAAA,EAAA,EAAA,EAAA,GAEA,MAAA,gBAAA,IACA,GAAA,IAAA,OAAA,EAAA,GAAA,OAAA,EAAA,IAGA,GAAA,IAAA,YAAA,GAAA,YAAA,IAIA,EAAA,eAAA,SAAA,EAAA,GACA,GAAA,GAAA,GAAA,EAKA,OAJA,GAAA,KAAA,EAAA,MAAA,GAAA,SAAA,GACA,GAAA,GAAA,EAAA,YAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EACA,KAAA,EAAA,EAAA,YAAA,GAAA,EAAA,YAAA,KAEA,EAAA,SAIA,EAAA,OAAA,SAAA,EAAA,EAAA,GACA,MAAA,UAAA,GAEA,GAAA,IAAA,OAAA,EAAA,EAAA,IAEA,GAAA,IAAA,OAAA,EAAA,EAAA,GAAA,SAOA,EAAA,QAAA,SAAA,EAAA,EAAA,EAAA,GAEA,MAAA,UAAA,GAEA,GAAA,IAAA,QAAA,EAAA,EAAA,EAAA,IAEA,GAAA,IAAA,QAAA,EAAA,EAAA,EAAA,GAAA,SAIA,EAAA,IAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGA,ICxkBA,EAAA,QACA,YAEA,aACA,oBACA,sBACA,8BACA,qBACA,0BACA,wBACA,uBACA,oBAEA,0BACA,SACA,GAIA,MAAA,KCpBA,EAAA,eAAA,UAAA,gBAAA,UAAA,oBAAA,eAAA,SAAA,GAGA,EAAA,iBAAA,MAEA,IAAA,GAAA,EAAA,WAEA,EAAA,EAAA,qBACA,EAAA,EAAA,cAGA,GAAA,QAAA,SAAA,EAAA,GACA,EAAA,KAAA,KAAA,EAAA,GACA,KAAA,KAAA,EACA,KAAA,UAAA,EAEA,IAAA,GAAA,EAAA,OA2DA,OAzDA,GAAA,KAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,IAGA,EAAA,UAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,IAGA,EAAA,YAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,KAOA,EAAA,EAAA,UAAA,GACA,MAAA,EAAA,UAAA,MAGA,MAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,UAAA,EAAA,UAAA,KAAA,KAAA,EAAA,UAAA,KAAA,UAAA,EAAA,OAGA,UAAA,SAAA,GACA,GAAA,GAAA,EAAA,kBACA,OAAA,IAAA,IACA,KAAA,KAAA,EAAA,KAAA,KAAA,UAAA,EAAA,WAAA,GACA,KAAA,UAAA,EAAA,KAAA,KAAA,KAAA,EAAA,WAAA,IAKA,KAAA,WACA,GAAA,GAAA,KAAA,WACA,OAAA,IAAA,GAAA,KAAA,MAAA,EAAA,KAAA,MAAA,IACA,KAAA,WAAA,EAAA,EAAA,IAAA,KAAA,MAAA,EAAA,KAAA,MAAA,KAGA,UAAA,WACA,MAAA,IAAA,GAAA,KAAA,MAAA,KAAA,YAIA,cAAA,WACA,MAAA,GAAA,YAAA,KAAA,IAAA,KAAA,MAAA,KAAA,YAGA,SAAA,WACA,MAAA,WAAA,KAAA,EAAA,KAAA,KAAA,EAAA,OAIA,EAAA,KAAA,GAAA,GAAA,EAAA,GACA,EAAA,IAAA,GAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,GAAA,EAAA,GAEA,IC9EA,EAAA,mBAAA,UAAA,gBAAA,WAAA,SAAA,GAQA,QAAA,GAAA,EAAA,EAAA,GACA,MAAA,GAAA,MAAA,GAAA,YAAA,EAAA,MAAA,IANA,EAAA,iBAAA,MAEA,IAAA,GAAA,EAAA,UAkEA,OA3DA,GAAA,aAIA,WAAA,SAAA,EAAA,GACA,GAAA,EAAA,QAAA,EACA,MAAA,EAIA,IAAA,GAAA,OAAA,kBACA,EAAA,IACA,GAAA,KAAA,EAAA,SAAA,GACA,EAAA,GAAA,IAEA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,EAAA,IACA,EAAA,IAGA,EAAA,EAAA,EACA,EAAA,MAMA,EAAA,EAAA,OAAA,EAAA,SAAA,GACA,MAAA,GAAA,MAAA,GAAA,UAIA,EAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAGA,IAAA,IAAA,EAoBA,OAlBA,GAAA,KAAA,EAAA,SAAA,GAIA,QAAA,KACA,GAAA,EAAA,OAAA,EACA,OAAA,CAEA,IAAA,GAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EAAA,EAAA,OAAA,GAAA,EACA,OAAA,GAAA,EAAA,EAAA,GAAA,EAPA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,CAUA,KAAA,KACA,EAAA,KAEA,GAAA,KAAA,MAGA,IAIA,EAAA,cCvEA,EAAA,kBAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,WAAA,SAAA,EAAA,GACA,KAAA,MAAA,EACA,KAAA,OAAA,EAEA,IAAA,GAAA,EAAA,UAcA,OAZA,GAAA,WACA,YAAA,EAEA,SAAA,WACA,MAAA,IAAA,KAAA,MAAA,MAAA,KAAA,OAAA,MAGA,OAAA,SAAA,GACA,MAAA,MAAA,QAAA,EAAA,OAAA,KAAA,SAAA,EAAA,SAIA,ICRA,EAAA,+BAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WAEA,EAAA,OAAA,cAAA,KAIA,GAAA,wBAAA,SAAA,GACA,GAAA,GAAA,EAEA,EAAA,EAAA,OACA,MAAA,EAAA,EAAA,oBACA,IAAA,GAAA,KAAA,CAQA,KAPA,KAAA,EAAA,GAAA,GAAA,EAAA,GAGA,KAAA,EAAA,GAAA,GAAA,GACA,KAAA,EAAA,GAAA,GAAA,GAEA,KAAA,aAAA,EACA,EAAA,EAAA,EAAA,GAAA,KAAA,YAAA,IACA,IAAA,EAAA,EAAA,EAAA,GAAA,KAAA,YAAA,IACA,KAAA,YAAA,EAAA,EAAA,KAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAIA,IAAA,KAAA,YAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAKA,MAAA,QAGA,KAAA,WAGA,CAIA,IAHA,KAAA,EAAA,GAAA,GAAA,EAAA,GACA,KAAA,IAAA,GAAA,GAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAKA,MAAA,SAGA,KAAA,QAGA,IAAA,GAAA,EAAA,uBAi1BA,OA/0BA,GAAA,WACA,YAAA,EAGA,KAAA,WACA,MAAA,MAAA,EAAA,QAIA,mBAAA,WACA,MAAA,MAAA,GAIA,mBAAA,WACA,MAAA,MAAA,GAIA,KAAA,WAKA,IAAA,GAJA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAEA,EAAA,GAAA,GAAA,OAAA,EAAA,GACA,EAAA,EAAA,QACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,GAAA,CAEA,GAAA,EAAA,KAAA,EAAA,GAAA,EAAA,GACA,EAAA,GAAA,EACA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,GAEA,EAAA,GAAA,IACA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,IAGA,MAAA,IAIA,MAAA,WACA,GACA,GAAA,EAAA,EAAA,EAAA,EAAA,EADA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,CAQA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,EAKA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAIA,GAAA,GAAA,CAEA,KADA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,KAAA,IAAA,EAAA,GAEA,IAAA,IAAA,EAEA,IADA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,KAAA,EAAA,GAAA,EACA,EAAA,EAAA,KAAA,EAAA,GAAA,MAGA,CAIA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,IAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAUA,KARA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,KAAA,GACA,EAAA,IACA,GAAA,GAEA,EAAA,GAAA,EAAA,EACA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,CAKA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAIA,IAHA,EAAA,EAAA,GACA,EAAA,EAAA,KAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GACA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,CAEA,GAAA,GAAA,EAGA,IADA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,IAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAEA,IAAA,GAAA,GAAA,EAAA,EACA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,IAAA,EAAA,EAAA,EAEA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAGA,IAFA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAEA,GAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,KAAA,EAAA,GAAA,GAGA,EAAA,GAAA,EAKA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAIA,GAHA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAEA,KAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAEA,KAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IAIA,IAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,IAAA,EAGA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,GAAA,EAAA,GAAA,CAEA,IAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EACA,EAAA,GAAA,GAIA,KAAA,WACA,GACA,GAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAFA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,CASA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EAEA,GAAA,EAAA,GAAA,CAEA,IAAA,GAAA,EACA,EAAA,EACA,EAAA,KAAA,IAAA,EAAA,IACA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAIA,EAAA,KAAA,IAAA,EAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,IAEA,KADA,GAAA,GAAA,EACA,EAAA,KACA,KAAA,IAAA,EAAA,KAAA,EAAA,IAGA,GAMA,IAAA,EAAA,EAAA,CACA,EAAA,CACA,GAAA,CACA,GAAA,EAIA,EAAA,EAAA,GACA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,GACA,IAAA,GAAA,EAAA,OAAA,MAAA,EAAA,EACA,GAAA,IACA,GAAA,GAEA,EAAA,GAAA,EAAA,IAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EACA,IAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EACA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,IAAA,CAEA,IAAA,EAIA,EAAA,EAAA,EACA,IAAA,GAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EAAA,EAAA,GACA,EAAA,EACA,EAAA,CACA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAeA,IAdA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,OAAA,MAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAIA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,CAGA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,GAAA,EAAA,EACA,EAAA,GAAA,EAAA,QAIA,KAAA,IAAA,EAAA,IAAA,EAAA,GAEA,EAAA,GAAA,EAAA,GAAA,EACA,EAAA,GAAA,EAKA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAGA,IAFA,EAAA,EACA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,IACA,EAAA,EACA,EAAA,EAAA,GAGA,IAAA,IAAA,EAGA,IAFA,EAAA,GAAA,EAAA,GACA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,KAAA,EAAA,GACA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,IAOA,OAAA,WACA,GACA,GAAA,EAAA,EAAA,EAAA,EADA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,IAQA,EAAA,EACA,EAAA,EAAA,CAEA,KAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAIA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,KAAA,IAAA,EAAA,EAAA,GAAA,EAAA,IAEA,IAAA,IAAA,EAAA,CAIA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EACA,GAAA,EAAA,GAAA,EAAA,EAYA,KAVA,EAAA,KAAA,KAAA,GACA,EAAA,GAAA,IACA,GAAA,GAEA,GAAA,EAAA,GAAA,EACA,EAAA,GAAA,EAAA,GAAA,EAKA,EAAA,EAAA,EAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAGA,KADA,GAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,IAAA,EAAA,EAAA,GAIA,IAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAGA,KADA,GAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,IAAA,EAAA,EAAA,GAGA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAMA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,GAAA,IAAA,EAAA,EAAA,CAIA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,IAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAEA,KAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAIA,KADA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,IAAA,EAAA,EAAA,MAQA,KAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,CACA,MAAA,IAAA,GAAA,KAAA,IAAA,IACA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,KAAA,OAAA,EAAA,EAAA,GAAA,EACA,KAAA,OAAA,EAAA,EAAA,GAAA,IAGA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,KAAA,OAAA,EAAA,EAAA,GAAA,EACA,KAAA,OAAA,EAAA,EAAA,GAAA,IAKA,KAAA,WACA,GAAA,GACA,EAAA,EAAA,EAAA,EAAA,EACA,EAFA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAWA,EAAA,KAAA,CACA,GAAA,EAAA,CACA,IAIA,GAAA,EAAA,EAAA,EAJA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,KAAA,IAAA,EAAA,KACA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAIA,EAAA,CACA,KAAA,EAAA,EAAA,EAAA,EAAA,IAKA,KAJA,EAAA,GAAA,EAAA,KACA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,GAEA,EAAA,KAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IACA,GAAA,KAAA,IAAA,EAAA,EAAA,KAAA,EAAA,GAOA,KADA,EAAA,EACA,GAAA,GAAA,CAKA,IADA,EAAA,EACA,EAAA,IACA,EAAA,KAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,KAAA,KAAA,IAAA,EAAA,EAAA,EAAA,IACA,IAAA,IACA,EAAA,KAEA,KAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAAA,EAAA,KAGA,GAMA,IAAA,IAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,EACA,IACA,EAAA,MAKA,IAAA,IAAA,EAAA,EAAA,CAWA,GAVA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,KAAA,KAAA,KAAA,IAAA,IACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EACA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAIA,GAAA,EAAA,CAwBA,IAtBA,EADA,GAAA,EACA,EAAA,EAGA,EAAA,EAEA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,GAAA,EAAA,EAAA,GACA,IAAA,IACA,EAAA,GAAA,EAAA,EAAA,GAEA,EAAA,EAAA,GAAA,EACA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,IAAA,GAAA,KAAA,IAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,KAAA,KAAA,EAAA,EAAA,EAAA,GACA,GAAA,EACA,GAAA,EAIA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,CAKA,KAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,CAKA,KAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,MAOA,GAAA,EAAA,GAAA,EAAA,EACA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,IAAA,CAEA,IAAA,EACA,EAAA,MAKA,CAcA,GAVA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,IAKA,KAAA,EAAA,CAEA,IADA,GAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,CAEA,GAAA,KAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,KAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,IACA,EAAA,EAAA,IAAA,EACA,GAAA,MAAA,EAAA,EAKA,GAAA,KAAA,IACA,GAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,CAMA,IALA,EAAA,KAAA,KAAA,GACA,EAAA,IACA,GAAA,GAEA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,CAEA,IAAA,EACA,EAAA,EAAA,EAAA,KASA,IALA,GAAA,EAIA,EAAA,EAAA,EACA,GAAA,IACA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,KAAA,IAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,IAAA,MAGA,KAAA,IAAA,EAAA,EAAA,GAAA,EAAA,MAAA,KAAA,IAAA,GAAA,KAAA,IAAA,IACA,EAAA,KAAA,IAAA,IAAA,KAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,KAAA,IAAA,GACA,KAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,OAGA,GAGA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAMA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,GAAA,GAAA,IAAA,EAAA,CAYA,IAXA,IAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EACA,EAAA,KAAA,IAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,GACA,IAAA,IACA,GAAA,EACA,GAAA,EACA,GAAA,IAGA,IAAA,EACA,KAMA,IAJA,EAAA,KAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,IACA,GAAA,GAEA,IAAA,EAAA,CAgBA,IAfA,IAAA,EACA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAEA,IAAA,IACA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAEA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,GAAA,EACA,GAAA,EAIA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GACA,IACA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAEA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EACA,GAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,CAKA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,EAAA,GAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAEA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,CAKA,KAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,IACA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAEA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,KASA,GAAA,IAAA,EAAA,CAIA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAMA,GALA,EAAA,EAAA,GACA,EAAA,EAAA,GAIA,IAAA,EAGA,IAFA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAGA,IAFA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAEA,IAAA,EAAA,GAAA,EACA,EAAA,EACA,EAAA,MAgCA,IA7BA,EAAA,EACA,IAAA,EAAA,GAEA,EAAA,EAAA,EAAA,GADA,IAAA,GACA,EAAA,GAGA,GAAA,EAAA,IAOA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,GAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAEA,GAAA,EAAA,GAAA,EAAA,GADA,KAAA,IAAA,GAAA,KAAA,IAAA,KACA,EAAA,EAAA,GAAA,IAGA,EAAA,EAAA,GAAA,GAMA,EAAA,KAAA,IAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,MASA,IAAA,EAAA,EAgBA,IAfA,EAAA,EAAA,EAIA,KAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,KAAA,IAAA,GAAA,EAAA,GAAA,EAAA,KACA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAGA,KAAA,KAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,GACA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,KAAA,MACA,GAAA,EAAA,GAAA,EAAA,GAAA,KAAA,OAEA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,EAAA,CAGA,KAFA,EAAA,EACA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAIA,IAFA,EAAA,EAAA,EAAA,EAAA,GAAA,EAEA,EAAA,GAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,MAqCA,IAlCA,EAAA,EACA,IAAA,EAAA,IACA,KAAA,MAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,EAAA,GAAA,KAAA,QAMA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,GAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EACA,EAAA,GAAA,EAAA,GAAA,GAAA,EACA,IAAA,GAAA,IAAA,IACA,EAAA,EAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,GACA,KAAA,IAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,KAEA,KAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,EAAA,GAAA,KAAA,MACA,KAAA,IAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,IACA,GAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EACA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAGA,KAAA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GACA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,KAAA,MACA,GAAA,EAAA,GAAA,EAAA,GAAA,KAAA,QAKA,EAAA,KAAA,IAAA,KAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,KAAA,IAAA,EAAA,EAAA,EAAA,KACA,EAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EASA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,GAAA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAMA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,IAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,IACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAEA,GAAA,EAAA,KAAA,EAAA,GAAA,MAMA,ICr5BA,EAAA,sBAAA,UAAA,UAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UA6CA,OA1CA,GAAA,YAUA,EAAA,eAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAEA,EAAA,EAAA,YAAA,IAAA,EAAA,CAOA,IAAA,GAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,KAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EACA,IAAA,EAAA,CACA,GAAA,GAAA,KAAA,IAAA,EAAA,GACA,EAAA,KAAA,IAAA,EAAA,EACA,GAAA,EAAA,KAAA,MAAA,EAAA,EAAA,GAEA,MAAA,IAIA,EAAA,SAAA,GACA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAQA,OAJA,GAAA,QAAA,SAAA,GACA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGA,GAGA,EAAA,iBCtDA,EAAA,uBAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WAEA,EAAA,OAAA,cAAA,KAIA,GAAA,gBAAA,SAAA,GACA,GAAA,GAAA,EAAA,CAEA,MAAA,OAAA,EAGA,KAAA,GAAA,EAAA,cACA,IAAA,GAAA,KAAA,EACA,MAAA,EAAA,EAAA,iBACA,IAAA,GAAA,KAAA,CACA,MAAA,EAAA,EAAA,oBACA,IAAA,GAAA,KAAA,CAEA,KADA,KAAA,IAAA,GAAA,aAAA,GACA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,IAAA,GAAA,CAEA,MAAA,QAAA,CACA,IAAA,GAAA,GAAA,GAAA,EAIA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAGA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,MAAA,EAAA,GAKA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAEA,GAAA,GAAA,KAAA,IAAA,EAAA,GACA,EAAA,CACA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,MAAA,EAAA,EACA,IAAA,EAAA,GAAA,EAAA,GAGA,EAAA,IAAA,EACA,EAAA,EAAA,MAAA,EAAA,IAAA,EAAA,GAKA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,MACA,EAAA,EAGA,IAAA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,MAAA,EAAA,GACA,EAAA,EAAA,MAAA,EAAA,GACA,EAAA,EAAA,EACA,GAAA,GAAA,EAAA,GACA,EAAA,GAAA,EAEA,EAAA,KAAA,IAAA,GACA,KAAA,IAAA,GAAA,KAAA,IAAA,GACA,KAAA,IAAA,GAAA,EACA,KAAA,SAAA,KAAA,QAKA,GAAA,EAAA,GAAA,IAAA,EAAA,KAAA,OAAA,MAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,MAAA,EAAA,KAAA,EAAA,EAAA,MAAA,EAAA,KAKA,IAAA,GAAA,EAAA,eAgHA,OA9GA,GAAA,WACA,YAAA,EAEA,cAAA,WACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,OAAA,MAAA,EAAA,EACA,IAAA,IAAA,KAAA,GAAA,GACA,OAAA,EAGA,OAAA,GAGA,KAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,OAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAEA,EAAA,QAAA,EAAA,MAAA,EAAA,IADA,EAAA,EACA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAEA,IAAA,EACA,EAGA,CAIA,OAAA,IAGA,KAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,OAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAEA,EAAA,QAAA,EAAA,MAAA,EAAA,IADA,GAAA,EACA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAGA,CAIA,OAAA,IAGA,SAAA,WAEA,IAAA,GADA,GAAA,GAAA,aAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,GAAA,KAAA,IAAA,EAEA,OAAA,IAGA,eAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,GAAA,KAAA,IAAA,EAEA,OAAA,IAGA,IAAA,WACA,GAAA,KAAA,IAAA,KAAA,EACA,KAAA,IAAA,OAAA,yBAGA,KAAA,GADA,GAAA,KAAA,QACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,GAEA,OAAA,IAGA,MAAA,SAAA,GACA,GAAA,GAAA,EAAA,CACA,IAAA,EAAA,oBAAA,KAAA,EACA,KAAA,IAAA,OAAA,oCAEA,KAAA,KAAA,gBACA,KAAA,IAAA,OAAA,sBAIA,IAAA,GAAA,EAAA,qBACA,EAAA,EAAA,kBAAA,KAAA,IAAA,EAAA,EAAA,EAGA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,GAMA,KAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,KAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,GAEA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAIA,MAAA,KAIA,ICnMA,EAAA,qBAAA,WAAA,WAGA,MAAA,UAAA,GAEA,MAAA,mBAAA,OAAA,UAAA,SAAA,KAAA,MCLA,EAAA,kCAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WAEA,EAAA,OAAA,cAAA,KAIA,GAAA,2BAAA,SAAA,GACA,KAAA,OAAA,CAEA,IAAA,GAAA,EAIA,EAAA,EAAA,cACA,MAAA,EAAA,EAAA,kBACA,KAAA,EAAA,EAAA,oBACA,IAAA,GAAA,KAAA,EACA,EAAA,KAAA,EAEA,EAAA,KAAA,IACA,EAAA,KAAA,IACA,EAAA,KAAA,IACA,EAAA,KAAA,IAOA,EAAA,EAAA,EAAA,EACA,MAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GACA,IAAA,GAAA,KAAA,CACA,MAAA,EAAA,GAAA,GAAA,EAAA,EACA,IAAA,GAAA,KAAA,CACA,MAAA,EAAA,GAAA,GAAA,EAAA,EACA,IAMA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAPA,EAAA,KAAA,EACA,EAAA,GAAA,GAAA,GACA,EAAA,GAAA,GAAA,GACA,GAAA,EACA,GAAA,EAKA,EAAA,EAAA,OAAA,MAKA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,CACA,GAAA,EAAA,EAAA,CAMA,IADA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAEA,IAAA,IAAA,EAAA,GAAA,CAIA,IAHA,EAAA,EAAA,EAAA,GAAA,IACA,EAAA,IAAA,EAAA,IAEA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAEA,GAAA,EAAA,EAAA,IAAA,EAEA,EAAA,IAAA,EAAA,GAEA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,EAAA,GAAA,IAAA,EAAA,GAAA,CAKA,IADA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAGA,KADA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAOA,EAAA,GAAA,EAAA,EAAA,EAAA,GAEA,GAAA,GAAA,EAAA,EAKA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAGA,IAAA,EAAA,EAAA,CAMA,IADA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAEA,IAAA,IAAA,EAAA,GAAA,CAIA,IAHA,EAAA,EAAA,GAAA,IACA,EAAA,IAAA,EAAA,IAEA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,IAAA,EAAA,EAEA,GAAA,EAAA,IAAA,EAGA,GADA,EAAA,IAAA,EAAA,GACA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,CAIA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,CAEA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAGA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAEA,IADA,GAAA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAIA,GAAA,EAKA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,EAAA,IAQA,GAAA,GAAA,EAAA,EAAA,EAAA,EAcA,IAbA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,EAAA,IAEA,EAAA,IACA,EAAA,EAAA,GAAA,GAEA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAEA,EAAA,EAAA,GAAA,EAIA,EAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,CAEA,GAAA,EAAA,EAAA,GAAA,EAEA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,IAAA,EAAA,GAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAGA,KADA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAGA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAGA,KADA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,MAGA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,CAEA,GAAA,EAAA,EAAA,GAAA,GAOA,GAAA,EACA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,GAAA,EAAA,GAAA,IAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAGA,KADA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAIA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,GAAA,CAEA,GAAA,EAAA,EAAA,GAAA,EAUA,IAJA,GAAA,GAAA,EAAA,EACA,EAAA,EACA,EAAA,EAAA,EAAA,KACA,EAAA,EAAA,EAAA,MACA,EAAA,GAAA,CACA,GAAA,EAcA,KAAA,EAAA,EAAA,EAAA,GAAA,IACA,KAAA,EADA,IAIA,GAAA,EAAA,EAAA,KACA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,CACA,EAAA,GAAA,CACA,OAGA,GAAA,IAAA,EAAA,EACA,EAAA,MAEA,CACA,GAAA,EACA,KAAA,EAAA,EAAA,EAAA,GAAA,GACA,IAAA,EADA,IAMA,GAFA,GAAA,IAAA,EAAA,EAAA,EAAA,IAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,CACA,EAAA,GAAA,CACA,OAGA,IAAA,EACA,EAAA,EAEA,IAAA,EAAA,EACA,EAAA,GAGA,EAAA,EACA,EAAA,GAOA,OAJA,IAIA,GAIA,IAAA,GAIA,IAFA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,IASA,GARA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,GAAA,EACA,IAAA,IACA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAEA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,CAKA,MAIA,KAAA,GAIA,IAFA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,IAOA,GANA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,GAAA,EACA,GAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,EAAA,GACA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,CAKA,MAIA,KAAA,GAKA,GAAA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KACA,EAAA,EAAA,KAAA,EAAA,EAAA,KACA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,EACA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GACA,IAAA,GAAA,IAAA,KACA,EAAA,KAAA,KAAA,EAAA,EAAA,GACA,EAAA,IACA,GAAA,GAEA,EAAA,GAAA,EAAA,IAEA,GAAA,EAAA,IAAA,EAAA,GAAA,CACA,IAAA,GAAA,EAAA,CAIA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAWA,GAVA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,IAAA,IACA,EAAA,EAAA,GAAA,GAEA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,CAWA,IARA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,GAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,EAIA,EAAA,EAAA,GAAA,EACA,GAAA,CAEA,MAIA,KAAA,GAKA,GAAA,EAAA,IAAA,IACA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EACA,GACA,IAAA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAOA,MAAA,EAAA,KACA,EAAA,IAAA,EAAA,EAAA,KADA,CAOA,GAHA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EACA,GAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,CAGA,IAAA,GAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,CAGA,KAEA,EAAA,EACA,MAMA,IAAA,GAAA,EAAA,0BAEA,GAAA,WACA,YAAA,EAEA,KAAA,WACA,MAAA,IAAA,GAAA,OAAA,KAAA,EAAA,KAAA,IAAA,KAAA,EAAA,EAAA,KAAA,GAAA,KAAA,GAAA,IAGA,KAAA,WACA,MAAA,IAAA,GAAA,OAAA,KAAA,EAAA,KAAA,EAAA,KAAA,GAAA,IAGA,kBAAA,WACA,MAAA,MAAA;EAGA,KAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,OAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,CAEA,GAAA,QAAA,EAAA,MAAA,EAAA,IAAA,KAAA,EAAA,GAEA,MAAA,IAGA,MAAA,WACA,MAAA,MAAA,EAAA,IAGA,KAAA,WACA,MAAA,MAAA,EAAA,GAAA,KAAA,EAAA,KAAA,IAAA,KAAA,EAAA,KAAA,GAAA,IAGA,KAAA,WAKA,IAAA,GAHA,GAAA,KAAA,IAAA,EAAA,KACA,EAAA,KAAA,IAAA,KAAA,EAAA,KAAA,GAAA,KAAA,EAAA,GAAA,EACA,EAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,OAAA,IACA,KAAA,EAAA,GAAA,GACA,GAGA,OAAA,OC1fA,EAAA,uBAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WAEA,EAAA,OAAA,cAAA,KAIA,GAAA,gBAAA,SAAA,GACA,KAAA,OAAA,EAGA,KAAA,GAAA,EAAA,cACA,IAAA,GAAA,KAAA,EACA,MAAA,EAAA,EAAA,iBACA,IAAA,GAAA,KAAA,CACA,MAAA,EAAA,EAAA,oBACA,IAAA,GAAA,KAAA,CAEA,MAAA,MAAA,GAAA,GAAA,EAEA,IAAA,GAAA,EAAA,CAGA,KAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAEA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,OAAA,MAAA,EAAA,EAAA,KAAA,OAAA,MAAA,EAAA,IAGA,IAAA,IAAA,EAAA,CAKA,IAHA,EAAA,KAAA,OAAA,MAAA,EAAA,IAAA,IACA,GAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,KAAA,OAAA,MAAA,EAAA,KAAA,CAKA,KAHA,EAAA,KAAA,OAAA,MAAA,EAAA,KAAA,EAGA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,KAAA,OAAA,MAAA,EAAA,IAAA,EAAA,KAAA,OAAA,MAAA,EAAA,GAGA,KADA,GAAA,EAAA,EAAA,KAAA,OAAA,MAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,KAAA,OAAA,MAAA,EAAA,KAAA,EAAA,EAAA,KAAA,OAAA,MAAA,EAAA,KAIA,KAAA,MAAA,IAAA,GAGA,IAAA,GAAA,EAAA,eAkHA,OAhHA,GAAA,WACA,YAAA,EAEA,WAAA,WACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,IAAA,KAAA,MAAA,GACA,OAAA,CAGA,QAAA,GAGA,KAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,OAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAEA,EAAA,QAAA,EAAA,MAAA,EAAA,IADA,GAAA,EACA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAGA,CAIA,OAAA,IAGA,KAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,OAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAEA,EAAA,QAAA,EAAA,MAAA,EAAA,IADA,EAAA,EACA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAEA,IAAA,EACA,KAAA,MAAA,GAGA,CAIA,OAAA,IAGA,KAAA,WACA,GAAA,GAAA,EAAA,EACA,EAAA,GAAA,GAAA,OAAA,KAAA,EAAA,KAAA,EACA,KAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,CAGA,KADA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,IAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAAA,CACA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAAA,EAAA,QAAA,EAAA,MAAA,EAAA,GAGA,KADA,GAAA,EAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,KAAA,EAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,KAKA,MAAA,IAGA,MAAA,SAAA,GACA,GAAA,EAAA,oBAAA,KAAA,EACA,KAAA,IAAA,OAAA,oCAEA,KAAA,KAAA,aACA,KAAA,IAAA,OAAA,4BAGA,IAAA,GAAA,EAAA,EAGA,EAAA,EAAA,qBACA,EAAA,EAAA,cAGA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,CACA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAAA,EAAA,EAAA,MAAA,EAAA,GAGA,KADA,GAAA,EAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,EAAA,MAAA,EAAA,KAAA,EAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAMA,IAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,MAAA,EAAA,KAAA,KAAA,MAAA,EAEA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,MAAA,EAAA,KAAA,EAAA,EAAA,MAAA,EAAA,IAAA,KAAA,GAAA,KAAA,OAAA,MAAA,EAAA,IAIA,MAAA,IAAA,GAAA,OAAA,EAAA,KAAA,EAAA,GAAA,UAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,KAIA,IC3KA,EAAA,cAAA,UAAA,gBAAA,UAAA,oBAAA,iCAAA,sBAAA,sBAAA,8BAAA,cAAA,cAAA,eAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAAA,OAEA,EAAA,EAAA,WAEA,EAAA,OAAA,cAAA,MAEA,EAAA,EAAA,oBAEA,GAAA,kCACA,EAAA,uBACA,EAAA,uBACA,EAAA,+BACA,EAAA,eACA,EAAA,eACA,EAAA,eAEA,EAAA,OAAA,SAAA,EAAA,EAAA,EAAA,GACA,KAAA,EAAA,EACA,KAAA,EAAA,CAEA,IAAA,GAAA,EAAA,CACA,MAAA,KAAA,CACA,IAAA,EAEA,IAAA,EACA,KAAA,QAAA,MAUA,IAPA,IACA,EAAA,GAIA,KAAA,QAAA,GAAA,GAAA,GAEA,EAAA,GAGA,IAFA,GAAA,EAAA,EAAA,SAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,QAAA,GAAA,EAAA,OAIA,KAAA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,QAAA,GAAA,EAKA,IAAA,GAAA,EAAA,MAseA,OAneA,GAAA,MAAA,SAAA,EAAA,GACA,GAAA,EAYA,OAXA,MAAA,IAAA,GAAA,KAAA,IAAA,IACA,EAAA,EAAA,EACA,EAAA,KAAA,IAAA,GAAA,KAAA,KAAA,EAAA,EAAA,IAEA,IAAA,GACA,EAAA,EAAA,EACA,EAAA,KAAA,IAAA,GAAA,KAAA,KAAA,EAAA,EAAA,IAGA,EAAA,EAEA,GAGA,EAAA,WACA,YAAA,EAEA,KAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,KAAA,IACA,EAAA,QAAA,GAAA,KAAA,QAAA,EAEA,OAAA,IAGA,SAAA,WACA,MAAA,MAAA,SAGA,aAAA,WACA,MAAA,IAAA,GAAA,KAAA,UAGA,gBAAA,WACA,MAAA,MAAA,GAGA,mBAAA,WACA,MAAA,MAAA,GAIA,MAAA,SAAA,EAAA,GACA,MAAA,GAAA,KAAA,EAAA,GAGA,IAAA,SAAA,EAAA,GACA,MAAA,MAAA,QAAA,KAAA,MAAA,EAAA,KAGA,IAAA,SAAA,EAAA,EAAA,GACA,KAAA,QAAA,KAAA,MAAA,EAAA,IAAA,GAGA,UAAA,SAAA,EAAA,EAAA,EAAA,GAEA,IAAA,GADA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,GAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,EAAA,EAAA,IAAA,KAAA,QAAA,KAAA,MAAA,EAAA,GAGA,OAAA,IAIA,kBAAA,SAAA,EAAA,EAAA,GAEA,IAAA,GADA,GAAA,GAAA,GAAA,EAAA,OAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,IAAA,GAAA,GAAA,EAAA,GAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,EAAA,IAAA,KAAA,QAAA,KAAA,MAAA,EAAA,GAAA,GAGA,OAAA,IAGA,UAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,KAAA,QAAA,KAAA,MAAA,EAAA,GAGA,OAAA,IAGA,MAAA,WAEA,IAAA,GADA,GAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CAEA,IAAA,GADA,GAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,KAAA,IAAA,KAAA,QAAA,KAAA,MAAA,EAAA,IAEA,GAAA,KAAA,IAAA,EAAA,GAEA,MAAA,IAGA,MAAA,WACA,MAAA,IAAA,GAAA,2BAAA,MAAA,SAGA,QAAA,WAEA,IAAA,GADA,GAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CAEA,IAAA,GADA,GAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,KAAA,IAAA,KAAA,QAAA,KAAA,MAAA,EAAA,IAEA,GAAA,KAAA,IAAA,EAAA,GAEA,MAAA,IAGA,MAAA,WAEA,IAAA,GADA,GAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,EAAA,MAAA,EAAA,KAAA,QAAA,KAAA,MAAA,EAAA,IAGA,OAAA,IAGA,OAAA,WAEA,IAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,KAAA,KAAA,QAAA,KAAA,MAAA,EAAA,GAGA,OAAA,IAGA,KAAA,SAAA,GACA,KAAA,sBAAA,EAEA,KAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,MAAA,EAAA,EACA,GAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,IAGA,WAAA,SAAA,GACA,KAAA,sBAAA,EAEA,KAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,MAAA,EAAA,EACA,MAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,OAGA,MAAA,SAAA,GACA,KAAA,sBAAA,EAEA,KAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,GAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,IAGA,YAAA,SAAA,GACA,KAAA,sBAAA,EACA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,MAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,OAGA,WAAA,SAAA,GACA,KAAA,sBAAA,EAEA,KAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,MAAA,EAAA,EACA,GAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,IAGA,iBAAA,SAAA,GACA,KAAA,sBAAA,EACA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,MAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,OAGA,iBAAA,SAAA,GACA,KAAA,sBAAA,EAEA,KAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,GAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,IAGA,uBAAA,SAAA,GACA,KAAA,sBAAA,EACA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,MAAA,QAAA,GAAA,KAAA,QAAA,GAAA,EAAA,QAAA,GAGA,MAAA,OAGA,gBAAA,SAAA,GACA,KAAA,sBAAA,EAEA,KAAA,GADA,GAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,GAAA,QAAA,GAAA,EAAA,QAAA,GAAA,KAAA,QAAA,GAGA,MAAA,IAGA,sBAAA,SAAA,GACA,KAAA,sBAAA,EACA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,MAAA,QAAA,GAAA,EAAA,QAAA,GAAA,KAAA,QAAA,GAGA,MAAA,OAGA,MAAA,SAAA,GACA,GAAA,GACA,EAAA,EAAA,EAAA,EACA,CACA,IAAA,EAAA,SAAA,CAEA,GADA,EAAA,EACA,EAAA,IAAA,KAAA,EACA,KAAA,IAAA,OAAA,sCAEA,GAAA,GAAA,GAAA,KAAA,EAAA,EAAA,EACA,IAAA,GAAA,GAAA,GAAA,KAAA,EACA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,GAAA,EAAA,QAAA,EAAA,MAAA,EAAA,GAEA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CAEA,IADA,EAAA,EACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,GAAA,KAAA,QAAA,KAAA,MAAA,EAAA,IAAA,EAAA,EAEA,GAAA,QAAA,EAAA,MAAA,EAAA,IAAA,GAGA,MAAA,GAKA,IAFA,EAAA,EACA,EAAA,GAAA,GAAA,KAAA,EAAA,KAAA,GACA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,EAAA,KAAA,QAAA,KAAA,MAAA,EAAA,GAGA,OAAA,IAIA,YAAA,SAAA,GACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,IAAA,CACA,GAAA,GAAA,KAAA,MAAA,EAAA,EACA,MAAA,QAAA,GAAA,EAAA,KAAA,QAAA,GAGA,MAAA,OAGA,MAAA,SAAA,GACA,MAAA,MAAA,IAAA,KAAA,EAAA,GAAA,GAAA,gBAAA,MAAA,MAAA,GACA,GAAA,GAAA,gBAAA,MAAA,MAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,YAAA,MAAA,EAAA,cAGA,QAAA,WACA,MAAA,MAAA,MAAA,EAAA,SAAA,KAAA,EAAA,KAAA,KAGA,IAAA,WACA,MAAA,IAAA,GAAA,gBAAA,MAAA,OAGA,KAAA,WACA,MAAA,IAAA,GAAA,2BAAA,MAAA,QAGA,KAAA,WACA,MAAA,IAAA,GAAA,2BAAA,MAAA,QAGA,MAAA,WAEA,IAAA,GADA,GAAA,EACA,EAAA,EAAA,EAAA,KAAA,IAAA,KAAA,EAAA,KAAA,GAAA,IACA,GAAA,KAAA,QAAA,KAAA,MAAA,EAAA,GAEA,OAAA,IAGA,sBAAA,SAAA,GACA,GAAA,EAAA,IAAA,KAAA,GAAA,EAAA,IAAA,KAAA,EACA,KAAA,IAAA,OAAA,kCAIA,SAAA,WACA,GAAA,GAAA,EACA,IAAA,QAAA,KAAA,kBAAA,IAAA,KAAA,qBAAA,IACA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,kBAAA,IAAA,CACA,IAAA,GAAA,GAAA,EAAA,EAAA,KAAA,qBAAA,IACA,GAAA,KAAA,IAAA,EAAA,GAAA,GAEA,IAAA,KAEA,MAAA,IAIA,eAAA,SAAA,GAEA,MADA,IAAA,EAAA,IAAA,KAAA,GACA,GAAA,GAAA,QAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAIA,eAAA,SAAA,GAEA,MADA,IAAA,EAAA,IAAA,KAAA,GACA,GAAA,GAAA,QAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAIA,eAAA,SAAA,GAEA,MADA,IAAA,EAAA,IAAA,KAAA,GACA,GAAA,GAAA,QAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAGA,UAAA,GAGA,EAAA,SAAA,SAAA,EAAA,GAEA,IAAA,GADA,GAAA,GAAA,GAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,IACA,EAAA,QAAA,EAAA,MAAA,EAAA,IAAA,IAAA,EAAA,EAAA,CAGA,OAAA,IAGA,EAAA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAGA,EAAA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAGA,EAAA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAGA,EAAA,UAAA,SAAA,GACA,GAAA,EAAA,UACA,MAAA,GAAA,WAAA,EAEA,IAAA,EAAA,UACA,MAAA,GAAA,WAAA,EAEA,IAAA,EAAA,UACA,MAAA,GAAA,WAAA,EAGA,MAAA,IAAA,OAAA,8BAAA,EAAA,aAIA,EAAA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAGA,EAAA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAGA,EAAA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAGA,EAAA,aAAA,SAAA,GACA,GAAA,EAAA,UACA,MAAA,GAAA,cAAA,EAEA,IAAA,EAAA,UACA,MAAA,GAAA,cAAA,EAEA,IAAA,EAAA,UACA,MAAA,GAAA,cAAA,EAGA,MAAA,IAAA,OAAA,8BAAA,EAAA,aAQA,EAAA,aAAA,SAAA,GAKA,IAAA,GAJA,GAAA,EACA,EAAA,EAAA,OACA,EAAA,GAAA,GAAA,EAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,EACA,GAAA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,EAGA,MAAA,IAAA,GAAA,EAAA,EAAA,GAAA,IAGA,EAAA,aAAA,SAAA,GAKA,IAAA,GAJA,GAAA,EACA,EAAA,EAAA,OACA,EAAA,GAAA,GAAA,EAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,EACA,GAAA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAGA,MAAA,IAAA,GAAA,EAAA,EAAA,GAAA,IAGA,EAAA,aAAA,SAAA,GAKA,IAAA,GAJA,GAAA,EACA,EAAA,EAAA,OACA,EAAA,GAAA,GAAA,EAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,EACA,GAAA,GAAA,EAAA,EACA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAGA,MAAA,IAAA,GAAA,EAAA,EAAA,GAAA,IAGA,IC1hBA,EAAA,mBAAA,UAAA,gBAAA,UAAA,oBAAA,YAAA,SAAA,GAyCA,QAAA,GAAA,EAAA,EAAA,GACA,GAAA,IAAA,EAAA,OACA,EAAA,KAAA,OAAA,OAGA,KAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CACA,GAAA,GAAA,EAAA,GAGA,EAAA,EAAA,MAAA,EACA,GAAA,OAAA,EAAA,EAGA,IAAA,GAAA,EAAA,MAAA,EACA,GAAA,KAAA,GAEA,EAAA,EAAA,EAAA,IAtDA,GAAA,GAAA,EAAA,iBAAA,OAEA,EAAA,EAAA,WAEA,EAAA,EAAA,oBACA,GAAA,WAGA,IAAA,GAAA,SAAA,GACA,KAAA,QAAA,EAyHA,OArHA,GAAA,SAAA,SAAA,GACA,GAAA,EAAA,GAAA,EAEA,KAAA,GADA,GAAA,GAAA,OAAA,GACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,CAEA,OAAA,IAAA,GAAA,IAIA,EAAA,aAAA,SAAA,GACA,GAAA,KAIA,OAHA,GAAA,mBAAA,EAAA,eAAA,EAAA,EAAA,GAAA,SAAA,GACA,EAAA,KAAA,GAAA,GAAA,MAEA,GA+BA,EAAA,mBAAA,SAAA,EAAA,GACA,EAAA,KAAA,IAGA,EAAA,WACA,YAAA,EAEA,KAAA,WACA,MAAA,MAAA,QAAA,QAGA,MAAA,SAAA,GACA,GAAA,EAAA,GAAA,CACA,GAAA,EAAA,SAAA,KAAA,OACA,KAAA,IAAA,OAAA,sBAAA,KAAA,OAAA,6BAAA,EAAA,OAKA,KAAA,GADA,GAAA,GAAA,OAAA,EAAA,QACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,GAAA,EAAA,KAAA,QAAA,GAEA,OAAA,GAIA,MAAA,MAAA,QAAA,IAKA,SAAA,WAEA,IAAA,GADA,GAAA,GAAA,OAAA,KAAA,QACA,EAAA,EAAA,EAAA,KAAA,OAAA,IACA,EAAA,KAAA,QAAA,IAAA,CAEA,OAAA,IAAA,GAAA,IAGA,oBAAA,SAAA,GACA,GAAA,MACA,EAAA,IAUA,OATA,GAAA,mBAAA,EAAA,SAAA,GAIA,IAAA,GAHA,GAAA,EAAA,QACA,EAAA,EAAA,MAAA,GAEA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,EAAA,IAAA,EAAA,EAAA,GAEA,GAAA,KAAA,GAAA,GAAA,MAEA,GAGA,SAAA,WACA,MAAA,KAAA,KAAA,QAAA,KAAA,MAAA,MAIA,EAAA,OAAA,SAAA,GACA,GAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,IAAA,EAAA,WAEA,IAAA,GAAA,EAAA,UACA,GAAA,IAAA,EAAA,YAEA,EAAA,IAAA,EAAA,qBAAA,EAAA,EAAA,IAAA,YAEA,EAAA,IAAA,EAAA,aAAA,GAAA,aAGA,ICrIA,EAAA,YAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,KAAA,SAAA,EAAA,GACA,KAAA,IAAA,EACA,KAAA,IAAA,EAEA,IAAA,GAAA,EAAA,IAkBA,OAhBA,GAAA,WACA,YAAA,EAEA,QAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,gBAAA,GAAA,KAAA,MAGA,gBAAA,SAAA,GACA,MAAA,MAAA,IAAA,KAAA,KAAA,IAAA,YAAA,KAGA,SAAA,WACA,MAAA,MAAA,IAAA,WAAA,OAAA,KAAA,IAAA,aAIA,IC3BA,EAAA,kBAAA,UAAA,UAAA,cAAA,cAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,eACA,EAAA,eACA,EAAA,YAGA,EAAA,WAAA,SAAA,GAEA,KAAA,IAAA,SAAA,EAAA,EAAA,QAAA,SAAA,GAEA,IAAA,GAAA,EAAA,UA0IA,OAxIA,GAAA,WACA,YAAA,EAEA,IAAA,SAAA,GACA,KAAA,OAAA,EAGA,KAAA,QAAA,KACA,KAAA,iBAAA,KACA,KAAA,kBAAA,MAGA,UAAA,WACA,MAAA,MAAA,QAGA,WAAA,WAIA,MAHA,QAAA,KAAA,UACA,KAAA,QAAA,KAAA,OAAA,YAEA,KAAA,SAGA,oBAAA,WAIA,MAHA,QAAA,KAAA,mBACA,KAAA,iBAAA,KAAA,OAAA,cAEA,KAAA,kBAGA,qBAAA,WAIA,MAHA,QAAA,KAAA,oBACA,KAAA,kBAAA,KAAA,aAAA,cAEA,KAAA,mBAGA,QAAA,SAAA,GACA,KAAA,IAAA,EAAA,YAAA,KAAA,UAGA,OAAA,SAAA,GACA,KAAA,IAAA,KAAA,OAAA,YAAA,KAGA,iBAAA,SAAA,GACA,KAAA,QAAA,EAAA,SAGA,gBAAA,SAAA,GACA,KAAA,OAAA,EAAA,SAGA,WAAA,WACA,MAAA,MAAA,OAAA,OAAA,EAAA,QAAA,MAAA,UAIA,qBAAA,SAAA,GACA,EAAA,aAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,OAAA,QAQA,mBAAA,SAAA,GACA,MAAA,MAAA,OAAA,aAAA,IAIA,gBAAA,SAAA,GACA,MAAA,MAAA,OAAA,qBAAA,IAIA,iBAAA,SAAA,GACA,MAAA,MAAA,aAAA,sBAAA,IAGA,gBAAA,SAAA,GACA,MAAA,MAAA,gBAAA,GAAA,GAAA,QAAA,EAAA,EAAA,IAAA,GAGA,gBAAA,SAAA,GACA,MAAA,MAAA,gBAAA,GAAA,GAAA,QAAA,EAAA,EAAA,IAAA,GAGA,gBAAA,SAAA,GACA,MAAA,MAAA,gBAAA,GAAA,GAAA,QAAA,EAAA,EAAA,IAAA,GAGA,aAAA,SAAA,GACA,MAAA,IAAA,GAAA,KACA,KAAA,mBAAA,EAAA,KACA,KAAA,mBAAA,EAAA,IAAA,KAAA,EAAA,MAAA,MAAA,KAAA,mBAAA,EAAA,QAOA,iBAAA,SAAA,GACA,MAAA,MAAA,aAAA,aAAA,IAGA,cAAA,SAAA,GAEA,MAAA,MAAA,iBAAA,GAAA,MAAA,KAAA,iBAAA,EAAA,QAAA,QAGA,eAAA,SAAA,GACA,MAAA,MAAA,OAAA,sBAAA,IAGA,cAAA,SAAA,GACA,MAAA,MAAA,cAAA,GAAA,GAAA,QAAA,EAAA,EAAA,IAAA,GAGA,cAAA,SAAA,GACA,MAAA,MAAA,cAAA,GAAA,GAAA,QAAA,EAAA,EAAA,IAAA,GAGA,cAAA,SAAA,GACA,MAAA,MAAA,cAAA,GAAA,GAAA,QAAA,EAAA,EAAA,IAAA,GAGA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,KACA,KAAA,iBAAA,EAAA,KACA,KAAA,iBAAA,EAAA,IAAA,KAAA,EAAA,MAAA,MAAA,KAAA,iBAAA,EAAA,SAKA,IC7JA,EAAA,YACA,UACA,cACA,cACA,kBACA,iBACA,8BACA,qBACA,sBACA,aACA,cACA,cACA,kBACA,sBACA,WACA,WACA,iCACA,iBACA,iBACA,WACA,cACA,cACA,eACA,SAAA,GAEA,MAAA,KCrBA,EAAA,uBAAA,WAAA,WA8BA,QAAA,GAAA,EAAA,EAAA,IACA,WACA,GAAA,GAAA,EAAA,UAAA,EACA,UAAA,KAAA,MAAA,EAAA,YACA,GAGA,MAAA,KChCA,EAAA,qBAAA,WAAA,WAGA,MAAA,UAAA,GACA,GAAA,KAIA,OAHA,GAAA,SAAA,GACA,EAAA,KAAA,KAEA,KCXA,EAAA,wBAAA,WAAA,WAGA,MAAA,UAAA,GAGA,MAAA,GAAA,QAAA,KAAA,SACA,QAAA,KAAA,QACA,QAAA,KAAA,QACA,QAAA,MAAA,UACA,QAAA,MAAA,UACA,QAAA,MAAA,aCbA,EAAA,8BAAA,WAAA,WAuBA,QAAA,GAAA,EAAA,GACA,GAAA,GAAA,OAAA,EAAA,UACA,GAAA,YAAA,EACA,EAAA,UAAA,EAGA,MAAA,KC5BA,EAAA,wBAAA,WAAA,WAaA,MAAA,UAAA,GAEA,gBAAA,KACA,GAAA,IAAA,GAGA,IAAA,GAAA,EAAA,IACA,EAAA,EAAA,SACA,EAAA,SAAA,EAAA,OAAA,EAAA,EAAA,MACA,EAAA,SAAA,EAAA,aAAA,EAAA,EAAA,YAEA,GAAA,EAEA,EAAA,SAAA,cAAA,SACA,GAAA,KAAA,kBACA,EAAA,MAAA,EACA,EAAA,OAAA,EAAA,mBAAA,WACA,GAAA,GAAA,KAAA,UACA,IAAA,aAAA,GAAA,WAAA,GAIA,IACA,GAAA,EAEA,GACA,MAMA,EAAA,IAAA,GAAA,EAAA,WAAA,KAAA,SAAA,QAAA,IAAA,GAEA,IAAA,GAAA,SAAA,qBAAA,UAAA,EACA,GAAA,WAAA,aAAA,EAAA,MCtDA,EAAA,kBAAA,UAAA,sBAAA,oBAAA,uBAAA,oBAAA,6BAAA,oBAAA,mBAAA,wBAAA,SAAA,GAGA,OACA,UAAA,EAAA,uBACA,QAAA,EAAA,qBACA,WAAA,EAAA,wBACA,QAAA,EAAA,qBACA,iBAAA,EAAA,8BACA,QAAA,EAAA,qBACA,OAAA,EAAA,oBACA,WAAA,EAAA,2BCVA,OAAA,MACA,OAAA,IAAA,IAAA,cAAA,WAEA,OAAA,IAEA,OAAA,IAAA,IAAA,oBAAA,WAEA,OAAA,KAIA,OAAA,kBAAA,EAEA,EAAA,QACA,MAAA,OAAA,WAAA,kBAEA,OACA,WAAA,+BACA,KAAA,IACA,IAAA,mBACA,UAAA,yBACA,OAAA,uBAGA,MACA,YAAA,QAAA,MAGA,SAAA,GAAA,OAAA,YAGA,EAAA,oBAAA,cAAA,OAAA,KAAA,EAAA,QAAA,OAAA,IAAA,EAAA","sourcesContent":["\n/**\n * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally\r\n * since it prevents Require.js issues with circular dependencies.\r\n *\r\n * The returned kite object namespace may be incomplete if not all modules are listed as\r\n * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/kite',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  // will be filled in by other modules\r\n  return {};\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/*\r\n * Usage:\r\n * var assert = require( '<assert>' )( 'flagName' );\r\n *\r\n * assert && assert( <simple value or big computation>, \"<message here>\" );\r\n *\r\n * TODO: decide on usages and viability, and if so document further\r\n *\r\n * NOTE: for changing build, add has.js tests for 'assert.' + flagName\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'ASSERT/assert',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = function( name, excludeByDefault ) {\r\n    var hasName = 'assert.' + name;\r\n    \r\n    var flagDefined = window.has && window.has( hasName ) !== undefined;\r\n    var skipAssert = flagDefined ? !window.has( hasName ) : excludeByDefault;\r\n    \r\n    if ( skipAssert ) {\r\n      return null;\r\n    } else {\r\n      return function( predicate, message ) {\r\n        var result = typeof predicate === 'function' ? predicate() : predicate;\r\n        \r\n        if ( !result ) {\r\n\r\n          //Log the stack trace to IE.  Just creating an Error is not enough, it has to be caught to get a stack.\r\n          //TODO: What will this do for IE9?  Probably just print stack = undefined.\r\n          if ( window.navigator && window.navigator.appName === 'Microsoft Internet Explorer' ) {\r\n            try { throw new Error(); }\r\n            catch( e ) { message = message + \", stack=\\n\" + e.stack; }\r\n          }\r\n          \r\n          // TODO: custom error?\r\n          throw new Error( 'Assertion failed: ' + message );\r\n        }\r\n      };\r\n    }\r\n  };\r\n  \r\n  return assert;\r\n} );\r\n","\n\r\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\ndefine( 'DOT/dot',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = function dot() {\r\n    switch ( arguments.length ) {\r\n      case 2:\r\n        return new dot.Vector2( arguments[0], arguments[1] );\r\n      case 3:\r\n        return new dot.Vector3( arguments[0], arguments[1], arguments[2] );\r\n      case 4:\r\n        return new dot.Vector4( arguments[0], arguments[1], arguments[2], arguments[3] );\r\n      default:\r\n        throw new Error( 'dot takes 2-4 arguments' );\r\n    }\r\n  };\r\n  \r\n  // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.\r\n  dot.FastArray = window.Float64Array ? window.Float64Array : window.Array;\r\n  \r\n  // will be filled in by other modules\r\n  return dot;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.\r\n *\r\n * See https://github.com/documentcloud/underscore/pull/986.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'PHET_CORE/extend',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function extend( obj ) {\r\n    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {\r\n      if ( source ) {\r\n        for ( var prop in source ) {\r\n          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\r\n        }\r\n      }\r\n    });\r\n    return obj;\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Experimental prototype inheritance\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\ndefine( 'PHET_CORE/inherit',['require','PHET_CORE/extend'],function( require ) {\r\n  'use strict';\r\n  \r\n  var extend = require( 'PHET_CORE/extend' );\r\n  \r\n  /**\r\n   * Experimental inheritance prototype, similar to Inheritance.inheritPrototype, but maintains\r\n   * supertype.prototype.constructor while properly copying ES5 getters and setters.\r\n   *\r\n   * TODO: find problems with this! It's effectively what is being used by Scenery\r\n   * TODO: consider inspecting arguments to see whether they are functions or just objects, to support\r\n   *       something like inherit( subtype, supertypeA, supertypeB, properties )\r\n   *\r\n   * Usage:\r\n   * function A() { scenery.Node.call( this ); };\r\n   * inherit( scenery.Node, A, {\r\n   *   customBehavior: function() { ... },\r\n   *   isAnA: true\r\n   * } );\r\n   * new A().isAnA // true\r\n   * new scenery.Node().isAnA // undefined\r\n   * new A().constructor.name // 'A'\r\n   *\r\n   * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )\r\n   * @param supertype           Constructor for the supertype.\r\n   * @param prototypeProperties [optional] object containing properties that will be set on the prototype.\r\n   * @param staticProperties [optional] object containing properties that will be set on the constructor function itself\r\n   */\r\n  function inherit( supertype, subtype, prototypeProperties, staticProperties ) {\r\n    function F() {}\r\n    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype\r\n    \r\n    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy\r\n      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely\r\n      { constructor: subtype }, // overrides the constructor properly\r\n      prototypeProperties       // [optional] additional properties for the prototype, as an object.\r\n    );\r\n\r\n    //Copy the static properties onto the subtype constructor so they can be accessed 'statically'\r\n    extend( subtype, staticProperties );\r\n    \r\n    return subtype; // pass back the subtype so it can be returned immediately as a module export\r\n  }\r\n\r\n  return inherit;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Utility functions for Dot, placed into the dot.X namespace.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Util',['require','ASSERT/assert','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference\r\n  \r\n  dot.Util = {\r\n    testAssert: function() {\r\n      return 'assert.dot: ' + ( assert ? 'true' : 'false' );\r\n    },\r\n    \r\n    clamp: function( value, min, max ) {\r\n      if ( value < min ) {\r\n        return min;\r\n      }\r\n      else if ( value > max ) {\r\n        return max;\r\n      }\r\n      else {\r\n        return value;\r\n      }\r\n    },\r\n    \r\n    // returns a number between [min,max) with the same equivalence class as value mod (max-min)\r\n    moduloBetweenDown: function( value, min, max ) {\r\n      assert && assert( max > min, 'max > min required for moduloBetween' );\r\n      \r\n      var divisor = max - min;\r\n      \r\n      // get a partial result of value-min between [0,divisor)\r\n      var partial = ( value - min ) % divisor;\r\n      if ( partial < 0 ) {\r\n        // since if value-min < 0, the remainder will give us a negative number\r\n        partial += divisor;\r\n      }\r\n      \r\n      return partial + min; // add back in the minimum value\r\n    },\r\n    \r\n    // returns a number between (min,max] with the same equivalence class as value mod (max-min)\r\n    moduloBetweenUp: function( value, min, max ) {\r\n      return -Util.moduloBetweenDown( -value, -max, -min );\r\n    },\r\n    \r\n    // Returns an array of integers from A to B (including both A to B)\r\n    rangeInclusive: function( a, b ) {\r\n      if ( b < a ) {\r\n        return [];\r\n      }\r\n      var result = new Array( b - a + 1 );\r\n      for ( var i = a; i <= b; i++ ) {\r\n        result[i-a] = i;\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    // Returns an array of integers between A and B (excluding both A to B)\r\n    rangeExclusive: function( a, b ) {\r\n      return Util.rangeInclusive( a + 1, b - 1 );\r\n    },\r\n    \r\n    toRadians: function( degrees ) {\r\n      return Math.PI * degrees / 180;\r\n    },\r\n    \r\n    toDegrees: function( radians ) {\r\n      return 180 * radians / Math.PI;\r\n    },\r\n    \r\n    // intersection between the line from p1-p2 and the line from p3-p4\r\n    lineLineIntersection: function( p1, p2, p3, p4 ) {\r\n      return new dot.Vector2(\r\n        ( ( p1.x * p2.y - p1.y * p2.x ) * ( p3.x - p4.x ) - ( p1.x - p2.x ) * ( p3.x * p4.y - p3.y * p4.x ) ) / ( ( p1.x - p2.x ) * ( p3.y - p4.y ) - ( p1.y - p2.y ) * ( p3.x - p4.x ) ),\r\n        ( ( p1.x * p2.y - p1.y * p2.x ) * ( p3.y - p4.y ) - ( p1.y - p2.y ) * ( p3.x * p4.y - p3.y * p4.x ) ) / ( ( p1.x - p2.x ) * ( p3.y - p4.y ) - ( p1.y - p2.y ) * ( p3.x - p4.x ) )\r\n      );\r\n    },\r\n    \r\n    // return an array of real roots of ax^2 + bx + c = 0\r\n    solveQuadraticRootsReal: function( a, b, c ) {\r\n      var discriminant = b * b - 4 * a * c;\r\n      if ( discriminant < 0 ) {\r\n        return [];\r\n      }\r\n      var sqrt = Math.sqrt( discriminant );\r\n      // TODO: how to handle if discriminant is 0? give unique root or double it?\r\n      // TODO: probably just use Complex for the future\r\n      return [\r\n        ( -b - sqrt ) / ( 2 * a ),\r\n        ( -b + sqrt ) / ( 2 * a )\r\n      ];\r\n    },\r\n    \r\n    // return an array of real roots of ax^3 + bx^2 + cx + d = 0\r\n    solveCubicRootsReal: function( a, b, c, d ) {\r\n      // TODO: a Complex type!\r\n      \r\n      //We need to test whether a is several orders of magnitude less than b, c, d\r\n      var epsilon = 1E7;\r\n      \r\n      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {\r\n        return Util.solveQuadraticRootsReal( b, c, d );\r\n      }\r\n      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {\r\n        return Util.solveQuadraticRootsReal( a, b, c );\r\n      }\r\n      \r\n      b /= a;\r\n      c /= a;\r\n      d /= a;\r\n      \r\n      var s, t;\r\n      var q = ( 3.0 * c - ( b * b ) ) / 9;\r\n      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;\r\n      var discriminant = q  * q  * q + r  * r;\r\n      var b3 = b / 3;\r\n      \r\n      if ( discriminant > 0 ) {\r\n        // a single real root\r\n        var dsqrt = Math.sqrt( discriminant );\r\n        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];\r\n      }\r\n      \r\n      // three real roots\r\n      if ( discriminant === 0 ) {\r\n        // contains a double root\r\n        var rsqrt = Util.cubeRoot( r );\r\n        var doubleRoot = b3 - rsqrt;\r\n        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];\r\n      } else {\r\n        // all unique\r\n        var qX = -q * q * q;\r\n        qX = Math.acos( r / Math.sqrt( qX ) );\r\n        var rr = 2 * Math.sqrt( -q );\r\n        return [\r\n          -b3 + rr * Math.cos( qX / 3 ),\r\n          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),\r\n          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )\r\n        ];\r\n      }\r\n    },\r\n    \r\n    cubeRoot: function( x ) {\r\n      return x >= 0 ? Math.pow( x, 1/3 ) : -Math.pow( -x, 1/3 );\r\n    },\r\n\r\n    // Linearly interpolate two points and evaluate the line equation for a third point\r\n    // f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>\r\n    linear: function( a1, a2, b1, b2, a3 ) {\r\n      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;\r\n    },\r\n\r\n    /**\r\n     * A predictable implementation of toFixed.\r\n     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,\r\n     * because the spec doesn't specify whether to round or floor.\r\n     */\r\n    toFixed: function( number, decimalPlaces ) {\r\n      var multiplier = Math.pow( 10, decimalPlaces );\r\n      return Math.round( number * multiplier ) / multiplier;\r\n    },\r\n\r\n    isInteger: function( number ) {\r\n      return Math.floor( number ) === number;\r\n    }\r\n  };\r\n  var Util = dot.Util;\r\n  \r\n  // make these available in the main namespace directly (for now)\r\n  dot.testAssert = Util.testAssert;\r\n  dot.clamp = Util.clamp;\r\n  dot.moduloBetweenDown = Util.moduloBetweenDown;\r\n  dot.moduloBetweenUp = Util.moduloBetweenUp;\r\n  dot.rangeInclusive = Util.rangeInclusive;\r\n  dot.rangeExclusive = Util.rangeExclusive;\r\n  dot.toRadians = Util.toRadians;\r\n  dot.toDegrees = Util.toDegrees;\r\n  dot.lineLineIntersection = Util.lineLineIntersection;\r\n  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;\r\n  dot.solveCubicRootsReal = Util.solveCubicRootsReal;\r\n  dot.cubeRoot = Util.cubeRoot;\r\n  dot.linear = Util.linear;\r\n  \r\n  return Util;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 2-dimensional vector\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Vector2',['require','ASSERT/assert','DOT/dot','PHET_CORE/inherit','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  require( 'DOT/Util' );\r\n  // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency\r\n  \r\n  dot.Vector2 = function Vector2( x, y ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    \r\n    assert && assert( typeof this.x === 'number', 'x needs to be a number' );\r\n    assert && assert( typeof this.y === 'number', 'y needs to be a number' );\r\n  };\r\n  var Vector2 = dot.Vector2;\r\n  \r\n  Vector2.createPolar = function( magnitude, angle ) {\r\n    return new Vector2( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );\r\n  };\r\n  \r\n  Vector2.prototype = {\r\n    constructor: Vector2,\r\n    \r\n    isVector2: true,\r\n    \r\n    dimension: 2,\r\n    \r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n    \r\n    magnitudeSquared: function() {\r\n      return this.dot( this );\r\n    },\r\n    \r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n    \r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n    \r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n    \r\n    copy: function() {\r\n      return new this.constructor( this.x, this.y );\r\n    },\r\n    \r\n    // z component of the equivalent 3-dimensional cross product (this.x, this.y,0) x (v.x, v.y, 0)\r\n    crossScalar: function( v ) {\r\n      return this.x * v.y - this.y * v.x;\r\n    },\r\n    \r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new this.constructor( this.x / mag, this.y / mag );\r\n      }\r\n    },\r\n    \r\n    timesScalar: function( scalar ) {\r\n      return new this.constructor( this.x * scalar, this.y * scalar );\r\n    },\r\n    \r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n    \r\n    componentTimes: function( v ) {\r\n      return new this.constructor( this.x * v.x, this.y * v.y );\r\n    },\r\n    \r\n    plus: function( v ) {\r\n      return new this.constructor( this.x + v.x, this.y + v.y );\r\n    },\r\n    \r\n    plusScalar: function( scalar ) {\r\n      return new this.constructor( this.x + scalar, this.y + scalar );\r\n    },\r\n    \r\n    minus: function( v ) {\r\n      return new this.constructor( this.x - v.x, this.y - v.y );\r\n    },\r\n    \r\n    minusScalar: function( scalar ) {\r\n      return new this.constructor( this.x - scalar, this.y - scalar );\r\n    },\r\n    \r\n    dividedScalar: function( scalar ) {\r\n      return new this.constructor( this.x / scalar, this.y / scalar );\r\n    },\r\n    \r\n    negated: function() {\r\n      return new this.constructor( -this.x, -this.y );\r\n    },\r\n    \r\n    angle: function() {\r\n      return Math.atan2( this.y, this.x );\r\n    },\r\n    \r\n    // equivalent to a -PI/2 rotation (right hand rotation)\r\n    perpendicular: function() {\r\n      return new this.constructor( this.y, -this.x );\r\n    },\r\n    \r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n    \r\n    rotated: function( angle ) {\r\n      var newAngle = this.angle() + angle;\r\n      return new this.constructor( Math.cos( newAngle ), Math.sin( newAngle ) ).timesScalar( this.magnitude() );\r\n    },\r\n    \r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n    \r\n    toString: function() {\r\n      return \"Vector2(\" + this.x + \", \" + this.y + \")\";\r\n    },\r\n    \r\n    toVector3: function() {\r\n      return new dot.Vector3( this.x, this.y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n    \r\n    set: function( x, y ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    \r\n    setX: function( x ) {\r\n      this.x = x;\r\n      return this;\r\n    },\r\n    \r\n    setY: function( y ) {\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    \r\n    add: function( v ) {\r\n      this.x += v.x;\r\n      this.y += v.y;\r\n      return this;\r\n    },\r\n    \r\n    addScalar: function( scalar ) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      return this;\r\n    },\r\n    \r\n    subtract: function( v ) {\r\n      this.x -= v.x;\r\n      this.y -= v.y;\r\n      return this;\r\n    },\r\n    \r\n    subtractScalar: function( scalar ) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      return this;\r\n    },\r\n    \r\n    componentMultiply: function( v ) {\r\n      this.x *= v.x;\r\n      this.y *= v.y;\r\n      return this;\r\n    },\r\n    \r\n    divideScalar: function( scalar ) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      return this;\r\n    },\r\n    \r\n    negate: function() {\r\n      this.x = -this.x;\r\n      this.y = -this.y;\r\n      return this;\r\n    }\r\n    \r\n  };\r\n  \r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector2.Immutable = function ImmutableVector2( x, y ) {\r\n    Vector2.call( this, x, y );\r\n  };\r\n  var Immutable = Vector2.Immutable;\r\n  \r\n  inherit( Vector2, Immutable );\r\n  \r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[mutableFunctionName] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector2\" );\r\n    };\r\n  };\r\n  \r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'set' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'copy' );\r\n  Immutable.mutableOverrideHelper( 'add' );\r\n  Immutable.mutableOverrideHelper( 'addScalar' );\r\n  Immutable.mutableOverrideHelper( 'subtract' );\r\n  Immutable.mutableOverrideHelper( 'subtractScalar' );\r\n  Immutable.mutableOverrideHelper( 'componentMultiply' );\r\n  Immutable.mutableOverrideHelper( 'divideScalar' );\r\n  Immutable.mutableOverrideHelper( 'negate' );\r\n  \r\n  // helpful immutable constants\r\n  Vector2.ZERO = new Immutable( 0, 0 );\r\n  Vector2.X_UNIT = new Immutable( 1, 0 );\r\n  Vector2.Y_UNIT = new Immutable( 0, 1 );\r\n  \r\n  return Vector2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A 2D rectangle-shaped bounded area (bounding box)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Bounds2',['require','ASSERT/assert','DOT/dot','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Vector2' );\r\n  \r\n  // not using x,y,width,height so that it can handle infinity-based cases in a better way\r\n  dot.Bounds2 = function Bounds2( minX, minY, maxX, maxY ) {\r\n    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );\r\n    this.minX = minX;\r\n    this.minY = minY;\r\n    this.maxX = maxX;\r\n    this.maxY = maxY;\r\n  };\r\n  var Bounds2 = dot.Bounds2;\r\n\r\n  Bounds2.prototype = {\r\n    constructor: Bounds2,\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Properties\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    getWidth: function() { return this.maxX - this.minX; },\r\n    get width() { return this.getWidth(); },\r\n    \r\n    getHeight: function() { return this.maxY - this.minY; },\r\n    get height() { return this.getHeight(); },\r\n    \r\n    getX: function() { return this.minX; },\r\n    get x() { return this.getX(); },\r\n    \r\n    getY: function() { return this.minY; },\r\n    get y() { return this.getY(); },\r\n    \r\n    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },\r\n    get center() { return this.getCenter(); },\r\n    \r\n    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },\r\n    get centerX() { return this.getCenterX(); },\r\n    \r\n    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },\r\n    get centerY() { return this.getCenterY(); },\r\n    \r\n    getMinX: function() { return this.minX; },\r\n    getMinY: function() { return this.minY; },\r\n    getMaxX: function() { return this.maxX; },\r\n    getMaxY: function() { return this.maxY; },\r\n    \r\n    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );\r\n    },\r\n    \r\n    isValid: function() {\r\n      return !this.isEmpty() && this.isFinite();\r\n    },\r\n    \r\n    // whether the coordinates are inside the bounding box (or on the boundary)\r\n    containsCoordinates: function( x, y ) {\r\n      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\r\n    },\r\n    \r\n    // whether the point is inside the bounding box (or on the boundary)\r\n    containsPoint: function( point ) {\r\n      return this.containsCoordinates( point.x, point.y );\r\n    },\r\n    \r\n    // whether this bounding box completely contains the argument bounding box\r\n    containsBounds: function( bounds ) {\r\n      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;\r\n    },\r\n    \r\n    // whether the intersection is non-empty (if they share any part of a boundary, this will be true)\r\n    intersectsBounds: function( bounds ) {\r\n      // TODO: more efficient way of doing this?\r\n      return !this.intersection( bounds ).isEmpty();\r\n    },\r\n    \r\n    toString: function() {\r\n      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      epsilon = epsilon || 0;\r\n      var thisFinite = this.isFinite();\r\n      var otherFinite = other.isFinite();\r\n      if ( thisFinite && otherFinite ) {\r\n        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity\r\n        return Math.abs( this.minX - other.minX ) < epsilon &&\r\n               Math.abs( this.minY - other.minY ) < epsilon &&\r\n               Math.abs( this.maxX - other.maxX ) < epsilon &&\r\n               Math.abs( this.maxY - other.maxY ) < epsilon;\r\n      } else if ( thisFinite !== otherFinite ) {\r\n        return false; // one is finite, the other is not. definitely not equal\r\n      } else if ( this === other ) {\r\n        return true; // exact same instance, must be equal\r\n      } else {\r\n        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both\r\n        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&\r\n               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&\r\n               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&\r\n               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );\r\n      }\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Immutable operations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    copy: function() {\r\n      return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );\r\n    },\r\n    \r\n    // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)\r\n    union: function( bounds ) {\r\n      return new Bounds2(\r\n        Math.min( this.minX, bounds.minX ),\r\n        Math.min( this.minY, bounds.minY ),\r\n        Math.max( this.maxX, bounds.maxX ),\r\n        Math.max( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n    intersection: function( bounds ) {\r\n      return new Bounds2(\r\n        Math.max( this.minX, bounds.minX ),\r\n        Math.max( this.minY, bounds.minY ),\r\n        Math.min( this.maxX, bounds.maxX ),\r\n        Math.min( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n    // TODO: difference should be well-defined, but more logic is needed to compute\r\n    \r\n    withCoordinates: function( x, y ) {\r\n      return new Bounds2(\r\n        Math.min( this.minX, x ),\r\n        Math.min( this.minY, y ),\r\n        Math.max( this.maxX, x ),\r\n        Math.max( this.maxY, y )\r\n      );\r\n    },\r\n    \r\n    // like a union with a point-sized bounding box\r\n    withPoint: function( point ) {\r\n      return this.withCoordinates( point.x, point.y );\r\n    },\r\n    \r\n    withMinX: function( minX ) { return new Bounds2( minX, this.minY, this.maxX, this.maxY ); },\r\n    withMinY: function( minY ) { return new Bounds2( this.minX, minY, this.maxX, this.maxY ); },\r\n    withMaxX: function( maxX ) { return new Bounds2( this.minX, this.minY, maxX, this.maxY ); },\r\n    withMaxY: function( maxY ) { return new Bounds2( this.minX, this.minY, this.maxX, maxY ); },\r\n    \r\n    // copy rounded to integral values, expanding where necessary\r\n    roundedOut: function() {\r\n      return new Bounds2(\r\n        Math.floor( this.minX ),\r\n        Math.floor( this.minY ),\r\n        Math.ceil( this.maxX ),\r\n        Math.ceil( this.maxY )\r\n      );\r\n    },\r\n    \r\n    // copy rounded to integral values, contracting where necessary\r\n    roundedIn: function() {\r\n      return new Bounds2(\r\n        Math.ceil( this.minX ),\r\n        Math.ceil( this.minY ),\r\n        Math.floor( this.maxX ),\r\n        Math.floor( this.maxY )\r\n      );\r\n    },\r\n    \r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transformed: function( matrix ) {\r\n      return this.copy().transform( matrix );\r\n    },\r\n    \r\n    // returns copy expanded on all sides by length d\r\n    dilated: function( d ) {\r\n      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );\r\n    },\r\n    \r\n    // returns copy contracted on all sides by length d\r\n    eroded: function( d ) {\r\n      return this.dilated( -d );\r\n    },\r\n    \r\n    shiftedX: function( x ) {\r\n      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );\r\n    },\r\n    \r\n    shiftedY: function( y ) {\r\n      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );\r\n    },\r\n    \r\n    shifted: function( x, y ) {\r\n      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Mutable operations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    set: function( minX, minY, maxX, maxY ) {\r\n      this.minX = minX;\r\n      this.minY = minY;\r\n      this.maxX = maxX;\r\n      this.maxY = maxY;\r\n      return this;\r\n    },\r\n    \r\n    setBounds: function( bounds ) {\r\n      return this.set( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );\r\n    },\r\n    \r\n    // mutable union\r\n    includeBounds: function( bounds ) {\r\n      this.minX = Math.min( this.minX, bounds.minX );\r\n      this.minY = Math.min( this.minY, bounds.minY );\r\n      this.maxX = Math.max( this.maxX, bounds.maxX );\r\n      this.maxY = Math.max( this.maxY, bounds.maxY );\r\n      return this;\r\n    },\r\n    \r\n    // mutable intersection\r\n    constrainBounds: function( bounds ) {\r\n      this.minX = Math.max( this.minX, bounds.minX );\r\n      this.minY = Math.max( this.minY, bounds.minY );\r\n      this.maxX = Math.min( this.maxX, bounds.maxX );\r\n      this.maxY = Math.min( this.maxY, bounds.maxY );\r\n      return this;\r\n    },\r\n    \r\n    addCoordinates: function( x, y ) {\r\n      this.minX = Math.min( this.minX, x );\r\n      this.minY = Math.min( this.minY, y );\r\n      this.maxX = Math.max( this.maxX, x );\r\n      this.maxY = Math.max( this.maxY, y );\r\n      return this;\r\n    },\r\n    \r\n    addPoint: function( point ) {\r\n      return this.addCoordinates( point.x, point.y );\r\n    },\r\n    \r\n    setMinX: function( minX ) { this.minX = minX; return this; },\r\n    setMinY: function( minY ) { this.minY = minY; return this; },\r\n    setMaxX: function( maxX ) { this.maxX = maxX; return this; },\r\n    setMaxY: function( maxY ) { this.maxY = maxY; return this; },\r\n    \r\n    // round to integral values, expanding where necessary\r\n    roundOut: function() {\r\n      this.minX = Math.floor( this.minX );\r\n      this.minY = Math.floor( this.minY );\r\n      this.maxX = Math.ceil( this.maxX );\r\n      this.maxY = Math.ceil( this.maxY );\r\n      return this;\r\n    },\r\n    \r\n    // round to integral values, contracting where necessary\r\n    roundIn: function() {\r\n      this.minX = Math.ceil( this.minX );\r\n      this.minY = Math.ceil( this.minY );\r\n      this.maxX = Math.floor( this.maxX );\r\n      this.maxY = Math.floor( this.maxY );\r\n      return this;\r\n    },\r\n    \r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transform: function( matrix ) {\r\n      // do nothing\r\n      if ( this.isEmpty() ) {\r\n        return this;\r\n      }\r\n      var minX = this.minX;\r\n      var minY = this.minY;\r\n      var maxX = this.maxX;\r\n      var maxY = this.maxY;\r\n      \r\n      // using mutable vector so we don't create excessive instances of Vector2 during this\r\n      // make sure all 4 corners are inside this transformed bounding box\r\n      var vector = new dot.Vector2();\r\n      this.setBounds( Bounds2.NOTHING );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( minX, minY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( minX, maxY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( maxX, minY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( maxX, maxY ) ) );\r\n      return this;\r\n    },\r\n    \r\n    // expands on all sides by length d\r\n    dilate: function( d ) {\r\n      return this.set( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );\r\n    },\r\n    \r\n    // contracts on all sides by length d\r\n    erode: function( d ) {\r\n      return this.dilate( -d );\r\n    },\r\n    \r\n    shiftX: function( x ) {\r\n      return this.setMinX( this.minX + x ).setMaxX( this.maxX + x );\r\n    },\r\n    \r\n    shiftY: function( y ) {\r\n      return this.setMinY( this.minY + y ).setMaxY( this.maxY + y );\r\n    },\r\n    \r\n    shift: function( x, y ) {\r\n      return this.shiftX( x ).shiftY( y );\r\n    }\r\n  };\r\n  \r\n  Bounds2.rect = function( x, y, width, height ) {\r\n    return new Bounds2( x, y, x + width, y + height );\r\n  };\r\n  \r\n  // specific bounds useful for operations\r\n  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );\r\n  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );\r\n  \r\n  return Bounds2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 2-dimensional ray\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Ray2',['require','ASSERT/assert','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n\r\n  dot.Ray2 = function Ray2( pos, dir ) {\r\n    this.pos = pos;\r\n    this.dir = dir;\r\n    \r\n    assert && assert( Math.abs( dir.magnitude() - 1 ) < 0.01 );\r\n  };\r\n  var Ray2 = dot.Ray2;\r\n\r\n  Ray2.prototype = {\r\n    constructor: Ray2,\r\n\r\n    shifted: function( distance ) {\r\n      return new Ray2( this.pointAtDistance( distance ), this.dir );\r\n    },\r\n\r\n    pointAtDistance: function( distance ) {\r\n      return this.pos.plus( this.dir.timesScalar( distance ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return this.pos.toString() + \" => \" + this.dir.toString();\r\n    }\r\n  };\r\n  \r\n  return Ray2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 4-dimensional vector\r\n *\r\n * TODO: sync with Vector2 changes\r\n * TODO: add quaternion extension\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Vector4',['require','ASSERT/assert','DOT/dot','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Util' );\r\n  // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency\r\n  \r\n  dot.Vector4 = function Vector4( x, y, z, w ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = w !== undefined ? w : 1; // since w could be zero!\r\n  };\r\n  var Vector4 = dot.Vector4;\r\n  \r\n  Vector4.prototype = {\r\n    constructor: Vector4,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      this.dot( this );\r\n    },\r\n    \r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n    \r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector4( this.x / mag, this.y / mag, this.z / mag, this.w / mag );\r\n      }\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector4( -this.x, -this.y, -this.z, -this.w );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n    \r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Vector4(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\r\n    },\r\n\r\n    toVector3: function() {\r\n      return new dot.Vector3( this.x, this.y, this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    set: function( x, y, z, w ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n      this.w = w;\r\n    },\r\n\r\n    setX: function( x ) {\r\n      this.x = x;\r\n    },\r\n\r\n    setY: function( y ) {\r\n      this.y = y;\r\n    },\r\n\r\n    setZ: function( z ) {\r\n      this.z = z;\r\n    },\r\n\r\n    setW: function( w ) {\r\n      this.w = w;\r\n    },\r\n\r\n    copy: function( v ) {\r\n      this.x = v.x;\r\n      this.y = v.y;\r\n      this.z = v.z;\r\n      this.w = v.w;\r\n    },\r\n\r\n    add: function( v ) {\r\n      this.x += v.x;\r\n      this.y += v.y;\r\n      this.z += v.z;\r\n      this.w += v.w;\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      this.z += scalar;\r\n      this.w += scalar;\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      this.x -= v.x;\r\n      this.y -= v.y;\r\n      this.z -= v.z;\r\n      this.w -= v.w;\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      this.z -= scalar;\r\n      this.w -= scalar;\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      this.x *= v.x;\r\n      this.y *= v.y;\r\n      this.z *= v.z;\r\n      this.w *= v.w;\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      this.z /= scalar;\r\n      this.w /= scalar;\r\n    },\r\n\r\n    negate: function() {\r\n      this.x = -this.x;\r\n      this.y = -this.y;\r\n      this.z = -this.z;\r\n      this.w = -this.w;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;\r\n    },\r\n\r\n    isVector4: true,\r\n\r\n    dimension: 4\r\n\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector4.Immutable = function( x, y, z, w ) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = w !== undefined ? w : 1;\r\n  };\r\n  var Immutable = Vector4.Immutable;\r\n\r\n  Immutable.prototype = new Vector4();\r\n  Immutable.prototype.constructor = Immutable;\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[mutableFunctionName] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector4\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'set' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'setZ' );\r\n  Immutable.mutableOverrideHelper( 'setW' );\r\n  Immutable.mutableOverrideHelper( 'copy' );\r\n  Immutable.mutableOverrideHelper( 'add' );\r\n  Immutable.mutableOverrideHelper( 'addScalar' );\r\n  Immutable.mutableOverrideHelper( 'subtract' );\r\n  Immutable.mutableOverrideHelper( 'subtractScalar' );\r\n  Immutable.mutableOverrideHelper( 'componentMultiply' );\r\n  Immutable.mutableOverrideHelper( 'divideScalar' );\r\n  Immutable.mutableOverrideHelper( 'negate' );\r\n\r\n  // helpful immutable constants\r\n  Vector4.ZERO = new Immutable( 0, 0, 0, 0 );\r\n  Vector4.X_UNIT = new Immutable( 1, 0, 0, 0 );\r\n  Vector4.Y_UNIT = new Immutable( 0, 1, 0, 0 );\r\n  Vector4.Z_UNIT = new Immutable( 0, 0, 1, 0 );\r\n  Vector4.W_UNIT = new Immutable( 0, 0, 0, 1 );\r\n  \r\n  return Vector4;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 3-dimensional vector\r\n *\r\n * TODO: sync with Vector2 changes\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Vector3',['require','ASSERT/assert','DOT/dot','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Util' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector4' );\r\n\r\n  dot.Vector3 = function Vector3( x, y, z ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n  };\r\n  var Vector3 = dot.Vector3;\r\n\r\n  Vector3.prototype = {\r\n    constructor: Vector3,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      return this.dot( this );\r\n    },\r\n    \r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n    \r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    cross: function( v ) {\r\n      return new Vector3(\r\n          this.y * v.z - this.z * v.y,\r\n          this.z * v.x - this.x * v.z,\r\n          this.x * v.y - this.y * v.x\r\n      );\r\n    },\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector3( this.x / mag, this.y / mag, this.z / mag );\r\n      }\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector3( -this.x, -this.y, -this.z );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n    \r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Vector3(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\r\n    },\r\n\r\n    toVector2: function() {\r\n      return new dot.Vector2( this.x, this.y );\r\n    },\r\n\r\n    toVector4: function() {\r\n      return new dot.Vector4( this.x, this.y, this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    set: function( x, y, z ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n    },\r\n\r\n    setX: function( x ) {\r\n      this.x = x;\r\n    },\r\n\r\n    setY: function( y ) {\r\n      this.y = y;\r\n    },\r\n\r\n    setZ: function( z ) {\r\n      this.z = z;\r\n    },\r\n\r\n    copy: function( v ) {\r\n      this.x = v.x;\r\n      this.y = v.y;\r\n      this.z = v.z;\r\n    },\r\n\r\n    add: function( v ) {\r\n      this.x += v.x;\r\n      this.y += v.y;\r\n      this.z += v.z;\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      this.z += scalar;\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      this.x -= v.x;\r\n      this.y -= v.y;\r\n      this.z -= v.z;\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      this.z -= scalar;\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      this.x *= v.x;\r\n      this.y *= v.y;\r\n      this.z *= v.z;\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      this.z /= scalar;\r\n    },\r\n\r\n    negate: function() {\r\n      this.x = -this.x;\r\n      this.y = -this.y;\r\n      this.z = -this.z;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y && this.z === other.z;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;\r\n    },\r\n\r\n    isVector3: true,\r\n\r\n    dimension: 3\r\n\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector3.Immutable = function( x, y, z ) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n  };\r\n  var Immutable = Vector3.Immutable;\r\n\r\n  Immutable.prototype = new Vector3();\r\n  Immutable.prototype.constructor = Immutable;\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[mutableFunctionName] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector3\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'set' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'setZ' );\r\n  Immutable.mutableOverrideHelper( 'copy' );\r\n  Immutable.mutableOverrideHelper( 'add' );\r\n  Immutable.mutableOverrideHelper( 'addScalar' );\r\n  Immutable.mutableOverrideHelper( 'subtract' );\r\n  Immutable.mutableOverrideHelper( 'subtractScalar' );\r\n  Immutable.mutableOverrideHelper( 'componentMultiply' );\r\n  Immutable.mutableOverrideHelper( 'divideScalar' );\r\n  Immutable.mutableOverrideHelper( 'negate' );\r\n\r\n  // helpful immutable constants\r\n  Vector3.ZERO = new Immutable( 0, 0, 0 );\r\n  Vector3.X_UNIT = new Immutable( 1, 0, 0 );\r\n  Vector3.Y_UNIT = new Immutable( 0, 1, 0 );\r\n  Vector3.Z_UNIT = new Immutable( 0, 0, 1 );\r\n  \r\n  return Vector3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 4-dimensional Matrix\r\n *\r\n * TODO: consider adding affine flag if it will help performance (a la Matrix3)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Vector4' );\r\n  \r\n  var Float32Array = window.Float32Array || Array;\r\n  \r\n  dot.Matrix4 = function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {\r\n\r\n    // entries stored in column-major format\r\n    this.entries = new Float32Array( 16 );\r\n\r\n    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0, v03 || 0,\r\n             v10 || 0, v11 === undefined ? 1 : v11, v12 || 0, v13 || 0,\r\n             v20 || 0, v21 || 0, v22 === undefined ? 1 : v22, v23 || 0,\r\n             v30 || 0, v31 || 0, v32 || 0, v33 === undefined ? 1 : v33,\r\n             type );\r\n  };\r\n  var Matrix4 = dot.Matrix4;\r\n\r\n  Matrix4.Types = {\r\n    OTHER: 0, // default\r\n    IDENTITY: 1,\r\n    TRANSLATION_3D: 2,\r\n    SCALING: 3\r\n\r\n    // TODO: possibly add rotations\r\n  };\r\n\r\n  var Types = Matrix4.Types;\r\n\r\n  Matrix4.identity = function() {\r\n    return new Matrix4( 1, 0, 0, 0,\r\n              0, 1, 0, 0,\r\n              0, 0, 1, 0,\r\n              0, 0, 0, 1,\r\n              Types.IDENTITY );\r\n  };\r\n\r\n  Matrix4.translation = function( x, y, z ) {\r\n    return new Matrix4( 1, 0, 0, x,\r\n              0, 1, 0, y,\r\n              0, 0, 1, z,\r\n              0, 0, 0, 1,\r\n              Types.TRANSLATION_3D );\r\n  };\r\n\r\n  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };\r\n\r\n  Matrix4.scaling = function( x, y, z ) {\r\n    // allow using one parameter to scale everything\r\n    y = y === undefined ? x : y;\r\n    z = z === undefined ? x : z;\r\n\r\n    return new Matrix4( x, 0, 0, 0,\r\n              0, y, 0, 0,\r\n              0, 0, z, 0,\r\n              0, 0, 0, 1,\r\n              Types.SCALING );\r\n  };\r\n\r\n  // axis is a normalized Vector3, angle in radians.\r\n  Matrix4.rotationAxisAngle = function( axis, angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n    var C = 1 - c;\r\n\r\n    return new Matrix4( axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,\r\n              axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,\r\n              axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  // TODO: add in rotation from quaternion, and from quat + translation\r\n\r\n  Matrix4.rotationX = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4( 1, 0, 0, 0,\r\n              0, c, -s, 0,\r\n              0, s, c, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  Matrix4.rotationY = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4( c, 0, s, 0,\r\n              0, 1, 0, 0,\r\n              -s, 0, c, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  Matrix4.rotationZ = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4( c, -s, 0, 0,\r\n              s, c, 0, 0,\r\n              0, 0, 1, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  // aspect === width / height\r\n  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {\r\n    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );\r\n\r\n    return new Matrix4( cotangent / aspect, 0, 0, 0,\r\n              0, cotangent, 0, 0,\r\n              0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),\r\n              0, 0, -1, 0 );\r\n  };\r\n\r\n  Matrix4.prototype = {\r\n    constructor: Matrix4,\r\n\r\n    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {\r\n      this.entries[0] = v00;\r\n      this.entries[1] = v10;\r\n      this.entries[2] = v20;\r\n      this.entries[3] = v30;\r\n      this.entries[4] = v01;\r\n      this.entries[5] = v11;\r\n      this.entries[6] = v21;\r\n      this.entries[7] = v31;\r\n      this.entries[8] = v02;\r\n      this.entries[9] = v12;\r\n      this.entries[10] = v22;\r\n      this.entries[11] = v32;\r\n      this.entries[12] = v03;\r\n      this.entries[13] = v13;\r\n      this.entries[14] = v23;\r\n      this.entries[15] = v33;\r\n      this.type = type === undefined ? Types.OTHER : type;\r\n    },\r\n\r\n    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {\r\n      this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );\r\n    },\r\n\r\n    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler\r\n    m00: function() { return this.entries[0]; },\r\n    m01: function() { return this.entries[4]; },\r\n    m02: function() { return this.entries[8]; },\r\n    m03: function() { return this.entries[12]; },\r\n    m10: function() { return this.entries[1]; },\r\n    m11: function() { return this.entries[5]; },\r\n    m12: function() { return this.entries[9]; },\r\n    m13: function() { return this.entries[13]; },\r\n    m20: function() { return this.entries[2]; },\r\n    m21: function() { return this.entries[6]; },\r\n    m22: function() { return this.entries[10]; },\r\n    m23: function() { return this.entries[14]; },\r\n    m30: function() { return this.entries[3]; },\r\n    m31: function() { return this.entries[7]; },\r\n    m32: function() { return this.entries[11]; },\r\n    m33: function() { return this.entries[15]; },\r\n\r\n    plus: function( m ) {\r\n      return new Matrix4(\r\n          this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),\r\n          this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),\r\n          this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),\r\n          this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()\r\n      );\r\n    },\r\n\r\n    minus: function( m ) {\r\n      return new Matrix4(\r\n          this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),\r\n          this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),\r\n          this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),\r\n          this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()\r\n      );\r\n    },\r\n\r\n    transposed: function() {\r\n      return new Matrix4( this.m00(), this.m10(), this.m20(), this.m30(),\r\n                this.m01(), this.m11(), this.m21(), this.m31(),\r\n                this.m02(), this.m12(), this.m22(), this.m32(),\r\n                this.m03(), this.m13(), this.m23(), this.m33() );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Matrix4( -this.m00(), -this.m01(), -this.m02(), -this.m03(),\r\n                -this.m10(), -this.m11(), -this.m12(), -this.m13(),\r\n                -this.m20(), -this.m21(), -this.m22(), -this.m23(),\r\n                -this.m30(), -this.m31(), -this.m32(), -this.m33() );\r\n    },\r\n\r\n    inverted: function() {\r\n      // TODO: optimizations for matrix types (like identity)\r\n\r\n      var det = this.determinant();\r\n\r\n      if ( det !== 0 ) {\r\n        return new Matrix4(\r\n            ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,\r\n            ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,\r\n            ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,\r\n            ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,\r\n            ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,\r\n            ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,\r\n            ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,\r\n            ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,\r\n            ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,\r\n            ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,\r\n            ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,\r\n            ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,\r\n            ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,\r\n            ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,\r\n            ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,\r\n            ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det\r\n        );\r\n      }\r\n      else {\r\n        throw new Error( \"Matrix could not be inverted, determinant === 0\" );\r\n      }\r\n    },\r\n\r\n    timesMatrix: function( m ) {\r\n      var newType = Types.OTHER;\r\n      if ( this.type === Types.TRANSLATION_3D && m.type === Types.TRANSLATION_3D ) {\r\n        newType = Types.TRANSLATION_3D;\r\n      }\r\n      if ( this.type === Types.SCALING && m.type === Types.SCALING ) {\r\n        newType = Types.SCALING;\r\n      }\r\n      if ( this.type === Types.IDENTITY ) {\r\n        newType = m.type;\r\n      }\r\n      if ( m.type === Types.IDENTITY ) {\r\n        newType = this.type;\r\n      }\r\n      return new Matrix4( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),\r\n                this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),\r\n                this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),\r\n                this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),\r\n                this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),\r\n                this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),\r\n                this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),\r\n                this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),\r\n                this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),\r\n                this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),\r\n                this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),\r\n                this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),\r\n                this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),\r\n                this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),\r\n                this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),\r\n                this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33(),\r\n                newType );\r\n    },\r\n\r\n    timesVector4: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;\r\n      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;\r\n      return new dot.Vector4( x, y, z, w );\r\n    },\r\n\r\n    timesVector3: function( v ) {\r\n      return this.timesVector4( v.toVector4() ).toVector3();\r\n    },\r\n\r\n    timesTransposeVector4: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;\r\n      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;\r\n      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;\r\n      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;\r\n      return new dot.Vector4( x, y, z, w );\r\n    },\r\n\r\n    timesTransposeVector3: function( v ) {\r\n      return this.timesTransposeVector4( v.toVector4() ).toVector3();\r\n    },\r\n\r\n    timesRelativeVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;\r\n      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;\r\n      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;\r\n      return new dot.Vector3( x, y, z );\r\n    },\r\n\r\n    determinant: function() {\r\n      return this.m03() * this.m12() * this.m21() * this.m30() -\r\n          this.m02() * this.m13() * this.m21() * this.m30() -\r\n          this.m03() * this.m11() * this.m22() * this.m30() +\r\n          this.m01() * this.m13() * this.m22() * this.m30() +\r\n          this.m02() * this.m11() * this.m23() * this.m30() -\r\n          this.m01() * this.m12() * this.m23() * this.m30() -\r\n          this.m03() * this.m12() * this.m20() * this.m31() +\r\n          this.m02() * this.m13() * this.m20() * this.m31() +\r\n          this.m03() * this.m10() * this.m22() * this.m31() -\r\n          this.m00() * this.m13() * this.m22() * this.m31() -\r\n          this.m02() * this.m10() * this.m23() * this.m31() +\r\n          this.m00() * this.m12() * this.m23() * this.m31() +\r\n          this.m03() * this.m11() * this.m20() * this.m32() -\r\n          this.m01() * this.m13() * this.m20() * this.m32() -\r\n          this.m03() * this.m10() * this.m21() * this.m32() +\r\n          this.m00() * this.m13() * this.m21() * this.m32() +\r\n          this.m01() * this.m10() * this.m23() * this.m32() -\r\n          this.m00() * this.m11() * this.m23() * this.m32() -\r\n          this.m02() * this.m11() * this.m20() * this.m33() +\r\n          this.m01() * this.m12() * this.m20() * this.m33() +\r\n          this.m02() * this.m10() * this.m21() * this.m33() -\r\n          this.m00() * this.m12() * this.m21() * this.m33() -\r\n          this.m01() * this.m10() * this.m22() * this.m33() +\r\n          this.m00() * this.m11() * this.m22() * this.m33();\r\n    },\r\n\r\n    toString: function() {\r\n      return this.m00() + \" \" + this.m01() + \" \" + this.m02() + \" \" + this.m03() + \"\\n\" +\r\n           this.m10() + \" \" + this.m11() + \" \" + this.m12() + \" \" + this.m13() + \"\\n\" +\r\n           this.m20() + \" \" + this.m21() + \" \" + this.m22() + \" \" + this.m23() + \"\\n\" +\r\n           this.m30() + \" \" + this.m31() + \" \" + this.m32() + \" \" + this.m33();\r\n    },\r\n\r\n    translation: function() { return new dot.Vector3( this.m03(), this.m13(), this.m23() ); },\r\n    scaling: function() { return new dot.Vector3( this.m00(), this.m11(), this.m22() );},\r\n\r\n    makeImmutable: function() {\r\n      this.rowMajor = function() {\r\n        throw new Error( \"Cannot modify immutable matrix\" );\r\n      };\r\n    }\r\n  };\r\n\r\n  // create an immutable\r\n  Matrix4.IDENTITY = new Matrix4();\r\n  Matrix4.IDENTITY.makeImmutable();\r\n  \r\n  return Matrix4;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 3-dimensional Matrix\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Matrix3',['require','DOT/dot','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var FastArray = dot.FastArray;\r\n  \r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Matrix4' );\r\n  \r\n  dot.Matrix3 = function Matrix3( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n\r\n    // entries stored in column-major format\r\n    this.entries = new FastArray( 9 ); // TODO: consider a typed array if possible (double even?) for performance and compatibility with WebGL\r\n\r\n    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0,\r\n                   v10 || 0, v11 === undefined ? 1 : v11, v12 || 0,\r\n                   v20 || 0, v21 || 0, v22 === undefined ? 1 : v22,\r\n                   type );\r\n  };\r\n  var Matrix3 = dot.Matrix3;\r\n\r\n  Matrix3.Types = {\r\n    // NOTE: if an inverted matrix of a type is not that type, change inverted()!\r\n    // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!\r\n    // NOTE: on adding a type, exaustively check all type usage\r\n    OTHER: 0, // default\r\n    IDENTITY: 1,\r\n    TRANSLATION_2D: 2,\r\n    SCALING: 3,\r\n    AFFINE: 4\r\n\r\n    // TODO: possibly add rotations\r\n  };\r\n\r\n  var Types = Matrix3.Types;\r\n\r\n  Matrix3.identity = function() {\r\n    return new Matrix3( 1, 0, 0,\r\n                        0, 1, 0,\r\n                        0, 0, 1,\r\n                        Types.IDENTITY );\r\n  };\r\n\r\n  Matrix3.translation = function( x, y ) {\r\n    return new Matrix3( 1, 0, x,\r\n                        0, 1, y,\r\n                        0, 0, 1,\r\n                        Types.TRANSLATION_2D );\r\n  };\r\n\r\n  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };\r\n\r\n  Matrix3.scaling = function( x, y ) {\r\n    // allow using one parameter to scale everything\r\n    y = y === undefined ? x : y;\r\n\r\n    return new Matrix3( x, 0, 0,\r\n                        0, y, 0,\r\n                        0, 0, 1,\r\n                        Types.SCALING );\r\n  };\r\n  Matrix3.scale = Matrix3.scaling;\r\n  \r\n  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) {\r\n    return new Matrix3( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );\r\n  };\r\n\r\n  // axis is a normalized Vector3, angle in radians.\r\n  Matrix3.rotationAxisAngle = function( axis, angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n    var C = 1 - c;\r\n\r\n    return new Matrix3( axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,\r\n                        axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,\r\n                        axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,\r\n                        Types.OTHER );\r\n  };\r\n\r\n  // TODO: add in rotation from quaternion, and from quat + translation\r\n\r\n  Matrix3.rotationX = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix3( 1, 0, 0,\r\n                        0, c, -s,\r\n                        0, s, c,\r\n                        Types.OTHER );\r\n  };\r\n\r\n  Matrix3.rotationY = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix3( c, 0, s,\r\n                        0, 1, 0,\r\n                        -s, 0, c,\r\n                        Types.OTHER );\r\n  };\r\n\r\n  Matrix3.rotationZ = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix3( c, -s, 0,\r\n                        s, c, 0,\r\n                        0, 0, 1,\r\n                        Types.AFFINE );\r\n  };\r\n  \r\n  // standard 2d rotation\r\n  Matrix3.rotation2 = Matrix3.rotationZ;\r\n  \r\n  Matrix3.fromSVGMatrix = function( svgMatrix ) {\r\n    return new Matrix3( svgMatrix.a, svgMatrix.c, svgMatrix.e,\r\n                        svgMatrix.b, svgMatrix.d, svgMatrix.f,\r\n                        0, 0, 1,\r\n                        Types.AFFINE );\r\n  };\r\n\r\n  // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors\r\n  Matrix3.rotateAToB = function( a, b ) {\r\n    // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation\r\n    var start = a;\r\n    var end = b;\r\n\r\n    var epsilon = 0.0001;\r\n\r\n    var e, h, f;\r\n\r\n    var v = start.cross( end );\r\n    e = start.dot( end );\r\n    f = ( e < 0 ) ? -e : e;\r\n\r\n    // if \"from\" and \"to\" vectors are nearly parallel\r\n    if ( f > 1.0 - epsilon ) {\r\n      var c1, c2, c3;\r\n      /* coefficients for later use */\r\n      var i, j;\r\n\r\n      var x = new dot.Vector3(\r\n        ( start.x > 0.0 ) ? start.x : -start.x,\r\n        ( start.y > 0.0 ) ? start.y : -start.y,\r\n        ( start.z > 0.0 ) ? start.z : -start.z\r\n      );\r\n\r\n      if ( x.x < x.y ) {\r\n        if ( x.x < x.z ) {\r\n          x = dot.Vector3.X_UNIT;\r\n        }\r\n        else {\r\n          x = dot.Vector3.Z_UNIT;\r\n        }\r\n      }\r\n      else {\r\n        if ( x.y < x.z ) {\r\n          x = dot.Vector3.Y_UNIT;\r\n        }\r\n        else {\r\n          x = dot.Vector3.Z_UNIT;\r\n        }\r\n      }\r\n\r\n      var u = x.minus( start );\r\n      v = x.minus( end );\r\n\r\n      c1 = 2.0 / u.dot( u );\r\n      c2 = 2.0 / v.dot( v );\r\n      c3 = c1 * c2 * u.dot( v );\r\n\r\n      return Matrix3.IDENTITY.plus( Matrix3.rowMajor(\r\n        -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x,\r\n        -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,\r\n        -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,\r\n        -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,\r\n        -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y,\r\n        -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,\r\n        -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,\r\n        -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,\r\n        -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z\r\n      ) );\r\n    }\r\n    else {\r\n      // the most common case, unless \"start\"=\"end\", or \"start\"=-\"end\"\r\n      var hvx, hvz, hvxy, hvxz, hvyz;\r\n      h = 1.0 / ( 1.0 + e );\r\n      hvx = h * v.x;\r\n      hvz = h * v.z;\r\n      hvxy = hvx * v.y;\r\n      hvxz = hvx * v.z;\r\n      hvyz = hvz * v.y;\r\n\r\n      return Matrix3.rowMajor(\r\n        e + hvx * v.x, hvxy - v.z, hvxz + v.y,\r\n        hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,\r\n        hvxz - v.y, hvyz + v.x, e + hvz * v.z\r\n      );\r\n    }\r\n  };\r\n\r\n  Matrix3.prototype = {\r\n    constructor: Matrix3,\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * \"Properties\"\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler\r\n    m00: function() { return this.entries[0]; },\r\n    m01: function() { return this.entries[3]; },\r\n    m02: function() { return this.entries[6]; },\r\n    m10: function() { return this.entries[1]; },\r\n    m11: function() { return this.entries[4]; },\r\n    m12: function() { return this.entries[7]; },\r\n    m20: function() { return this.entries[2]; },\r\n    m21: function() { return this.entries[5]; },\r\n    m22: function() { return this.entries[8]; },\r\n    \r\n    isAffine: function() {\r\n      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.m00() ) &&\r\n             isFinite( this.m01() ) &&\r\n             isFinite( this.m02() ) &&\r\n             isFinite( this.m10() ) &&\r\n             isFinite( this.m11() ) &&\r\n             isFinite( this.m12() ) &&\r\n             isFinite( this.m20() ) &&\r\n             isFinite( this.m21() ) &&\r\n             isFinite( this.m22() );\r\n    },\r\n    \r\n    getDeterminant: function() {\r\n      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();\r\n    },\r\n    get determinant() { return this.getDeterminant(); },\r\n    \r\n    getTranslation: function() {\r\n      return new dot.Vector2( this.m02(), this.m12() );\r\n    },\r\n    get translation() { return this.getTranslation(); },\r\n    \r\n    // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform\r\n    getScaleVector: function() {\r\n      return new dot.Vector2( Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),\r\n                              Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );\r\n    },\r\n    get scaleVector() { return this.getScaleVector(); },\r\n    \r\n    // angle in radians for the 2d rotation from this matrix, between pi, -pi\r\n    getRotation: function() {\r\n      var transformedVector = this.timesVector2( dot.Vector2.X_UNIT ).minus( this.timesVector2( dot.Vector2.ZERO ) );\r\n      return Math.atan2( transformedVector.y, transformedVector.x );\r\n    },\r\n    get rotation() { return this.getRotation(); },\r\n    \r\n    toMatrix4: function() {\r\n      return new dot.Matrix4( this.m00(), this.m01(), this.m02(), 0,\r\n                              this.m10(), this.m11(), this.m12(), 0,\r\n                              this.m20(), this.m21(), this.m22(), 0,\r\n                              0, 0, 0, 1 );\r\n    },\r\n    \r\n    toString: function() {\r\n      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\\n' +\r\n             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\\n' +\r\n             this.m20() + ' ' + this.m21() + ' ' + this.m22();\r\n    },\r\n    \r\n    toSVGMatrix: function() {\r\n      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();\r\n      \r\n      // top two rows\r\n      result.a = this.m00();\r\n      result.b = this.m10();\r\n      result.c = this.m01();\r\n      result.d = this.m11();\r\n      result.e = this.m02();\r\n      result.f = this.m12();\r\n      \r\n      return result;\r\n    },\r\n    \r\n    getCSSTransform: function() {\r\n      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility\r\n      \r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n      \r\n      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!\r\n      // NOTE: the toFixed calls are inlined for performance reasons\r\n      return 'matrix(' + this.entries[0].toFixed( 20 ) + ',' + this.entries[1].toFixed( 20 ) + ',' + this.entries[3].toFixed( 20 ) + ',' + this.entries[4].toFixed( 20 ) + ',' + this.entries[6].toFixed( 20 ) + ',' + this.entries[7].toFixed( 20 ) + ')';\r\n    },\r\n    get cssTransform() { return this.getCSSTransform(); },\r\n    \r\n    getSVGTransform: function() {\r\n      // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute\r\n      \r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      function svgNumber( number ) {\r\n        // largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n        return number.toFixed( 20 );\r\n      }\r\n      \r\n      switch( this.type ) {\r\n        case Types.IDENTITY:\r\n          return '';\r\n        case Types.TRANSLATION_2D:\r\n          return 'translate(' + svgNumber( this.entries[6] ) + ',' + this.entries[7] + ')';\r\n        case Types.SCALING:\r\n          return 'scale(' + svgNumber( this.entries[0] ) + ( this.entries[0] === this.entries[4] ? '' : ',' + svgNumber( this.entries[4] ) ) + ')';\r\n        default:\r\n          return 'matrix(' + svgNumber( this.entries[0] ) + ',' + svgNumber( this.entries[1] ) + ',' + svgNumber( this.entries[3] ) + ',' + svgNumber( this.entries[4] ) + ',' + svgNumber( this.entries[6] ) + ',' + svgNumber( this.entries[7] ) + ')';\r\n      }\r\n    },\r\n    get svgTransform() { return this.getSVGTransform(); },\r\n    \r\n    // returns a parameter object suitable for use with jQuery's .css()\r\n    getCSSTransformStyles: function() {\r\n      var transformCSS = this.getCSSTransform();\r\n      \r\n      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/\r\n      return {\r\n        // force iOS hardware acceleration\r\n        '-webkit-perspective': 1000,\r\n        '-webkit-backface-visibility': 'hidden',\r\n        \r\n        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible\r\n        '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible\r\n        '-ms-transform': transformCSS,\r\n        '-o-transform': transformCSS,\r\n        'transform': transformCSS,\r\n        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin\r\n        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?\r\n      };\r\n    },\r\n    get cssTransformStyles() { return this.getCSSTransformStyles(); },\r\n    \r\n    // exact equality\r\n    equals: function( m ) {\r\n      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&\r\n             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&\r\n             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();\r\n    },\r\n    \r\n    // equality within a margin of error\r\n    equalsEpsilon: function( m, epsilon ) {\r\n      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&\r\n             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&\r\n             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Immutable operations (returns a new matrix)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    copy: function() {\r\n      return new Matrix3(\r\n        this.m00(), this.m01(), this.m02(),\r\n        this.m10(), this.m11(), this.m12(),\r\n        this.m20(), this.m21(), this.m22(),\r\n        this.type\r\n      );\r\n    },\r\n    \r\n    plus: function( m ) {\r\n      return new Matrix3(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()\r\n      );\r\n    },\r\n    \r\n    minus: function( m ) {\r\n      return new Matrix3(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()\r\n      );\r\n    },\r\n    \r\n    transposed: function() {\r\n      return new Matrix3(\r\n        this.m00(), this.m10(), this.m20(),\r\n        this.m01(), this.m11(), this.m21(),\r\n        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined\r\n      );\r\n    },\r\n    \r\n    negated: function() {\r\n      return new Matrix3(\r\n        -this.m00(), -this.m01(), -this.m02(),\r\n        -this.m10(), -this.m11(), -this.m12(),\r\n        -this.m20(), -this.m21(), -this.m22()\r\n      );\r\n    },\r\n    \r\n    inverted: function() {\r\n      var det;\r\n      \r\n      switch ( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_2D:\r\n          return new Matrix3( 1, 0, -this.m02(),\r\n                              0, 1, -this.m12(),\r\n                              0, 0, 1, Types.TRANSLATION_2D );\r\n        case Types.SCALING:\r\n          return new Matrix3( 1 / this.m00(), 0, 0,\r\n                              0, 1 / this.m11(), 0,\r\n                              0, 0, 1 / this.m22(), Types.SCALING );\r\n        case Types.AFFINE:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return new Matrix3(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              0, 0, 1, Types.AFFINE\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        case Types.OTHER:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return new Matrix3(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,\r\n              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,\r\n              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,\r\n              Types.OTHER\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n    \r\n    timesMatrix: function( m ) {\r\n      // I * M === M * I === I (the identity)\r\n      if( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {\r\n        return this.type === Types.IDENTITY ? m : this;\r\n      }\r\n      \r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_2D ) {\r\n          // faster combination of translations\r\n          return new Matrix3( 1, 0, this.m02() + m.m02(),\r\n                              0, 1, this.m12() + m.m12(),\r\n                              0, 0, 1, Types.TRANSLATION_2D );\r\n        } else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return new Matrix3( this.m00() * m.m00(), 0, 0,\r\n                              0, this.m11() * m.m11(), 0,\r\n                              0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n      \r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n        \r\n        // affine case\r\n        return new Matrix3( this.m00() * m.m00() + this.m01() * m.m10(),\r\n                            this.m00() * m.m01() + this.m01() * m.m11(),\r\n                            this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),\r\n                            this.m10() * m.m00() + this.m11() * m.m10(),\r\n                            this.m10() * m.m01() + this.m11() * m.m11(),\r\n                            this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),\r\n                            0, 0, 1, Types.AFFINE );\r\n      }\r\n      \r\n      // general case\r\n      return new Matrix3( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n                          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n                          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n                          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n                          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n                          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n                          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n                          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n                          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Immutable operations (returns new form of a parameter)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    timesVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02();\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12();\r\n      return new dot.Vector2( x, y );\r\n    },\r\n    \r\n    timesVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;\r\n      return new dot.Vector3( x, y, z );\r\n    },\r\n    \r\n    timesTransposeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y;\r\n      var y = this.m01() * v.x + this.m11() * v.y;\r\n      return new dot.Vector2( x, y );\r\n    },\r\n    \r\n    // TODO: this operation seems to not work for transformDelta2, should be vetted\r\n    timesRelativeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y;\r\n      var y = this.m10() * v.y + this.m11() * v.y;\r\n      return new dot.Vector2( x, y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Mutable operations (changes this matrix)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    makeImmutable: function() {\r\n      this.rowMajor = function() {\r\n        throw new Error( 'Cannot modify immutable matrix' );\r\n      };\r\n      return this;\r\n    },\r\n    \r\n    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n      this.entries[0] = v00;\r\n      this.entries[1] = v10;\r\n      this.entries[2] = v20;\r\n      this.entries[3] = v01;\r\n      this.entries[4] = v11;\r\n      this.entries[5] = v21;\r\n      this.entries[6] = v02;\r\n      this.entries[7] = v12;\r\n      this.entries[8] = v22;\r\n      \r\n      // TODO: consider performance of the affine check here\r\n      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;\r\n      return this;\r\n    },\r\n    \r\n    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {\r\n      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n    },\r\n    \r\n    add: function( m ) {\r\n      return this.rowMajor(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()\r\n      );\r\n    },\r\n    \r\n    subtract: function( m ) {\r\n      return this.rowMajor(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()\r\n      );\r\n    },\r\n    \r\n    transpose: function() {\r\n      return this.rowMajor(\r\n        this.m00(), this.m10(), this.m20(),\r\n        this.m01(), this.m11(), this.m21(),\r\n        this.m02(), this.m12(), this.m22(),\r\n        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined\r\n      );\r\n    },\r\n    \r\n    negate: function() {\r\n      return this.rowMajor(\r\n        -this.m00(), -this.m01(), -this.m02(),\r\n        -this.m10(), -this.m11(), -this.m12(),\r\n        -this.m20(), -this.m21(), -this.m22()\r\n      );\r\n    },\r\n    \r\n    invert: function() {\r\n      var det;\r\n      \r\n      switch ( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_2D:\r\n          return this.rowMajor( 1, 0, -this.m02(),\r\n                                0, 1, -this.m12(),\r\n                                0, 0, 1, Types.TRANSLATION_2D );\r\n        case Types.SCALING:\r\n          return this.rowMajor( 1 / this.m00(), 0, 0,\r\n                                0, 1 / this.m11(), 0,\r\n                                0, 0, 1 / this.m22(), Types.SCALING );\r\n        case Types.AFFINE:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return this.rowMajor(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              0, 0, 1, Types.AFFINE\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        case Types.OTHER:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return this.rowMajor(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,\r\n              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,\r\n              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,\r\n              Types.OTHER\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n    \r\n    multiplyMatrix: function( m ) {\r\n      // I * M === M * I === I (the identity)\r\n      if( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {\r\n        return this.type === Types.IDENTITY ? m : this;\r\n      }\r\n      \r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_2D ) {\r\n          // faster combination of translations\r\n          return this.rowMajor( 1, 0, this.m02() + m.m02(),\r\n                                0, 1, this.m12() + m.m12(),\r\n                                0, 0, 1, Types.TRANSLATION_2D );\r\n        } else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return this.rowMajor( this.m00() * m.m00(), 0, 0,\r\n                                0, this.m11() * m.m11(), 0,\r\n                                0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n      \r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n        \r\n        // affine case\r\n        return this.rowMajor( this.m00() * m.m00() + this.m01() * m.m10(),\r\n                              this.m00() * m.m01() + this.m01() * m.m11(),\r\n                              this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),\r\n                              this.m10() * m.m00() + this.m11() * m.m10(),\r\n                              this.m10() * m.m01() + this.m11() * m.m11(),\r\n                              this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),\r\n                              0, 0, 1, Types.AFFINE );\r\n      }\r\n      \r\n      // general case\r\n      return this.rowMajor( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n                            this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n                            this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n                            this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n                            this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n                            this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n                            this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n                            this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n                            this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Mutable operations (changes the parameter)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    multiplyVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02();\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12();\r\n      v.setX( x );\r\n      v.setY( y );\r\n      return v;\r\n    },\r\n    \r\n    multiplyVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;\r\n      v.setX( x );\r\n      v.setY( y );\r\n      v.setZ( z );\r\n      return v;\r\n    },\r\n    \r\n    multiplyTransposeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y;\r\n      var y = this.m01() * v.x + this.m11() * v.y;\r\n      v.setX( x );\r\n      v.setY( y );\r\n      return v;\r\n    },\r\n    \r\n    multiplyRelativeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y;\r\n      var y = this.m10() * v.y + this.m11() * v.y;\r\n      v.setX( x );\r\n      v.setY( y );\r\n      return v;\r\n    },\r\n    \r\n    // sets the transform of a Canvas 2D rendering context to the affine part of this matrix\r\n    canvasSetTransform: function( context ) {\r\n      context.setTransform(\r\n        // inlined array entries\r\n        this.entries[0],\r\n        this.entries[1],\r\n        this.entries[3],\r\n        this.entries[4],\r\n        this.entries[6],\r\n        this.entries[7]\r\n      );\r\n    },\r\n    \r\n    // appends the affine part of this matrix to the Canvas 2D rendering context\r\n    canvasAppendTransform: function( context ) {\r\n      if ( this.type !== Types.IDENTITY ) {\r\n        context.transform(\r\n          // inlined array entries\r\n          this.entries[0],\r\n          this.entries[1],\r\n          this.entries[3],\r\n          this.entries[4],\r\n          this.entries[6],\r\n          this.entries[7]\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  // create an immutable\r\n  Matrix3.IDENTITY = new Matrix3( 1, 0, 0,\r\n                                  0, 1, 0,\r\n                                  0, 0, 1,\r\n                                  Types.IDENTITY );\r\n  Matrix3.IDENTITY.makeImmutable();\r\n  \r\n  Matrix3.X_REFLECTION = new Matrix3( -1, 0, 0,\r\n                                       0, 1, 0,\r\n                                       0, 0, 1,\r\n                                       Types.AFFINE );\r\n  Matrix3.X_REFLECTION.makeImmutable();\r\n  \r\n  Matrix3.Y_REFLECTION = new Matrix3( 1,  0, 0,\r\n                                      0, -1, 0,\r\n                                      0,  0, 1,\r\n                                      Types.AFFINE );\r\n  Matrix3.Y_REFLECTION.makeImmutable();\r\n  \r\n  Matrix3.printer = {\r\n    print: function( matrix ) {\r\n      console.log( matrix.toString() );\r\n    }\r\n  };\r\n  \r\n  return Matrix3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Forward and inverse transforms with 3x3 matrices\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Transform3',['require','ASSERT/assert','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {\r\n  'use strict';\r\n\r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Matrix3' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Ray2' );\r\n\r\n  // takes a 4x4 matrix\r\n  dot.Transform3 = function Transform3( matrix ) {\r\n    this.listeners = [];\r\n    \r\n    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices\r\n    this.set( matrix === undefined ? dot.Matrix3.IDENTITY : matrix );\r\n  };\r\n  var Transform3 = dot.Transform3;\r\n\r\n  Transform3.prototype = {\r\n    constructor: Transform3,\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * mutators\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    set: function( matrix ) {\r\n      // TODO: performance: don't notify or handle instances where the matrix is detected to be the identity matrix?\r\n      assert && assert( matrix instanceof dot.Matrix3 );\r\n      \r\n      var oldMatrix = this.matrix;\r\n      var length = this.listeners.length;\r\n      var i;\r\n      \r\n      // notify listeners before the change\r\n      for ( i = 0; i < length; i++ ) {\r\n        this.listeners[i].before( matrix, oldMatrix );\r\n      }\r\n      \r\n      this.matrix = matrix;\r\n      \r\n      // compute these lazily\r\n      this.inverse = null;\r\n      this.matrixTransposed = null;\r\n      this.inverseTransposed = null;\r\n      \r\n      // notify listeners after the change\r\n      for ( i = 0; i < length; i++ ) {\r\n        this.listeners[i].after( matrix, oldMatrix );\r\n      }\r\n    },\r\n    \r\n    prepend: function( matrix ) {\r\n      this.set( matrix.timesMatrix( this.matrix ) );\r\n    },\r\n\r\n    append: function( matrix ) {\r\n      this.set( this.matrix.timesMatrix( matrix ) );\r\n    },\r\n\r\n    prependTransform: function( transform ) {\r\n      this.prepend( transform.matrix );\r\n    },\r\n\r\n    appendTransform: function( transform ) {\r\n      this.append( transform.matrix );\r\n    },\r\n\r\n    applyToCanvasContext: function( context ) {\r\n      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * getters\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // uses the same matrices, for use cases where the matrices are considered immutable\r\n    copy: function() {\r\n      var transform = new Transform3( this.matrix );\r\n      transform.inverse = this.inverse;\r\n      transform.matrixTransposed = this.matrixTransposed;\r\n      transform.inverseTransposed = this.inverseTransposed;\r\n    },\r\n    \r\n    // copies matrices, for use cases where the matrices are considered mutable\r\n    deepCopy: function() {\r\n      var transform = new Transform3( this.matrix.copy() );\r\n      transform.inverse = this.inverse ? this.inverse.copy() : null;\r\n      transform.matrixTransposed = this.matrixTransposed ? this.matrixTransposed.copy() : null;\r\n      transform.inverseTransposed = this.inverseTransposed ? this.inverseTransposed.copy() : null;\r\n    },\r\n    \r\n    getMatrix: function() {\r\n      return this.matrix;\r\n    },\r\n    \r\n    getInverse: function() {\r\n      if ( this.inverse === null ) {\r\n        this.inverse = this.matrix.inverted();\r\n      }\r\n      return this.inverse;\r\n    },\r\n    \r\n    getMatrixTransposed: function() {\r\n      if ( this.matrixTransposed === null ) {\r\n        this.matrixTransposed = this.matrix.transposed();\r\n      }\r\n      return this.matrixTransposed;\r\n    },\r\n    \r\n    getInverseTransposed: function() {\r\n      if ( this.inverseTransposed === null ) {\r\n        this.inverseTransposed = this.getInverse().transposed();\r\n      }\r\n      return this.inverseTransposed;\r\n    },\r\n    \r\n    isIdentity: function() {\r\n      return this.matrix.type === dot.Matrix3.Types.IDENTITY;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return this.matrix.isFinite();\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * forward transforms (for Vector2 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // transform a position (includes translation)\r\n    transformPosition2: function( vec2 ) {\r\n      return this.matrix.timesVector2( vec2 );\r\n    },\r\n\r\n    // transform a vector (exclude translation)\r\n    transformDelta2: function( vec2 ) {\r\n      // transform actually has the translation rolled into the other coefficients, so we have to make this longer\r\n      return this.transformPosition2( vec2 ).minus( this.transformPosition2( dot.Vector2.ZERO ) );\r\n    },\r\n\r\n    // transform a normal vector (different than a normal vector)\r\n    transformNormal2: function( vec2 ) {\r\n      return this.getInverse().timesTransposeVector2( vec2 );\r\n    },\r\n\r\n    transformDeltaX: function( x ) {\r\n      return this.transformDelta2( new dot.Vector2( x, 0 ) ).x;\r\n    },\r\n\r\n    transformDeltaY: function( y ) {\r\n      return this.transformDelta2( new dot.Vector2( 0, y ) ).y;\r\n    },\r\n    \r\n    transformBounds2: function( bounds2 ) {\r\n      return bounds2.transformed( this.matrix );\r\n    },\r\n    \r\n    transformShape: function( shape ) {\r\n      return shape.transformed( this.matrix );\r\n    },\r\n    \r\n    transformRay2: function( ray ) {\r\n      return new dot.Ray2( this.transformPosition2( ray.pos ), this.transformDelta2( ray.dir ).normalized() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * inverse transforms (for Vector2 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    inversePosition2: function( vec2 ) {\r\n      return this.getInverse().timesVector2( vec2 );\r\n    },\r\n\r\n    inverseDelta2: function( vec2 ) {\r\n      // inverse actually has the translation rolled into the other coefficients, so we have to make this longer\r\n      return this.inversePosition2( vec2 ).minus( this.inversePosition2( dot.Vector2.ZERO ) );\r\n    },\r\n\r\n    inverseNormal2: function( vec2 ) {\r\n      return this.matrix.timesTransposeVector2( vec2 );\r\n    },\r\n\r\n    inverseDeltaX: function( x ) {\r\n      return this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;\r\n    },\r\n\r\n    inverseDeltaY: function( y ) {\r\n      return this.inverseDelta2( new dot.Vector2( 0, y ) ).y;\r\n    },\r\n    \r\n    inverseBounds2: function( bounds2 ) {\r\n      return bounds2.transformed( this.getInverse() );\r\n    },\r\n    \r\n    inverseShape: function( shape ) {\r\n      return shape.transformed( this.getInverse() );\r\n    },\r\n    \r\n    inverseRay2: function( ray ) {\r\n      return new dot.Ray2( this.inversePosition2( ray.pos ), this.inverseDelta2( ray.dir ).normalized() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * listeners\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // note: listener.before( matrix, oldMatrix ) will be called before the change, listener.after( matrix, oldMatrix ) will be called after\r\n    addTransformListener: function( listener ) {\r\n      assert && assert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.push( listener );\r\n    },\r\n    \r\n    // useful for making sure the listener is triggered first\r\n    prependTransformListener: function( listener ) {\r\n      assert && assert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.unshift( listener );\r\n    },\r\n    \r\n    removeTransformListener: function( listener ) {\r\n      assert && assert( _.contains( this.listeners, listener ) );\r\n      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );\r\n    }\r\n  };\r\n  \r\n  return Transform3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A segment represents a specific curve with a start and end.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Segment',['require','ASSERT/assert','KITE/kite','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var DotUtil = require( 'DOT/Util' );\r\n  \r\n  /*\r\n   * Will contain (for segments):\r\n   * properties:\r\n   * start        - start point of this segment\r\n   * end          - end point of this segment\r\n   * startTangent - the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)\r\n   * endTangent   - the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)\r\n   * bounds       - the bounding box for the segment\r\n   *\r\n   * methods:\r\n   * positionAt( t )          - returns the position parametrically, with 0 <= t <= 1. this does NOT guarantee a constant magnitude tangent... don't feel like adding elliptical functions yet!\r\n   * tangentAt( t )           - returns the non-normalized tangent (dx/dt, dy/dt) parametrically, with 0 <= t <= 1.\r\n   * curvatureAt( t )         - returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)\r\n   * subdivided( t, skip )    - returns an array with 2 sub-segments, split at the parametric t value. if skip is passed, expensive operations are not performed\r\n   * getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first\r\n   * strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side\r\n   * strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side\r\n   * intersectsBounds         - whether this segment intersects the specified bounding box (not just the segment's bounding box, but the actual segment)\r\n   * windingIntersection      - returns the winding number for intersection with a ray\r\n   *\r\n   * writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point\r\n   * transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix\r\n   */\r\n  kite.Segment = function Segment(){}; // no common construction for now\r\n  var Segment = kite.Segment;\r\n  \r\n  Segment.prototype = {\r\n    constructor: Segment,\r\n    \r\n    // tList should be a list of sorted t values from 0 <= t <= 1\r\n    subdivisions: function( tList, skipComputation ) {\r\n      // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization\r\n      var right = this;\r\n      var result = [];\r\n      for ( var i = 0; i < tList.length; i++ ) {\r\n        // assume binary subdivision\r\n        var t = tList[i];\r\n        var arr = right.subdivided( t, skipComputation );\r\n        assert && assert( arr.length === 2 );\r\n        result.push( arr[0] );\r\n        right = arr[1];\r\n        \r\n        // scale up the remaining t values\r\n        for ( var j = i + 1; j < tList.length; j++ ) {\r\n          tList[j] = DotUtil.linear( t, 1, 0, 1, tList[j] );\r\n        }\r\n      }\r\n      result.push( right );\r\n      return result;\r\n    },\r\n    \r\n    // return an array of segments from breaking this segment into monotone pieces\r\n    subdividedIntoMonotone: function() {\r\n      return this.subdivisions( this.getInteriorExtremaTs() );\r\n    },\r\n  };\r\n  \r\n  return Segment;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Linear segment\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Line',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Bounds2','DOT/Util','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Line = function Line( start, end ) {\r\n    this.start = start;\r\n    this.end = end;\r\n    \r\n    if ( start.equals( end, 0 ) ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    this.startTangent = end.minus( start ).normalized();\r\n    this.endTangent = this.startTangent;\r\n    \r\n    // acceleration for intersection\r\n    this.bounds = Bounds2.NOTHING.withPoint( start ).withPoint( end );\r\n  };\r\n  inherit( Segment, Segment.Line, {\r\n    \r\n    positionAt: function( t ) {\r\n      return this.start.plus( this.end.minus( this.start ).times( t ) );\r\n    },\r\n    \r\n    tangentAt: function( t ) {\r\n      // tangent always the same, just use the start tanget\r\n      return this.startTangent;\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      return 0; // no curvature on a straight line segment\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      return 'L ' + this.end.x + ' ' + this.end.y;\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      var offset = this.endTangent.perpendicular().negated().times( lineWidth / 2 );\r\n      return [new Segment.Line( this.start.plus( offset ), this.end.plus( offset ) )];\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      var offset = this.startTangent.perpendicular().times( lineWidth / 2 );\r\n      return [new Segment.Line( this.end.plus( offset ), this.start.plus( offset ) )];\r\n    },\r\n    \r\n    // lines are already monotone\r\n    getInteriorExtremaTs: function() { return []; },\r\n    \r\n    subdivided: function( t ) {\r\n      var pt = this.positionAt( t );\r\n      return [\r\n        new Segment.Line( this.start, pt ),\r\n        new Segment.Line( pt, this.end )\r\n      ];\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Line.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var result = [];\r\n      \r\n      var start = this.start;\r\n      var end = this.end;\r\n      \r\n      var intersection = lineLineIntersection( start, end, ray.pos, ray.pos.plus( ray.dir ) );\r\n      \r\n      if ( !isFinite( intersection.x ) || !isFinite( intersection.y ) ) {\r\n        // lines must be parallel\r\n        return result;\r\n      }\r\n      \r\n      // check to make sure our point is in our line segment (specifically, in the bounds (start,end], not including the start point so we don't double-count intersections)\r\n      if ( start.x !== end.x && ( start.x > end.x ? ( intersection.x >= start.x || intersection.x < end.x ) : ( intersection.x <= start.x || intersection.x > end.x ) ) ) {\r\n        return result;\r\n      }\r\n      if ( start.y !== end.y && ( start.y > end.y ? ( intersection.y >= start.y || intersection.y < end.y ) : ( intersection.y <= start.y || intersection.y > end.y ) ) ) {\r\n        return result;\r\n      }\r\n      \r\n      // make sure the intersection is not behind the ray\r\n      var t = intersection.minus( ray.pos ).dot( ray.dir );\r\n      if ( t < 0 ) {\r\n        return result;\r\n      }\r\n      \r\n      // return the proper winding direction depending on what way our line intersection is \"pointed\"\r\n      var diff = end.minus( start );\r\n      var perp = diff.perpendicular();\r\n      result.push( {\r\n        distance: t,\r\n        point: ray.pointAtDistance( t ),\r\n        normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n        wind: ray.dir.perpendicular().dot( diff ) < 0 ? 1 : -1\r\n      } );\r\n      return result;\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      var hits = this.intersection( ray );\r\n      if ( hits.length ) {\r\n        return hits[0].wind;\r\n      } else {\r\n        return 0;\r\n      }\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.lineTo( this.end.x, this.end.y );\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Segment.Line( matrix.timesVector2( this.start ), matrix.timesVector2( this.end ) );\r\n    }\r\n  } );\r\n  \r\n  return Segment.Line;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Arc segment\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Arc',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var DotUtil = require( 'DOT/Util' );\r\n\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Arc = function Arc( center, radius, startAngle, endAngle, anticlockwise ) {\r\n    if ( radius < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radius = -radius;\r\n      startAngle += Math.PI;\r\n      endAngle += Math.PI;\r\n    }\r\n    \r\n    this.center = center;\r\n    this.radius = radius;\r\n    this.startAngle = startAngle;\r\n    this.endAngle = endAngle;\r\n    this.anticlockwise = anticlockwise;\r\n    \r\n    this.start = this.positionAtAngle( startAngle );\r\n    this.end = this.positionAtAngle( endAngle );\r\n    this.startTangent = this.tangentAtAngle( startAngle );\r\n    this.endTangent = this.tangentAtAngle( endAngle );\r\n    \r\n    if ( radius <= 0 || startAngle === endAngle ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    // compute an actual end angle so that we can smoothly go from this.startAngle to this.actualEndAngle\r\n    if ( this.anticlockwise ) {\r\n      // angle is 'decreasing'\r\n      // -2pi <= end - start < 2pi\r\n      if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle - 2 * Math.PI;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    } else {\r\n      // angle is 'increasing'\r\n      // -2pi < end - start <= 2pi\r\n      if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle + Math.PI * 2;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    }\r\n    \r\n    // constraints\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );\r\n    \r\n    var isFullPerimeter = ( !anticlockwise && endAngle - startAngle >= Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle >= Math.PI * 2 );\r\n    \r\n    // compute an angle difference that represents how \"much\" of the circle our arc covers\r\n    this.angleDifference = this.anticlockwise ? this.startAngle - this.endAngle : this.endAngle - this.startAngle;\r\n    if ( this.angleDifference < 0 ) {\r\n      this.angleDifference += Math.PI * 2;\r\n    }\r\n    assert && assert( this.angleDifference >= 0 ); // now it should always be zero or positive\r\n    \r\n    // acceleration for intersection\r\n    this.bounds = Bounds2.NOTHING;\r\n    this.bounds = this.bounds.withPoint( this.start );\r\n    this.bounds = this.bounds.withPoint( this.end );\r\n    \r\n    // for bounds computations\r\n    var that = this;\r\n    function boundsAtAngle( angle ) {\r\n      if ( that.containsAngle( angle ) ) {\r\n        // the boundary point is in the arc\r\n        that.bounds = that.bounds.withPoint( center.plus( Vector2.createPolar( radius, angle ) ) );\r\n      }\r\n    }\r\n    \r\n    // if the angles are different, check extrema points\r\n    if ( startAngle !== endAngle ) {\r\n      // check all of the extrema points\r\n      boundsAtAngle( 0 );\r\n      boundsAtAngle( Math.PI / 2 );\r\n      boundsAtAngle( Math.PI );\r\n      boundsAtAngle( 3 * Math.PI / 2 );\r\n    }\r\n  };\r\n  inherit( Segment, Segment.Arc, {\r\n    \r\n    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.\r\n    mapAngle: function( angle ) {\r\n      // consider an assert that we contain that angle?\r\n      return ( this.startAngle > this.actualEndAngle ) ?\r\n             DotUtil.moduloBetweenUp( angle, this.startAngle - 2 * Math.PI, this.startAngle ) :\r\n             DotUtil.moduloBetweenDown( angle, this.startAngle, this.startAngle + 2 * Math.PI );\r\n    },\r\n    \r\n    tAtAngle: function( angle ) {\r\n      return ( this.mapAngle( angle ) - this.startAngle ) / ( this.actualEndAngle - this.startAngle );\r\n    },\r\n    \r\n    angleAt: function( t ) {\r\n      return this.startAngle + ( this.actualEndAngle - this.startAngle ) * t;\r\n    },\r\n    \r\n    positionAt: function( t ) {\r\n      return this.positionAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    tangentAt: function( t ) {\r\n      return this.tangentAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      return ( this.anticlockwise ? -1 : 1 ) / this.radius;\r\n    },\r\n    \r\n    positionAtAngle: function( angle ) {\r\n      return this.center.plus( Vector2.createPolar( this.radius, angle ) );\r\n    },\r\n    \r\n    tangentAtAngle: function( angle ) {\r\n      var normal = Vector2.createPolar( 1, angle );\r\n      \r\n      return this.anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();\r\n    },\r\n    \r\n    // TODO: refactor? shared with Segment.EllipticalArc (use this improved version)\r\n    containsAngle: function( angle ) {\r\n      // transform the angle into the appropriate coordinate form\r\n      // TODO: check anticlockwise version!\r\n      var normalizedAngle = this.anticlockwise ? angle - this.endAngle : angle - this.startAngle;\r\n      \r\n      // get the angle between 0 and 2pi\r\n      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );\r\n      \r\n      return positiveMinAngle <= this.angleDifference;\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info\r\n      // rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n      \r\n      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'\r\n      var sweepFlag = this.anticlockwise ? '0' : '1';\r\n      var largeArcFlag;\r\n      if ( this.angleDifference < Math.PI * 2 - epsilon ) {\r\n        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';\r\n        return 'A ' + this.radius + ' ' + this.radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n      } else {\r\n        // circle (or almost-circle) case needs to be handled differently\r\n        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs\r\n        \r\n        // get the angle that is between and opposite of both of the points\r\n        var splitOppositeAngle = ( this.startAngle + this.endAngle ) / 2; // this _should_ work for the modular case?\r\n        var splitPoint = this.center.plus( Vector2.createPolar( this.radius, splitOppositeAngle ) );\r\n        \r\n        largeArcFlag = '0'; // since we split it in 2, it's always the small arc\r\n        \r\n        var firstArc = 'A ' + this.radius + ' ' + this.radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;\r\n        var secondArc = 'A ' + this.radius + ' ' + this.radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n        \r\n        return firstArc + ' ' + secondArc;\r\n      }\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return [new Segment.Arc( this.center, this.radius + ( this.anticlockwise ? 1 : -1 ) * lineWidth / 2, this.startAngle, this.endAngle, this.anticlockwise )];\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return [new Segment.Arc( this.center, this.radius + ( this.anticlockwise ? -1 : 1 ) * lineWidth / 2, this.endAngle, this.startAngle, !this.anticlockwise )];\r\n    },\r\n    \r\n    // not including 0 and 1\r\n    getInteriorExtremaTs: function() {\r\n      var that = this;\r\n      var result = [];\r\n      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {\r\n        if ( that.containsAngle( angle ) ) {\r\n          var t = that.tAtAngle( angle );\r\n          var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n          if ( t > epsilon && t < 1 - epsilon ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort(); // modifies original, which is OK\r\n    },\r\n    \r\n    subdivided: function( t ) {\r\n      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles\r\n      var angle0 = this.angleAt( 0 );\r\n      var angleT = this.angleAt( t );\r\n      var angle1 = this.angleAt( 1 );\r\n      return [\r\n        new Segment.Arc( this.center, this.radius, angle0, angleT, this.anticlockwise ),\r\n        new Segment.Arc( this.center, this.radius, angleT, angle1, this.anticlockwise )\r\n      ];\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.intersectsBounds unimplemented!' );\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var result = []; // hits in order\r\n      \r\n      // left here, if in the future we want to better-handle boundary points\r\n      var epsilon = 0;\r\n      \r\n      // Run a general circle-intersection routine, then we can test the angles later.\r\n      // Solves for the two solutions t such that ray.pos + ray.dir * t is on the circle.\r\n      // Then we check whether the angle at each possible hit point is in our arc.\r\n      var centerToRay = ray.pos.minus( this.center );\r\n      var tmp = ray.dir.dot( centerToRay );\r\n      var centerToRayDistSq = centerToRay.magnitudeSquared();\r\n      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this.radius * this.radius );\r\n      if ( discriminant < epsilon ) {\r\n        // ray misses circle entirely\r\n        return result;\r\n      }\r\n      var base = ray.dir.dot( this.center ) - ray.dir.dot( ray.pos );\r\n      var sqt = Math.sqrt( discriminant ) / 2;\r\n      var ta = base - sqt;\r\n      var tb = base + sqt;\r\n      \r\n      if ( tb < epsilon ) {\r\n        // circle is behind ray\r\n        return result;\r\n      }\r\n      \r\n      var pointB = ray.pointAtDistance( tb );\r\n      var normalB = pointB.minus( this.center ).normalized();\r\n      \r\n      if ( ta < epsilon ) {\r\n        // we are inside the circle, so only one intersection is possible\r\n        if ( this.containsAngle( normalB.angle() ) ) {\r\n          result.push( {\r\n            distance: tb,\r\n            point: pointB,\r\n            normal: normalB.negated(), // normal is towards the ray\r\n            wind: this.anticlockwise ? -1 : 1 // since we are inside, wind this way\r\n          } );\r\n        }\r\n      }\r\n      else {\r\n        // two possible hits (outside circle)\r\n        var pointA = ray.pointAtDistance( ta );\r\n        var normalA = pointA.minus( this.center ).normalized();\r\n        \r\n        if ( this.containsAngle( normalA.angle() ) ) {\r\n          result.push( {\r\n            distance: ta,\r\n            point: pointA,\r\n            normal: normalA,\r\n            wind: this.anticlockwise ? 1 : -1 // hit from outside\r\n          } );\r\n        }\r\n        if ( this.containsAngle( normalB.angle() ) ) {\r\n          result.push( {\r\n            distance: tb,\r\n            point: pointB,\r\n            normal: normalB.negated(),\r\n            wind: this.anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way\r\n          } );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n    \r\n    writeToContext: function( context ) {\r\n      context.arc( this.center.x, this.center.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise );\r\n    },\r\n    \r\n    // TODO: test various transform types, especially rotations, scaling, shears, etc.\r\n    transformed: function( matrix ) {\r\n      // so we can handle reflections in the transform, we do the general case handling for start/end angles\r\n      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this.startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();\r\n      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this.endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();\r\n      \r\n      // reverse the 'clockwiseness' if our transform includes a reflection\r\n      var anticlockwise = matrix.getDeterminant() >= 0 ? this.anticlockwise : !this.anticlockwise;\r\n\r\n      var scaleVector = matrix.getScaleVector();\r\n      if ( scaleVector.x !== scaleVector.y ) {\r\n        var radiusX = scaleVector.x * this.radius;\r\n        var radiusY = scaleVector.y * this.radius;\r\n        return new Segment.EllipticalArc( matrix.timesVector2( this.center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );\r\n      } else {\r\n        var radius = scaleVector.x * this.radius;\r\n        return new Segment.Arc( matrix.timesVector2( this.center ), radius, startAngle, endAngle, anticlockwise );\r\n      }\r\n    }\r\n  } );\r\n  \r\n  return Segment.Arc;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.\r\n *\r\n * See http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#concept-path\r\n * for the path / subpath Canvas concept.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/util/Subpath',['require','ASSERT/assert','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Line','KITE/segments/Arc'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  \r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Arc' );\r\n  \r\n  // all arguments optional (they are for the copy() method)\r\n  kite.Subpath = function Subpath( segments, points, closed ) {\r\n    this.segments = segments || [];\r\n    \r\n    // recombine points if necessary, based off of start points of segments + the end point of the last segment\r\n    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[segments.length-1].end ) : [] );\r\n    this.closed = !!closed;\r\n    \r\n    // cached stroked shape (so hit testing can be done quickly on stroked shapes)\r\n    this._strokedSubpaths = null;\r\n    this._strokedSubpathsComputed = false;\r\n    this._strokedStyles = null;\r\n  };\r\n  var Subpath = kite.Subpath;\r\n  Subpath.prototype = {\r\n    copy: function() {\r\n      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );\r\n    },\r\n    \r\n    invalidate: function() {\r\n      this._strokedSubpathsComputed = false;\r\n    },\r\n    \r\n    addPoint: function( point ) {\r\n      this.points.push( point );\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    addSegment: function( segment ) {\r\n      if ( !segment.invalid ) {\r\n        assert && assert( segment.start.isFinite(), 'Segment start is infinite' );\r\n        assert && assert( segment.end.isFinite(), 'Segment end is infinite' );\r\n        assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );\r\n        assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );\r\n        assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );\r\n        this.segments.push( segment );\r\n        this.invalidate();\r\n      }\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    close: function() {\r\n      this.closed = true;\r\n    },\r\n    \r\n    getLength: function() {\r\n      return this.points.length;\r\n    },\r\n    \r\n    getFirstPoint: function() {\r\n      return _.first( this.points );\r\n    },\r\n    \r\n    getLastPoint: function() {\r\n      return _.last( this.points );\r\n    },\r\n    \r\n    getFirstSegment: function() {\r\n      return _.first( this.segments );\r\n    },\r\n    \r\n    getLastSegment: function() {\r\n      return _.last( this.segments );\r\n    },\r\n    \r\n    isDrawable: function() {\r\n      return this.segments.length > 0;\r\n    },\r\n    \r\n    isClosed: function() {\r\n      return this.closed;\r\n    },\r\n    \r\n    hasClosingSegment: function() {\r\n      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );\r\n    },\r\n    \r\n    getClosingSegment: function() {\r\n      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );\r\n      return new kite.Segment.Line( this.getLastPoint(), this.getFirstPoint() );\r\n    },\r\n    \r\n    writeToContext: function( context ) {\r\n      if ( this.isDrawable() ) {\r\n        var startPoint = this.getFirstSegment().start;\r\n        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start\r\n        \r\n        _.each( this.segments, function( segment ) {\r\n          segment.writeToContext( context );\r\n        } );\r\n        \r\n        if ( this.closed ) {\r\n          context.closePath();\r\n        }\r\n      }\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Subpath(\r\n        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),\r\n        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),\r\n        this.closed\r\n      );\r\n    },\r\n    \r\n    computeBounds: function() {\r\n      return _.reduce( this.segments, function( bounds, segment ) {\r\n        return bounds.union( segment.bounds );\r\n      }, Bounds2.NOTHING );\r\n    },\r\n    \r\n    // returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.\r\n    stroked: function( lineStyles ) {\r\n      // non-drawable subpaths convert to empty subpaths\r\n      if ( !this.isDrawable() ) {\r\n        return new Subpath();\r\n      }\r\n      \r\n      if ( lineStyles === undefined ) {\r\n        lineStyles = new kite.LineStyles();\r\n      }\r\n      \r\n      // return a cached version if possible\r\n      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {\r\n        return this._strokedSubpaths;\r\n      }\r\n      \r\n      var lineWidth = lineStyles.lineWidth;\r\n      \r\n      // joins two segments together on the logical \"left\" side, at 'center' (where they meet), and normalized tangent vectors in the direction of the stroking\r\n      // to join on the \"right\" side, switch the tangent order and negate them\r\n      function join( center, fromTangent, toTangent ) {\r\n        // where our join path starts and ends\r\n        var fromPoint = center.plus( fromTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n        var toPoint = center.plus( toTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n        \r\n        var bevel = ( fromPoint.equals( toPoint ) ? [] : [new kite.Segment.Line( fromPoint, toPoint )] );\r\n        \r\n        // only insert a join on the non-acute-angle side\r\n        if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {\r\n          switch( lineStyles.lineJoin ) {\r\n            case 'round':\r\n              var fromAngle = fromTangent.angle() + Math.PI / 2;\r\n              var toAngle = toTangent.angle() + Math.PI / 2;\r\n              return [new kite.Segment.Arc( center, lineWidth / 2, fromAngle, toAngle, true )];\r\n            case 'miter':\r\n              var theta = fromTangent.angleBetween( toTangent.negated() );\r\n              var notStraight = theta < Math.PI - 0.00001; // if fromTangent is approximately equal to toTangent, just bevel. it will be indistinguishable\r\n              if ( 1 / Math.sin( theta / 2 ) <= lineStyles.miterLimit && theta < Math.PI - 0.00001 ) {\r\n                // draw the miter\r\n                var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );\r\n                return [\r\n                  new kite.Segment.Line( fromPoint, miterPoint ),\r\n                  new kite.Segment.Line( miterPoint, toPoint )\r\n                ];\r\n              } else {\r\n                // angle too steep, use bevel instead. same as below, but copied for linter\r\n                return bevel;\r\n              }\r\n              break;\r\n            case 'bevel':\r\n              return bevel;\r\n          }\r\n        } else {\r\n          // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place\r\n          // TODO: can we prevent self-intersection here?\r\n          return bevel;\r\n        }\r\n      }\r\n      \r\n      // draws the necessary line cap from the endpoint 'center' in the direction of the tangent\r\n      function cap( center, tangent ) {\r\n        var fromPoint = center.plus( tangent.perpendicular().times( -lineWidth / 2 ) );\r\n        var toPoint = center.plus( tangent.perpendicular().times( lineWidth / 2 ) );\r\n        \r\n        switch( lineStyles.lineCap ) {\r\n          case 'butt':\r\n            return [new kite.Segment.Line( fromPoint, toPoint )];\r\n          case 'round':\r\n            var tangentAngle = tangent.angle();\r\n            return [new kite.Segment.Arc( center, lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true )];\r\n          case 'square':\r\n            var toLeft = tangent.perpendicular().negated().times( lineWidth / 2 );\r\n            var toRight = tangent.perpendicular().times( lineWidth / 2 );\r\n            var toFront = tangent.times( lineWidth / 2 );\r\n            \r\n            var left = center.plus( toLeft ).plus( toFront );\r\n            var right = center.plus( toRight ).plus( toFront );\r\n            return [\r\n              new kite.Segment.Line( fromPoint, left ),\r\n              new kite.Segment.Line( left, right ),\r\n              new kite.Segment.Line( right, toPoint )\r\n            ];\r\n        }\r\n      }\r\n      \r\n      var i;\r\n      var leftSegments = [];\r\n      var rightSegments = [];\r\n      var firstSegment = this.getFirstSegment();\r\n      var lastSegment = this.getLastSegment();\r\n      \r\n      function addLeftSegments( segments ) {\r\n        _.each( segments, function( segment ) { leftSegments.push( segment ); } );\r\n      }\r\n      function addRightSegments( segments ) {\r\n        _.each( segments, function( segment ) { rightSegments.push( segment ); } );\r\n      }\r\n      \r\n      // we don't need to insert an implicit closing segment if the start and end points are the same\r\n      var alreadyClosed = lastSegment.end.equals( firstSegment.start );\r\n      // if there is an implicit closing segment\r\n      var closingSegment = alreadyClosed ? null : new kite.Segment.Line( this.segments[this.segments.length-1].end, this.segments[0].start );\r\n      \r\n      // stroke the logical \"left\" side of our path\r\n      for ( i = 0; i < this.segments.length; i++ ) {\r\n        if ( i > 0 ) {\r\n          addLeftSegments( join( this.segments[i].start, this.segments[i-1].endTangent, this.segments[i].startTangent, true ) );\r\n        }\r\n        addLeftSegments( this.segments[i].strokeLeft( lineWidth ) );\r\n      }\r\n      \r\n      // stroke the logical \"right\" side of our path\r\n      for ( i = this.segments.length - 1; i >= 0; i-- ) {\r\n        if ( i < this.segments.length - 1 ) {\r\n          addRightSegments( join( this.segments[i].end, this.segments[i+1].startTangent.negated(), this.segments[i].endTangent.negated(), false ) );\r\n        }\r\n        addRightSegments( this.segments[i].strokeRight( lineWidth ) );\r\n      }\r\n      \r\n      var subpaths;\r\n      if ( this.closed ) {\r\n        if ( alreadyClosed ) {\r\n          // add the joins between the start and end\r\n          addLeftSegments( join( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );\r\n          addRightSegments( join( lastSegment.end, firstSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );\r\n        } else {\r\n          // logical \"left\" stroke on the implicit closing segment\r\n          addLeftSegments( join( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );\r\n          addLeftSegments( closingSegment.strokeLeft( lineWidth ) );\r\n          addLeftSegments( join( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );\r\n          \r\n          // logical \"right\" stroke on the implicit closing segment\r\n          addRightSegments( join( closingSegment.end, firstSegment.startTangent.negated(), closingSegment.endTangent.negated() ) );\r\n          addRightSegments( closingSegment.strokeRight( lineWidth ) );\r\n          addRightSegments( join( closingSegment.start, closingSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );\r\n        }\r\n        subpaths = [\r\n          new Subpath( leftSegments, null, true ),\r\n          new Subpath( rightSegments, null, true )\r\n        ];\r\n      } else {\r\n        subpaths = [\r\n          new Subpath( leftSegments\r\n                         .concat( cap( lastSegment.end, lastSegment.endTangent ) )\r\n                         .concat( rightSegments )\r\n                         .concat( cap( firstSegment.start, firstSegment.startTangent.negated() ) ),\r\n                       null, true )\r\n        ];\r\n      }\r\n      \r\n      this._strokedSubpaths = subpaths;\r\n      this._strokedSubpathsComputed = true;\r\n      this._strokedStyles = new kite.LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable\r\n      \r\n      return subpaths;\r\n    }\r\n  };\r\n  \r\n  // TODO: performance / cleanliness to have these as methods instead?\r\n  function segmentStartLeft( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.start.plus( segment.startTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  function segmentEndLeft( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.end.plus( segment.endTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  function segmentStartRight( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.start.plus( segment.startTangent.perpendicular().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  function segmentEndRight( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.end.plus( segment.endTangent.perpendicular().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  return kite.Subpath;\r\n} );\r\n","\n// generated from svgPath.pegjs, with added kite namespace and require.js compatibility\r\n\r\ndefine( 'KITE/../parser/svgPath',['require','KITE/kite'],function( require ) {\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  /*\r\n   * Generated by PEG.js 0.7.0.\r\n   *\r\n   * http://pegjs.majda.cz/\r\n   */\r\n  \r\n  function quote(s) {\r\n    /*\r\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\r\n     * string literal except for the closing quote character, backslash,\r\n     * carriage return, line separator, paragraph separator, and line feed.\r\n     * Any character may appear in the form of an escape sequence.\r\n     *\r\n     * For portability, we also escape escape all control and non-ASCII\r\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\r\n     * because JSHint does not like the first and IE the second.\r\n     */\r\n     return '\"' + s\r\n      .replace(/\\\\/g, '\\\\\\\\')  // backslash\r\n      .replace(/\"/g, '\\\\\"')    // closing quote character\r\n      .replace(/\\x08/g, '\\\\b') // backspace\r\n      .replace(/\\t/g, '\\\\t')   // horizontal tab\r\n      .replace(/\\n/g, '\\\\n')   // line feed\r\n      .replace(/\\f/g, '\\\\f')   // form feed\r\n      .replace(/\\r/g, '\\\\r')   // carriage return\r\n      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\r\n      + '\"';\r\n  }\r\n  \r\n  kite.svgPath = {\r\n    /*\r\n     * Parses the input with a generated parser. If the parsing is successfull,\r\n     * returns a value explicitly or implicitly specified by the grammar from\r\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\r\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\r\n     */\r\n    parse: function(input, startRule) {\r\n      var parseFunctions = {\r\n        \"svgPath\": parse_svgPath,\r\n        \"movetoDrawtoCommandGroups\": parse_movetoDrawtoCommandGroups,\r\n        \"movetoDrawtoCommandGroup\": parse_movetoDrawtoCommandGroup,\r\n        \"drawtoCommands\": parse_drawtoCommands,\r\n        \"drawtoCommand\": parse_drawtoCommand,\r\n        \"moveto\": parse_moveto,\r\n        \"movetoArgumentSequence\": parse_movetoArgumentSequence,\r\n        \"closepath\": parse_closepath,\r\n        \"lineto\": parse_lineto,\r\n        \"linetoArgumentSequence\": parse_linetoArgumentSequence,\r\n        \"horizontalLineto\": parse_horizontalLineto,\r\n        \"horizontalLinetoArgumentSequence\": parse_horizontalLinetoArgumentSequence,\r\n        \"verticalLineto\": parse_verticalLineto,\r\n        \"verticalLinetoArgumentSequence\": parse_verticalLinetoArgumentSequence,\r\n        \"curveto\": parse_curveto,\r\n        \"curvetoArgumentSequence\": parse_curvetoArgumentSequence,\r\n        \"curvetoArgument\": parse_curvetoArgument,\r\n        \"smoothCurveto\": parse_smoothCurveto,\r\n        \"smoothCurvetoArgumentSequence\": parse_smoothCurvetoArgumentSequence,\r\n        \"smoothCurvetoArgument\": parse_smoothCurvetoArgument,\r\n        \"quadraticBezierCurveto\": parse_quadraticBezierCurveto,\r\n        \"quadraticBezierCurvetoArgumentSequence\": parse_quadraticBezierCurvetoArgumentSequence,\r\n        \"quadraticBezierCurvetoArgument\": parse_quadraticBezierCurvetoArgument,\r\n        \"smoothQuadraticBezierCurveto\": parse_smoothQuadraticBezierCurveto,\r\n        \"smoothQuadraticBezierCurvetoArgumentSequence\": parse_smoothQuadraticBezierCurvetoArgumentSequence,\r\n        \"ellipticalArc\": parse_ellipticalArc,\r\n        \"ellipticalArcArgumentSequence\": parse_ellipticalArcArgumentSequence,\r\n        \"ellipticalArcArgument\": parse_ellipticalArcArgument,\r\n        \"coordinatePair\": parse_coordinatePair,\r\n        \"nonnegativeNumber\": parse_nonnegativeNumber,\r\n        \"number\": parse_number,\r\n        \"flag\": parse_flag,\r\n        \"commaWsp\": parse_commaWsp,\r\n        \"comma\": parse_comma,\r\n        \"floatingPointConstant\": parse_floatingPointConstant,\r\n        \"fractionalConstant\": parse_fractionalConstant,\r\n        \"exponent\": parse_exponent,\r\n        \"sign\": parse_sign,\r\n        \"digitSequence\": parse_digitSequence,\r\n        \"digit\": parse_digit,\r\n        \"wsp\": parse_wsp\r\n      };\r\n      \r\n      if (startRule !== undefined) {\r\n        if (parseFunctions[startRule] === undefined) {\r\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\r\n        }\r\n      } else {\r\n        startRule = \"svgPath\";\r\n      }\r\n      \r\n      var pos = 0;\r\n      var reportFailures = 0;\r\n      var rightmostFailuresPos = 0;\r\n      var rightmostFailuresExpected = [];\r\n      \r\n      function padLeft(input, padding, length) {\r\n        var result = input;\r\n        \r\n        var padLength = length - input.length;\r\n        for (var i = 0; i < padLength; i++) {\r\n          result = padding + result;\r\n        }\r\n        \r\n        return result;\r\n      }\r\n      \r\n      function escape(ch) {\r\n        var charCode = ch.charCodeAt(0);\r\n        var escapeChar;\r\n        var length;\r\n        \r\n        if (charCode <= 0xFF) {\r\n          escapeChar = 'x';\r\n          length = 2;\r\n        } else {\r\n          escapeChar = 'u';\r\n          length = 4;\r\n        }\r\n        \r\n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\r\n      }\r\n      \r\n      function matchFailed(failure) {\r\n        if (pos < rightmostFailuresPos) {\r\n          return;\r\n        }\r\n        \r\n        if (pos > rightmostFailuresPos) {\r\n          rightmostFailuresPos = pos;\r\n          rightmostFailuresExpected = [];\r\n        }\r\n        \r\n        rightmostFailuresExpected.push(failure);\r\n      }\r\n      \r\n      function parse_svgPath() {\r\n        var result0, result1, result2, result3;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = [];\r\n        result1 = parse_wsp();\r\n        while (result1 !== null) {\r\n          result0.push(result1);\r\n          result1 = parse_wsp();\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = parse_movetoDrawtoCommandGroups();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = [];\r\n            result3 = parse_wsp();\r\n            while (result3 !== null) {\r\n              result2.push(result3);\r\n              result3 = parse_wsp();\r\n            }\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, path) { return path ? path : []; })(pos0, result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_movetoDrawtoCommandGroups() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_movetoDrawtoCommandGroup();\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_movetoDrawtoCommandGroups();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a.concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_movetoDrawtoCommandGroup();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return a; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_movetoDrawtoCommandGroup() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_moveto();\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_drawtoCommands();\r\n            result2 = result2 !== null ? result2 : \"\";\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, m, c) { return c.length ? m.concat( c ) : m; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_drawtoCommands() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_drawtoCommand();\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_drawtoCommands();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, cmd, cmds) { return cmd.concat( cmds ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_drawtoCommand();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, cmd) { return cmd; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_drawtoCommand() {\r\n        var result0;\r\n        \r\n        result0 = parse_closepath();\r\n        if (result0 === null) {\r\n          result0 = parse_lineto();\r\n          if (result0 === null) {\r\n            result0 = parse_horizontalLineto();\r\n            if (result0 === null) {\r\n              result0 = parse_verticalLineto();\r\n              if (result0 === null) {\r\n                result0 = parse_curveto();\r\n                if (result0 === null) {\r\n                  result0 = parse_smoothCurveto();\r\n                  if (result0 === null) {\r\n                    result0 = parse_quadraticBezierCurveto();\r\n                    if (result0 === null) {\r\n                      result0 = parse_smoothQuadraticBezierCurveto();\r\n                      if (result0 === null) {\r\n                        result0 = parse_ellipticalArc();\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_moveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 77) {\r\n          result0 = \"M\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"M\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_movetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return createMoveTo( args, false ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 109) {\r\n            result0 = \"m\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"m\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_movetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return createMoveTo( args, true ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_movetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, pair, list) { return [pair].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, pair) { return [pair]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_closepath() {\r\n        var result0;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        if (input.charCodeAt(pos) === 90) {\r\n          result0 = \"Z\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"Z\\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 122) {\r\n            result0 = \"z\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"z\\\"\");\r\n            }\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, command) { return { cmd: 'close' }; })(pos0, result0);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_lineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 76) {\r\n          result0 = \"L\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"L\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'lineTo', args: [ arg.x, arg.y ] }; } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 108) {\r\n            result0 = \"l\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"l\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_linetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'lineToRelative', args: [ arg.x, arg.y ] }; } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_linetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_horizontalLineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 72) {\r\n          result0 = \"H\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"H\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_horizontalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'horizontalLineTo', args: [ arg ] } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 104) {\r\n            result0 = \"h\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"h\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_horizontalLinetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'horizontalLineToRelative', args: [ arg ] } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_horizontalLinetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_horizontalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_number();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_verticalLineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 86) {\r\n          result0 = \"V\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"V\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_verticalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'verticalLineTo', args: [ arg ] } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 118) {\r\n            result0 = \"v\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"v\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_verticalLinetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'verticalLineToRelative', args: [ arg ] } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_verticalLinetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_verticalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_number();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_curveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 67) {\r\n          result0 = \"C\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"C\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_curvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'cubicCurveTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 99) {\r\n            result0 = \"c\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"c\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_curvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'cubicCurveToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_curvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_curvetoArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_curvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_curvetoArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_curvetoArgument() {\r\n        var result0, result1, result2, result3, result4;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_coordinatePair();\r\n            if (result2 !== null) {\r\n              result3 = parse_commaWsp();\r\n              result3 = result3 !== null ? result3 : \"\";\r\n              if (result3 !== null) {\r\n                result4 = parse_coordinatePair();\r\n                if (result4 !== null) {\r\n                  result0 = [result0, result1, result2, result3, result4];\r\n                } else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b, c) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })(pos0, result0[0], result0[2], result0[4]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 83) {\r\n          result0 = \"S\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"S\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 115) {\r\n            result0 = \"s\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"s\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_smoothCurvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_smoothCurvetoArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_smoothCurvetoArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothCurvetoArgument() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_coordinatePair();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [ a.x, a.y, b.x, b.y ]; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_quadraticBezierCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 81) {\r\n          result0 = \"Q\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"Q\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'quadraticCurveTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 113) {\r\n            result0 = \"q\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"q\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'quadraticCurveToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_quadraticBezierCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_quadraticBezierCurvetoArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_quadraticBezierCurvetoArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_quadraticBezierCurvetoArgument() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_coordinatePair();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [ a.x, a.y, b.x, b.y ]; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothQuadraticBezierCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 84) {\r\n          result0 = \"T\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"T\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveTo', args: [ arg.x, arg.y ] } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 116) {\r\n            result0 = \"t\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"t\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveToRelative', args: [ arg.x, arg.y ] } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_ellipticalArc() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 65) {\r\n          result0 = \"A\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"A\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_ellipticalArcArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'ellipticalArcTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 97) {\r\n            result0 = \"a\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"a\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_ellipticalArcArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'ellipticalArcToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_ellipticalArcArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_ellipticalArcArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_ellipticalArcArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_ellipticalArcArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_ellipticalArcArgument() {\r\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_nonnegativeNumber();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_nonnegativeNumber();\r\n            if (result2 !== null) {\r\n              result3 = parse_commaWsp();\r\n              result3 = result3 !== null ? result3 : \"\";\r\n              if (result3 !== null) {\r\n                result4 = parse_number();\r\n                if (result4 !== null) {\r\n                  result5 = parse_commaWsp();\r\n                  if (result5 !== null) {\r\n                    result6 = parse_flag();\r\n                    if (result6 !== null) {\r\n                      result7 = parse_commaWsp();\r\n                      result7 = result7 !== null ? result7 : \"\";\r\n                      if (result7 !== null) {\r\n                        result8 = parse_flag();\r\n                        if (result8 !== null) {\r\n                          result9 = parse_commaWsp();\r\n                          result9 = result9 !== null ? result9 : \"\";\r\n                          if (result9 !== null) {\r\n                            result10 = parse_coordinatePair();\r\n                            if (result10 !== null) {\r\n                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];\r\n                            } else {\r\n                              result0 = null;\r\n                              pos = pos1;\r\n                            }\r\n                          } else {\r\n                            result0 = null;\r\n                            pos = pos1;\r\n                          }\r\n                        } else {\r\n                          result0 = null;\r\n                          pos = pos1;\r\n                        }\r\n                      } else {\r\n                        result0 = null;\r\n                        pos = pos1;\r\n                      }\r\n                    } else {\r\n                      result0 = null;\r\n                      pos = pos1;\r\n                    }\r\n                  } else {\r\n                    result0 = null;\r\n                    pos = pos1;\r\n                  }\r\n                } else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, rx, ry, rot, largeArc, sweep, to) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })(pos0, result0[0], result0[2], result0[4], result0[6], result0[8], result0[10]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_coordinatePair() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_number();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return { x: a, y: b }; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_nonnegativeNumber() {\r\n        var result0;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        result0 = parse_floatingPointConstant();\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, number) { return parseFloat( number, 10 ); })(pos0, result0);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_digitSequence();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, number) { return parseInt( number, 10 ); })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_number() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_sign();\r\n        result0 = result0 !== null ? result0 : \"\";\r\n        if (result0 !== null) {\r\n          result1 = parse_floatingPointConstant();\r\n          if (result1 !== null) {\r\n            result0 = [result0, result1];\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, sign, number) { return parseFloat( sign + number, 10 ); })(pos0, result0[0], result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_sign();\r\n          result0 = result0 !== null ? result0 : \"\";\r\n          if (result0 !== null) {\r\n            result1 = parse_digitSequence();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, sign, number) { return parseInt( sign + number, 10 ); })(pos0, result0[0], result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_flag() {\r\n        var result0;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        if (input.charCodeAt(pos) === 48) {\r\n          result0 = \"0\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"0\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset) { return false; })(pos0);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          if (input.charCodeAt(pos) === 49) {\r\n            result0 = \"1\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"1\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset) { return true; })(pos0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_commaWsp() {\r\n        var result0, result1, result2, result3;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        result1 = parse_wsp();\r\n        if (result1 !== null) {\r\n          result0 = [];\r\n          while (result1 !== null) {\r\n            result0.push(result1);\r\n            result1 = parse_wsp();\r\n          }\r\n        } else {\r\n          result0 = null;\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = parse_comma();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = [];\r\n            result3 = parse_wsp();\r\n            while (result3 !== null) {\r\n              result2.push(result3);\r\n              result3 = parse_wsp();\r\n            }\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos0;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos0;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_comma();\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos0;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_comma() {\r\n        var result0;\r\n        \r\n        if (input.charCodeAt(pos) === 44) {\r\n          result0 = \",\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\",\\\"\");\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_floatingPointConstant() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_fractionalConstant();\r\n        if (result0 !== null) {\r\n          result1 = parse_exponent();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result0 = [result0, result1];\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_digitSequence();\r\n          if (result0 !== null) {\r\n            result1 = parse_exponent();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_fractionalConstant() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_digitSequence();\r\n        result0 = result0 !== null ? result0 : \"\";\r\n        if (result0 !== null) {\r\n          if (input.charCodeAt(pos) === 46) {\r\n            result1 = \".\";\r\n            pos++;\r\n          } else {\r\n            result1 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\".\\\"\");\r\n            }\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_digitSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a + '.' + b; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_digitSequence();\r\n          if (result0 !== null) {\r\n            if (input.charCodeAt(pos) === 46) {\r\n              result1 = \".\";\r\n              pos++;\r\n            } else {\r\n              result1 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"\\\".\\\"\");\r\n              }\r\n            }\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return a })(pos0, result0[0]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_exponent() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 101) {\r\n          result0 = \"e\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"e\\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 69) {\r\n            result0 = \"E\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"E\\\"\");\r\n            }\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = parse_sign();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_digitSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b, c) { return a + b + c; })(pos0, result0[0], result0[1], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_sign() {\r\n        var result0;\r\n        \r\n        if (input.charCodeAt(pos) === 43) {\r\n          result0 = \"+\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"+\\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 45) {\r\n            result0 = \"-\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"-\\\"\");\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_digitSequence() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_digit();\r\n        if (result0 !== null) {\r\n          result1 = parse_digitSequence();\r\n          if (result1 !== null) {\r\n            result0 = [result0, result1];\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          result0 = parse_digit();\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_digit() {\r\n        var result0;\r\n        \r\n        if (/^[0-9]/.test(input.charAt(pos))) {\r\n          result0 = input.charAt(pos);\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"[0-9]\");\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_wsp() {\r\n        var result0;\r\n        \r\n        if (input.charCodeAt(pos) === 32) {\r\n          result0 = \" \";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\" \\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 9) {\r\n            result0 = \"\\t\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"\\\\t\\\"\");\r\n            }\r\n          }\r\n          if (result0 === null) {\r\n            if (input.charCodeAt(pos) === 13) {\r\n              result0 = \"\\r\";\r\n              pos++;\r\n            } else {\r\n              result0 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"\\\"\\\\r\\\"\");\r\n              }\r\n            }\r\n            if (result0 === null) {\r\n              if (input.charCodeAt(pos) === 10) {\r\n                result0 = \"\\n\";\r\n                pos++;\r\n              } else {\r\n                result0 = null;\r\n                if (reportFailures === 0) {\r\n                  matchFailed(\"\\\"\\\\n\\\"\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      \r\n      function cleanupExpected(expected) {\r\n        expected.sort();\r\n        \r\n        var lastExpected = null;\r\n        var cleanExpected = [];\r\n        for (var i = 0; i < expected.length; i++) {\r\n          if (expected[i] !== lastExpected) {\r\n            cleanExpected.push(expected[i]);\r\n            lastExpected = expected[i];\r\n          }\r\n        }\r\n        return cleanExpected;\r\n      }\r\n      \r\n      function computeErrorPosition() {\r\n        /*\r\n         * The first idea was to use |String.split| to break the input up to the\r\n         * error position along newlines and derive the line and column from\r\n         * there. However IE's |split| implementation is so broken that it was\r\n         * enough to prevent it.\r\n         */\r\n        \r\n        var line = 1;\r\n        var column = 1;\r\n        var seenCR = false;\r\n        \r\n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\r\n          var ch = input.charAt(i);\r\n          if (ch === \"\\n\") {\r\n            if (!seenCR) { line++; }\r\n            column = 1;\r\n            seenCR = false;\r\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\r\n            line++;\r\n            column = 1;\r\n            seenCR = true;\r\n          } else {\r\n            column++;\r\n            seenCR = false;\r\n          }\r\n        }\r\n        \r\n        return { line: line, column: column };\r\n      }\r\n      \r\n      \r\n        function createMoveTo( args, isRelative ) {\r\n          var result = [ {\r\n            cmd: isRelative ? 'moveToRelative' : 'moveTo',\r\n            args: [ args[0].x, args[0].y ]\r\n          } ];\r\n          \r\n          // any other coordinate pairs are implicit lineTos\r\n          if ( args.length > 1 ) {\r\n            for ( var i = 1; i < args.length; i++ ) {\r\n              result.push( {\r\n                cmd: isRelative ? 'lineToRelative' : 'lineTo',\r\n                args: [ args[i].x, args[i].y ]\r\n              } );\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n      \r\n      var result = parseFunctions[startRule]();\r\n      \r\n      /*\r\n       * The parser is now in one of the following three states:\r\n       *\r\n       * 1. The parser successfully parsed the whole input.\r\n       *\r\n       *    - |result !== null|\r\n       *    - |pos === input.length|\r\n       *    - |rightmostFailuresExpected| may or may not contain something\r\n       *\r\n       * 2. The parser successfully parsed only a part of the input.\r\n       *\r\n       *    - |result !== null|\r\n       *    - |pos < input.length|\r\n       *    - |rightmostFailuresExpected| may or may not contain something\r\n       *\r\n       * 3. The parser did not successfully parse any part of the input.\r\n       *\r\n       *   - |result === null|\r\n       *   - |pos === 0|\r\n       *   - |rightmostFailuresExpected| contains at least one failure\r\n       *\r\n       * All code following this comment (including called functions) must\r\n       * handle these states.\r\n       */\r\n      if (result === null || pos !== input.length) {\r\n        var offset = Math.max(pos, rightmostFailuresPos);\r\n        var found = offset < input.length ? input.charAt(offset) : null;\r\n        var errorPosition = computeErrorPosition();\r\n        \r\n        throw new this.SyntaxError(\r\n          cleanupExpected(rightmostFailuresExpected),\r\n          found,\r\n          offset,\r\n          errorPosition.line,\r\n          errorPosition.column\r\n        );\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    /* Returns the parser source code. */\r\n    toSource: function() { return this._source; }\r\n  };\r\n  var result = kite.svgPath;\r\n  \r\n  /* Thrown when a parser encounters a syntax error. */\r\n  \r\n  result.SyntaxError = function(expected, found, offset, line, column) {\r\n    function buildMessage(expected, found) {\r\n      var expectedHumanized, foundHumanized;\r\n      \r\n      switch (expected.length) {\r\n        case 0:\r\n          expectedHumanized = \"end of input\";\r\n          break;\r\n        case 1:\r\n          expectedHumanized = expected[0];\r\n          break;\r\n        default:\r\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\r\n            + \" or \"\r\n            + expected[expected.length - 1];\r\n      }\r\n      \r\n      foundHumanized = found ? quote(found) : \"end of input\";\r\n      \r\n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\r\n    }\r\n    \r\n    this.name = \"SyntaxError\";\r\n    this.expected = expected;\r\n    this.found = found;\r\n    this.message = buildMessage(expected, found);\r\n    this.offset = offset;\r\n    this.line = line;\r\n    this.column = column;\r\n  };\r\n  \r\n  result.SyntaxError.prototype = Error.prototype;\r\n  \r\n  return result;\r\n});\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Styles needed to determine a stroked line shape.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/util/LineStyles',['require','ASSERT/assert','KITE/kite'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  kite.LineStyles = function( args ) {\r\n    if ( args === undefined ) {\r\n      args = {};\r\n    }\r\n    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;\r\n    this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square\r\n    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel\r\n    this.lineDash = args.lineDash !== undefined ? args.lineDash : null; // null is default, otherwise an array of numbers\r\n    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number\r\n    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations\r\n  };\r\n  var LineStyles = kite.LineStyles;\r\n  LineStyles.prototype = {\r\n    constructor: LineStyles,\r\n    \r\n    equals: function( other ) {\r\n      var typical = this.lineWidth === other.lineWidth &&\r\n                    this.lineCap === other.lineCap &&\r\n                    this.lineJoin === other.lineJoin &&\r\n                    this.miterLimit === other.miterLimit &&\r\n                    this.lineDashOffset === other.lineDashOffset;\r\n      if ( !typical ) {\r\n        return false;\r\n      }\r\n      \r\n      // now we need to compare the line dashes\r\n      /* jshint -W018 */\r\n      //jshint -W018\r\n      if ( !this.lineDash !== !other.lineDash ) {\r\n        // one is defined, the other is not\r\n        return false;\r\n      }\r\n      \r\n      if ( this.lineDash ) {\r\n        if ( this.lineDash.length !== other.lineDash.length ) {\r\n          return false;\r\n        }\r\n        for ( var i = 0; i < this.lineDash.length; i++ ) {\r\n          if ( this.lineDash[i] !== other.lineDash[i] ) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      } else {\r\n        // both have no line dash, so they are equal\r\n        return true;\r\n      }\r\n    }\r\n  };\r\n  \r\n  return kite.LineStyles;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Quadratic Bezier segment\r\n *\r\n * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Quadratic',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;\r\n\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Quadratic = function Quadratic( start, control, end, skipComputations ) {\r\n    this.start = start;\r\n    this.control = control;\r\n    this.end = end;\r\n    \r\n    if ( start.equals( end ) && start.equals( control ) ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    var t;\r\n    \r\n    // allows us to skip unnecessary computation in the subdivision steps\r\n    if ( skipComputations ) {\r\n      return;\r\n    }\r\n    \r\n    var controlIsStart = start.equals( control );\r\n    var controlIsEnd = end.equals( control );\r\n    // ensure the points are distinct\r\n    assert && assert( !controlIsStart || !controlIsEnd );\r\n    \r\n    // allow either the start or end point to be the same as the control point (necessary if you do a quadraticCurveTo on an empty path)\r\n    // tangents go through the control point, which simplifies things\r\n    this.startTangent = controlIsStart ? end.minus( start ).normalized() : control.minus( start ).normalized();\r\n    this.endTangent = controlIsEnd ? end.minus( start ).normalized() : end.minus( control ).normalized();\r\n    \r\n    // calculate our temporary guaranteed lower bounds based on the end points\r\n    this.bounds = new Bounds2( Math.min( start.x, end.x ), Math.min( start.y, end.y ), Math.max( start.x, end.x ), Math.max( start.y, end.y ) );\r\n    \r\n    // compute x and y where the derivative is 0, so we can include this in the bounds\r\n    var divisorX = 2 * ( end.x - 2 * control.x + start.x );\r\n    if ( divisorX !== 0 ) {\r\n      this.tCriticalX = -2 * ( control.x - start.x ) / divisorX;\r\n      \r\n      if ( t > 0 && t < 1 ) {\r\n        this.bounds = this.bounds.withPoint( this.positionAt( this.tCriticalX ) );\r\n      }\r\n    }\r\n    var divisorY = 2 * ( end.y - 2 * control.y + start.y );\r\n    if ( divisorY !== 0 ) {\r\n      this.tCriticalY = -2 * ( control.y - start.y ) / divisorY;\r\n      \r\n      if ( t > 0 && t < 1 ) {\r\n        this.bounds = this.bounds.withPoint( this.positionAt( this.tCriticalY ) );\r\n      }\r\n    }\r\n  };\r\n  inherit( Segment, Segment.Quadratic, {\r\n    \r\n    degree: 2,\r\n    \r\n    // can be described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end\r\n    positionAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this.start.times( mt * mt ).plus( this.control.times( 2 * mt * t ) ).plus( this.end.times( t * t ) );\r\n    },\r\n    \r\n    // derivative: 2(1-t)( control - start ) + 2t( end - control )\r\n    tangentAt: function( t ) {\r\n      return this.control.minus( this.start ).times( 2 * ( 1 - t ) ).plus( this.end.minus( this.control ).times( 2 * t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31\r\n      // TODO: remove code duplication with Cubic\r\n      var epsilon = 0.0000001;\r\n      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {\r\n        var isZero = t < 0.5;\r\n        var p0 = isZero ? this.start : this.end;\r\n        var p1 = this.control;\r\n        var p2 = isZero ? this.end : this.start;\r\n        var d10 = p1.minus( p0 );\r\n        var a = d10.magnitude();\r\n        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );\r\n        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );\r\n      } else {\r\n        return this.subdivided( t, true )[0].curvatureAt( 1 );\r\n      }\r\n    },\r\n    \r\n    // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf\r\n    // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length\r\n    \r\n    offsetTo: function( r, reverse ) {\r\n      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html\r\n      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      var curves = [this];\r\n      \r\n      // subdivide this curve\r\n      var depth = 5; // generates 2^depth curves\r\n      for ( var i = 0; i < depth; i++ ) {\r\n        curves = _.flatten( _.map( curves, function( curve ) {\r\n          return curve.subdivided( 0.5, true );\r\n        } ));\r\n      }\r\n      \r\n      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );\r\n      \r\n      if ( reverse ) {\r\n        offsetCurves.reverse();\r\n        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );\r\n      }\r\n      \r\n      return offsetCurves;\r\n    },\r\n    \r\n    subdivided: function( t, skipComputations ) {\r\n      // de Casteljau method\r\n      var leftMid = this.start.blend( this.control, t );\r\n      var rightMid = this.control.blend( this.end, t );\r\n      var mid = leftMid.blend( rightMid, t );\r\n      return [\r\n        new Segment.Quadratic( this.start, leftMid, mid, skipComputations ),\r\n        new Segment.Quadratic( mid, rightMid, this.end, skipComputations )\r\n      ];\r\n    },\r\n    \r\n    reversed: function( skipComputations ) {\r\n      return new Segment.Quadratic( this.end, this.control, this.start );\r\n    },\r\n    \r\n    approximateOffset: function( r ) {\r\n      return new Segment.Quadratic(\r\n        this.start.plus( ( this.start.equals( this.control ) ? this.end.minus( this.start ) : this.control.minus( this.start ) ).perpendicular().normalized().times( r ) ),\r\n        this.control.plus( this.end.minus( this.start ).perpendicular().normalized().times( r ) ),\r\n        this.end.plus( ( this.end.equals( this.control ) ? this.end.minus( this.start ) : this.end.minus( this.control ) ).perpendicular().normalized().times( r ) )\r\n      );\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      return 'Q ' + this.control.x + ' ' + this.control.y + ' ' + this.end.x + ' ' + this.end.y;\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n    \r\n    getInteriorExtremaTs: function() {\r\n      var result = [];\r\n      var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n      if ( this.tCriticalX !== undefined && this.tCriticalX > epsilon && this.tCriticalX < 1 - epsilon ) {\r\n        result.push( this.tCriticalX );\r\n      }\r\n      if ( this.tCriticalY !== undefined && this.tCriticalY > epsilon && this.tCriticalY < 1 - epsilon ) {\r\n        result.push( this.tCriticalY );\r\n      }\r\n      return result.sort();\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Quadratic.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    intersection: function( ray ) {\r\n      var self = this;\r\n      var result = [];\r\n      \r\n      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );\r\n      \r\n      var p0 = inverseMatrix.timesVector2( this.start );\r\n      var p1 = inverseMatrix.timesVector2( this.control );\r\n      var p2 = inverseMatrix.timesVector2( this.end );\r\n      \r\n      //(1-t)^2 start + 2(1-t)t control + t^2 end\r\n      var a = p0.y - 2 * p1.y + p2.y;\r\n      var b = -2 * p0.y + 2 * p1.y;\r\n      var c = p0.y;\r\n      \r\n      var ts = solveQuadraticRootsReal( a, b, c );\r\n      \r\n      _.each( ts, function( t ) {\r\n        if ( t >= 0 && t <= 1 ) {\r\n          var hitPoint = self.positionAt( t );\r\n          var unitTangent = self.tangentAt( t ).normalized();\r\n          var perp = unitTangent.perpendicular();\r\n          var toHit = hitPoint.minus( ray.pos );\r\n          \r\n          // make sure it's not behind the ray\r\n          if ( toHit.dot( ray.dir ) > 0 ) {\r\n            result.push( {\r\n              distance: toHit.magnitude(),\r\n              point: hitPoint,\r\n              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return result;\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.quadraticCurveTo( this.control.x, this.control.y, this.end.x, this.end.y );\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Segment.Quadratic( matrix.timesVector2( this.start ), matrix.timesVector2( this.control ), matrix.timesVector2( this.end ) );\r\n    }\r\n  } );\r\n  \r\n  return Segment.Quadratic;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Cubic Bezier segment.\r\n *\r\n * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info\r\n *\r\n * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Cubic',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;\r\n  var solveCubicRootsReal = require( 'DOT/Util' ).solveCubicRootsReal;\r\n  \r\n  var Segment = require( 'KITE/segments/Segment' );\r\n  require( 'KITE/segments/Quadratic' );\r\n\r\n  Segment.Cubic = function Cubic( start, control1, control2, end, skipComputations ) {\r\n    this.start = start;\r\n    this.control1 = control1;\r\n    this.control2 = control2;\r\n    this.end = end;\r\n    \r\n    // allows us to skip unnecessary computation in the subdivision steps\r\n    if ( skipComputations ) {\r\n      return;\r\n    }\r\n    \r\n    if ( start.equals( end, 0 ) && start.equals( control1, 0 ) && start.equals( control2, 0 ) ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    this.startTangent = this.tangentAt( 0 ).normalized();\r\n    this.endTangent = this.tangentAt( 1 ).normalized();\r\n    \r\n    // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n    this.r = control1.minus( start ).normalized();\r\n    this.s = this.r.perpendicular();\r\n    \r\n    var a = start.times( -1 ).plus( control1.times( 3 ) ).plus( control2.times( -3 ) ).plus( end );\r\n    var b = start.times( 3 ).plus( control1.times( -6 ) ).plus( control2.times( 3 ) );\r\n    var c = start.times( -3 ).plus( control1.times( 3 ) );\r\n    var d = start;\r\n    \r\n    var aPerp = a.perpendicular();\r\n    var bPerp = b.perpendicular();\r\n    var aPerpDotB = aPerp.dot( b );\r\n    \r\n    this.tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB );\r\n    this.tDeterminant = this.tCusp * this.tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB );\r\n    if ( this.tDeterminant >= 0 ) {\r\n      var sqrtDet = Math.sqrt( this.tDeterminant );\r\n      this.tInflection1 = this.tCusp - sqrtDet;\r\n      this.tInflection2 = this.tCusp + sqrtDet;\r\n    }\r\n    \r\n    if ( this.hasCusp() ) {\r\n      // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.\r\n      // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)\r\n      var subdividedAtCusp = this.subdivided( this.tCusp, true );\r\n      this.startQuadratic = new Segment.Quadratic( subdividedAtCusp[0].start, subdividedAtCusp[0].control1, subdividedAtCusp[0].end, false );\r\n      this.endQuadratic = new Segment.Quadratic( subdividedAtCusp[1].start, subdividedAtCusp[1].control2, subdividedAtCusp[1].end, false );\r\n    }\r\n    \r\n    this.bounds = Bounds2.NOTHING;\r\n    this.bounds = this.bounds.withPoint( this.start );\r\n    this.bounds = this.bounds.withPoint( this.end );\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Bounds\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // finds what t values the cubic extrema are at (if any).\r\n    function extremaT( v0, v1, v2, v3 ) {\r\n      // coefficients of derivative\r\n      var a = -3 * v0 + 9 * v1 -9 * v2 + 3 * v3;\r\n      var b =  6 * v0 - 12 * v1 + 6 * v2;\r\n      var c = -3 * v0 + 3 * v1;\r\n      \r\n      return solveQuadraticRootsReal( a, b, c );\r\n    }\r\n    \r\n    var cubic = this;\r\n    this.xExtremaT = extremaT( this.start.x, this.control1.x, this.control2.x, this.end.x );\r\n    _.each( this.xExtremaT, function( t ) {\r\n      if ( t >= 0 && t <= 1 ) {\r\n        cubic.bounds = cubic.bounds.withPoint( cubic.positionAt( t ) );\r\n      }\r\n    } );\r\n    this.yExtremaT = extremaT( this.start.y, this.control1.y, this.control2.y, this.end.y );\r\n    _.each( this.yExtremaT, function( t ) {\r\n      if ( t >= 0 && t <= 1 ) {\r\n        cubic.bounds = cubic.bounds.withPoint( cubic.positionAt( t ) );\r\n      }\r\n    } );\r\n    \r\n    if ( this.hasCusp() ) {\r\n      this.bounds = this.bounds.withPoint( this.positionAt( this.tCusp ) );\r\n    }\r\n  };\r\n  inherit( Segment, Segment.Cubic, {\r\n    \r\n    degree: 3,\r\n    \r\n    hasCusp: function() {\r\n      var epsilon = 0.000001; // TODO: make this available to change?\r\n      return this.tangentAt( this.tCusp ).magnitude() < epsilon && this.tCusp >= 0 && this.tCusp <= 1;\r\n    },\r\n    \r\n    // position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end\r\n    positionAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this.start.times( mt * mt * mt ).plus( this.control1.times( 3 * mt * mt * t ) ).plus( this.control2.times( 3 * mt * t * t ) ).plus( this.end.times( t * t * t ) );\r\n    },\r\n    \r\n    // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2\r\n    tangentAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this.start.times( -3 * mt * mt ).plus( this.control1.times( 3 * mt * mt - 6 * mt * t ) ).plus( this.control2.times( 6 * mt * t - 3 * t * t ) ).plus( this.end.times( 3 * t * t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31\r\n      // TODO: remove code duplication with Quadratic\r\n      var epsilon = 0.0000001;\r\n      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {\r\n        var isZero = t < 0.5;\r\n        var p0 = isZero ? this.start : this.end;\r\n        var p1 = isZero ? this.control1 : this.control2;\r\n        var p2 = isZero ? this.control2 : this.control1;\r\n        var d10 = p1.minus( p0 );\r\n        var a = d10.magnitude();\r\n        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );\r\n        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );\r\n      } else {\r\n        return this.subdivided( t, true )[0].curvatureAt( 1 );\r\n      }\r\n    },\r\n    \r\n    toRS: function( point ) {\r\n      var firstVector = point.minus( this.start );\r\n      return new Vector2( firstVector.dot( this.r ), firstVector.dot( this.s ) );\r\n    },\r\n    \r\n    subdivided: function( t, skipComputations ) {\r\n      // de Casteljau method\r\n      // TODO: add a 'bisect' or 'between' method for vectors?\r\n      var left = this.start.blend( this.control1, t );\r\n      var right = this.control2.blend( this.end, t );\r\n      var middle = this.control1.blend( this.control2, t );\r\n      var leftMid = left.blend( middle, t );\r\n      var rightMid = middle.blend( right, t );\r\n      var mid = leftMid.blend( rightMid, t );\r\n      return [\r\n        new Segment.Cubic( this.start, left, leftMid, mid, skipComputations ),\r\n        new Segment.Cubic( mid, rightMid, right, this.end, skipComputations )\r\n      ];\r\n    },\r\n    \r\n    offsetTo: function( r, reverse ) {\r\n      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html\r\n      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      \r\n      // how many segments to create (possibly make this more adaptive?)\r\n      var quantity = 32;\r\n      \r\n      var points = [];\r\n      var result = [];\r\n      for ( var i = 0; i < quantity; i++ ) {\r\n        var t = i / ( quantity - 1 );\r\n        if ( reverse ) {\r\n          t = 1 - t;\r\n        }\r\n        \r\n        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );\r\n        if ( i > 0 ) {\r\n          result.push( new Segment.Line( points[i-1], points[i] ) );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      return 'C ' + this.control1.x + ' ' + this.control1.y + ' ' + this.control2.x + ' ' + this.control2.y + ' ' + this.end.x + ' ' + this.end.y;\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n    \r\n    getInteriorExtremaTs: function() {\r\n      var ts = this.xExtremaT.concat( this.yExtremaT );\r\n      var result = [];\r\n      _.each( ts, function( t ) {\r\n        var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n        if ( t > epsilon && t < 1 - epsilon ) {\r\n          // don't add duplicate t values\r\n          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort();\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Cubic.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    intersection: function( ray ) {\r\n      var self = this;\r\n      var result = [];\r\n      \r\n      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );\r\n      \r\n      var p0 = inverseMatrix.timesVector2( this.start );\r\n      var p1 = inverseMatrix.timesVector2( this.control1 );\r\n      var p2 = inverseMatrix.timesVector2( this.control2 );\r\n      var p3 = inverseMatrix.timesVector2( this.end );\r\n      \r\n      // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3\r\n      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;\r\n      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;\r\n      var c = -3 * p0.y + 3 * p1.y;\r\n      var d = p0.y;\r\n      \r\n      var ts = solveCubicRootsReal( a, b, c, d );\r\n      \r\n      _.each( ts, function( t ) {\r\n        if ( t >= 0 && t <= 1 ) {\r\n          var hitPoint = self.positionAt( t );\r\n          var unitTangent = self.tangentAt( t ).normalized();\r\n          var perp = unitTangent.perpendicular();\r\n          var toHit = hitPoint.minus( ray.pos );\r\n          \r\n          // make sure it's not behind the ray\r\n          if ( toHit.dot( ray.dir ) > 0 ) {\r\n            result.push( {\r\n              distance: toHit.magnitude(),\r\n              point: hitPoint,\r\n              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return result;\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.bezierCurveTo( this.control1.x, this.control1.y, this.control2.x, this.control2.y, this.end.x, this.end.y );\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Segment.Cubic( matrix.timesVector2( this.start ), matrix.timesVector2( this.control1 ), matrix.timesVector2( this.control2 ), matrix.timesVector2( this.end ) );\r\n    }\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    // windingIntersection: function( ray ) {\r\n    //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n    //   var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() );\r\n    //   assert && assert( inverseMatrix.timesVector2( ray.dir ).x > 0.99 ); // verify that we transform the unit vector to the x-unit\r\n      \r\n    //   var y0 = inverseMatrix.timesVector2( this.start ).y;\r\n    //   var y1 = inverseMatrix.timesVector2( this.control1 ).y;\r\n    //   var y2 = inverseMatrix.timesVector2( this.control2 ).y;\r\n    //   var y3 = inverseMatrix.timesVector2( this.end ).y;\r\n      \r\n    //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3\r\n    //   var a = -y0 + 3 * y1 - 3 * y2 + y3;\r\n    //   var b = 3 * y0 - 6 * y1 + 3 * y2;\r\n    //   var c = -3 * y0 + 3 * y1;\r\n    //   var d = y0;\r\n      \r\n    //   // solve cubic roots\r\n    //   var ts = solveCubicRootsReal( a, b, c, d );\r\n      \r\n    //   var result = 0;\r\n      \r\n    //   // for each hit\r\n    //   _.each( ts, function( t ) {\r\n    //     if ( t >= 0 && t <= 1 ) {\r\n    //       result += ray.dir.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;\r\n    //     }\r\n    //   } );\r\n      \r\n    //   return result;\r\n    // }\r\n  } );\r\n  \r\n  return Segment.Cubic;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Elliptical arc segment\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/EllipticalArc',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/util/Subpath'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var toDegrees = require( 'DOT/Util' ).toDegrees;\r\n  var DotUtil = require( 'DOT/Util' );\r\n\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n  require( 'KITE/util/Subpath' );\r\n\r\n  // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n  // Canvas notes at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse\r\n  Segment.EllipticalArc = function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n    if ( radiusX < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radiusX = -radiusX;\r\n      startAngle = Math.PI - startAngle;\r\n      endAngle = Math.PI - endAngle;\r\n      anticlockwise = !anticlockwise;\r\n    }\r\n    if ( radiusY < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radiusY = -radiusY;\r\n      startAngle = -startAngle;\r\n      endAngle = -endAngle;\r\n      anticlockwise = !anticlockwise;\r\n    }\r\n    if ( radiusX < radiusY ) {\r\n      // swap radiusX and radiusY internally for consistent Canvas / SVG output\r\n      rotation += Math.PI / 2;\r\n      startAngle -= Math.PI / 2;\r\n      endAngle -= Math.PI / 2;\r\n      \r\n      // swap radiusX and radiusY\r\n      var tmpR = radiusX;\r\n      radiusX = radiusY;\r\n      radiusY = tmpR;\r\n    }\r\n    \r\n    this.center = center;\r\n    this.radiusX = radiusX;\r\n    this.radiusY = radiusY;\r\n    this.rotation = rotation;\r\n    this.startAngle = startAngle;\r\n    this.endAngle = endAngle;\r\n    this.anticlockwise = anticlockwise;\r\n    \r\n    this.unitTransform = Segment.EllipticalArc.computeUnitTransform( center, radiusX, radiusY, rotation );\r\n    \r\n    this.start = this.positionAtAngle( startAngle );\r\n    this.end = this.positionAtAngle( endAngle );\r\n    this.startTangent = this.tangentAtAngle( startAngle ).normalized();\r\n    this.endTangent = this.tangentAtAngle( endAngle ).normalized();\r\n    \r\n    if ( radiusX === 0 || radiusY === 0 || startAngle === endAngle ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    if ( radiusX < radiusY ) {\r\n      // TODO: check this\r\n      throw new Error( 'Not verified to work if radiusX < radiusY' );\r\n    }\r\n    \r\n    // compute an actual end angle so that we can smoothly go from this.startAngle to this.actualEndAngle\r\n    if ( this.anticlockwise ) {\r\n      // angle is 'decreasing'\r\n      // -2pi <= end - start < 2pi\r\n      if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle - 2 * Math.PI;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    } else {\r\n      // angle is 'increasing'\r\n      // -2pi < end - start <= 2pi\r\n      if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle + Math.PI * 2;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    }\r\n    \r\n    // constraints shared with Segment.Arc\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );\r\n    \r\n    var isFullPerimeter = ( !anticlockwise && endAngle - startAngle >= Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle >= Math.PI * 2 );\r\n    \r\n    // compute an angle difference that represents how \"much\" of the circle our arc covers\r\n    this.angleDifference = this.anticlockwise ? this.startAngle - this.endAngle : this.endAngle - this.startAngle;\r\n    if ( this.angleDifference < 0 ) {\r\n      this.angleDifference += Math.PI * 2;\r\n    }\r\n    assert && assert( this.angleDifference >= 0 ); // now it should always be zero or positive\r\n    \r\n    // a unit arg segment that we can map to our ellipse. useful for hit testing and such.\r\n    this.unitArcSegment = new Segment.Arc( Vector2.ZERO, 1, startAngle, endAngle, anticlockwise );\r\n    \r\n    this.bounds = Bounds2.NOTHING;\r\n    this.bounds = this.bounds.withPoint( this.start );\r\n    this.bounds = this.bounds.withPoint( this.end );\r\n    \r\n    // for bounds computations\r\n    var that = this;\r\n    function boundsAtAngle( angle ) {\r\n      if ( that.containsAngle( angle ) ) {\r\n        // the boundary point is in the arc\r\n        that.bounds = that.bounds.withPoint( that.positionAtAngle( angle ) );\r\n      }\r\n    }\r\n    \r\n    // if the angles are different, check extrema points\r\n    if ( startAngle !== endAngle ) {\r\n      // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.\r\n      // we find one extrema point for both x and y, since the other two are just rotated by pi from them.\r\n      var xAngle = Math.atan( -( radiusY / radiusX ) * Math.tan( rotation ) );\r\n      var yAngle = Math.atan( ( radiusY / radiusX ) / Math.tan( rotation ) );\r\n      \r\n      // check all of the extrema points\r\n      this.possibleExtremaAngles = [\r\n        xAngle,\r\n        xAngle + Math.PI,\r\n        yAngle,\r\n        yAngle + Math.PI\r\n      ];\r\n      \r\n      _.each( this.possibleExtremaAngles, boundsAtAngle );\r\n    }\r\n  };\r\n  inherit( Segment, Segment.EllipticalArc, {\r\n    \r\n    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.\r\n    mapAngle: function( angle ) {\r\n      // consider an assert that we contain that angle?\r\n      return ( this.startAngle > this.actualEndAngle ) ?\r\n             DotUtil.moduloBetweenUp( angle, this.startAngle - 2 * Math.PI, this.startAngle ) :\r\n             DotUtil.moduloBetweenDown( angle, this.startAngle, this.startAngle + 2 * Math.PI );\r\n    },\r\n    \r\n    tAtAngle: function( angle ) {\r\n      return ( this.mapAngle( angle ) - this.startAngle ) / ( this.actualEndAngle - this.startAngle );\r\n    },\r\n    \r\n    angleAt: function( t ) {\r\n      return this.startAngle + ( this.actualEndAngle - this.startAngle ) * t;\r\n    },\r\n    \r\n    positionAt: function( t ) {\r\n      return this.positionAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    tangentAt: function( t ) {\r\n      return this.tangentAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      // see http://mathworld.wolfram.com/Ellipse.html (59)\r\n      var angle = this.angleAt( t );\r\n      var aq = this.radiusX * Math.sin( angle );\r\n      var bq = this.radiusY * Math.cos( angle );\r\n      var denominator = Math.pow( bq * bq + aq * aq, 3/2 );\r\n      return ( this.anticlockwise ? -1 : 1 ) * this.radiusX * this.radiusY / denominator;\r\n    },\r\n    \r\n    positionAtAngle: function( angle ) {\r\n      return this.unitTransform.transformPosition2( Vector2.createPolar( 1, angle ) );\r\n    },\r\n    \r\n    tangentAtAngle: function( angle ) {\r\n      var normal = this.unitTransform.transformNormal2( Vector2.createPolar( 1, angle ) );\r\n      \r\n      return this.anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();\r\n    },\r\n    \r\n    // TODO: refactor? exact same as Segment.Arc\r\n    containsAngle: function( angle ) {\r\n      // transform the angle into the appropriate coordinate form\r\n      // TODO: check anticlockwise version!\r\n      var normalizedAngle = this.anticlockwise ? angle - this.endAngle : angle - this.startAngle;\r\n      \r\n      // get the angle between 0 and 2pi\r\n      var positiveMinAngle = normalizedAngle % ( Math.PI * 2 );\r\n      // check this because modular arithmetic with negative numbers reveal a negative number\r\n      if ( positiveMinAngle < 0 ) {\r\n        positiveMinAngle += Math.PI * 2;\r\n      }\r\n      \r\n      return positiveMinAngle <= this.angleDifference;\r\n    },\r\n    \r\n    // discretizes the elliptical arc and returns an offset curve as a list of lineTos\r\n    offsetTo: function( r, reverse ) {\r\n      // how many segments to create (possibly make this more adaptive?)\r\n      var quantity = 32;\r\n      \r\n      var points = [];\r\n      var result = [];\r\n      for ( var i = 0; i < quantity; i++ ) {\r\n        var ratio = i / ( quantity - 1 );\r\n        if ( reverse ) {\r\n          ratio = 1 - ratio;\r\n        }\r\n        var angle = this.angleAt( ratio );\r\n        \r\n        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );\r\n        if ( i > 0 ) {\r\n          result.push( new Segment.Line( points[i-1], points[i] ) );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info\r\n      // rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'\r\n      var sweepFlag = this.anticlockwise ? '0' : '1';\r\n      var largeArcFlag;\r\n      var degreesRotation = toDegrees( this.rotation ); // bleh, degrees?\r\n      if ( this.angleDifference < Math.PI * 2 - epsilon ) {\r\n        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';\r\n        return 'A ' + this.radiusX + ' ' + this.radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n      } else {\r\n        // ellipse (or almost-ellipse) case needs to be handled differently\r\n        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs\r\n        \r\n        // get the angle that is between and opposite of both of the points\r\n        var splitOppositeAngle = ( this.startAngle + this.endAngle ) / 2; // this _should_ work for the modular case?\r\n        var splitPoint = this.positionAtAngle( splitOppositeAngle );\r\n        \r\n        largeArcFlag = '0'; // since we split it in 2, it's always the small arc\r\n        \r\n        var firstArc = 'A ' + this.radiusX + ' ' + this.radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;\r\n        var secondArc = 'A ' + this.radiusX + ' ' + this.radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n        \r\n        return firstArc + ' ' + secondArc;\r\n      }\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n    \r\n    // not including 0 and 1\r\n    getInteriorExtremaTs: function() {\r\n      var that = this;\r\n      var result = [];\r\n      _.each( this.possibleExtremaAngles, function( angle ) {\r\n        if ( that.containsAngle( angle ) ) {\r\n          var t = that.tAtAngle( angle );\r\n          var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n          if ( t > epsilon && t < 1 - epsilon ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort(); // modifies original, which is OK\r\n    },\r\n    \r\n    subdivided: function( t ) {\r\n      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles\r\n      var angle0 = this.angleAt( 0 );\r\n      var angleT = this.angleAt( t );\r\n      var angle1 = this.angleAt( 1 );\r\n      return [\r\n        new Segment.EllipticalArc( this.center, this.radiusX, this.radiusY, this.rotation, angle0, angleT, this.anticlockwise ),\r\n        new Segment.EllipticalArc( this.center, this.radiusX, this.radiusY, this.rotation, angleT, angle1, this.anticlockwise )\r\n      ];\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.EllipticalArc.intersectsBounds unimplemented' );\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      // be lazy. transform it into the space of a non-elliptical arc.\r\n      var unitTransform = this.unitTransform;\r\n      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );\r\n      var hits = this.unitArcSegment.intersection( rayInUnitCircleSpace );\r\n      \r\n      return _.map( hits, function( hit ) {\r\n        var transformedPoint = unitTransform.transformPosition2( hit.point );\r\n        return {\r\n          distance: ray.pos.distance( transformedPoint ),\r\n          point: transformedPoint,\r\n          normal: unitTransform.inverseNormal2( hit.normal ),\r\n          wind: hit.wind\r\n        };\r\n      } );\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      // be lazy. transform it into the space of a non-elliptical arc.\r\n      var rayInUnitCircleSpace = this.unitTransform.inverseRay2( ray );\r\n      return this.unitArcSegment.windingIntersection( rayInUnitCircleSpace );\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      if ( context.ellipse ) {\r\n        context.ellipse( this.center.x, this.center.y, this.radiusX, this.radiusY, this.rotation, this.startAngle, this.endAngle, this.anticlockwise );\r\n      } else {\r\n        // fake the ellipse call by using transforms\r\n        this.unitTransform.getMatrix().canvasAppendTransform( context );\r\n        context.arc( 0, 0, 1, this.startAngle, this.endAngle, this.anticlockwise );\r\n        this.unitTransform.getInverse().canvasAppendTransform( context );\r\n      }\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this.radiusX, this.rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );\r\n      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this.radiusY, this.rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );\r\n      var rotation = transformedSemiMajorAxis.angle();\r\n      var radiusX = transformedSemiMajorAxis.magnitude();\r\n      var radiusY = transformedSemiMinorAxis.magnitude();\r\n      \r\n      var reflected = matrix.getDeterminant() < 0;\r\n      \r\n      // reverse the 'clockwiseness' if our transform includes a reflection\r\n      // TODO: check reflections. swapping angle signs should fix clockwiseness\r\n      var anticlockwise = reflected ? !this.anticlockwise : this.anticlockwise;\r\n      var startAngle = reflected ? -this.startAngle : this.startAngle;\r\n      var endAngle = reflected ? -this.endAngle : this.endAngle;\r\n      \r\n      return new Segment.EllipticalArc( matrix.timesVector2( this.center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n    }\r\n  } );\r\n  \r\n  // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n  // transforms the unit circle onto our ellipse\r\n  Segment.EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {\r\n    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this.center) when available\r\n                                  .timesMatrix( Matrix3.rotation2( rotation ) )\r\n                                  .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );\r\n  };\r\n  \r\n  return Segment.EllipticalArc;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Shape handling\r\n *\r\n * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.\r\n * Familiarity with how Canvas handles subpaths is helpful for understanding this code.\r\n *\r\n * Canvas spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html\r\n * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html\r\n *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)\r\n * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html\r\n *\r\n * TODO: add nonzero / evenodd support when browsers support it\r\n * TODO: docs\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/Shape',['require','ASSERT/assert','ASSERT/assert','KITE/kite','DOT/Vector2','DOT/Bounds2','DOT/Ray2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/util/Subpath','KITE/../parser/svgPath','KITE/util/LineStyles','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  var assertExtra = require( 'ASSERT/assert' )( 'kite.extra', true );\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  // TODO: clean up imports\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Ray2 = require( 'DOT/Ray2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var toDegrees = require( 'DOT/Util' ).toDegrees;\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var Subpath = require( 'KITE/util/Subpath' );\r\n  \r\n  var svgPath = require( 'KITE/../parser/svgPath' );\r\n  require( 'KITE/util/LineStyles' );\r\n  require( 'KITE/segments/Arc' );\r\n  require( 'KITE/segments/Cubic' );\r\n  require( 'KITE/segments/EllipticalArc' );\r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Quadratic' );\r\n  \r\n  // for brevity\r\n  function p( x,y ) { return new Vector2( x, y ); }\r\n  function v( x,y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type\r\n  \r\n  // a normalized vector for non-zero winding checks\r\n  // var weirdDir = p( Math.PI, 22 / 7 );\r\n  \r\n  // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'\r\n  kite.Shape = function Shape( subpaths, bounds ) {\r\n    // lower-level piecewise mathematical description using segments, also individually immutable\r\n    this.subpaths = ( typeof subpaths === 'object' ) ? subpaths : [];\r\n    assert && assert( this.subpaths.length === 0 || this.subpaths[0].constructor.name !== 'Array' );\r\n    \r\n    // computed bounds for all pieces added so far\r\n    this.bounds = bounds || Bounds2.NOTHING;\r\n    \r\n    var that = this;\r\n    if ( subpaths && typeof subpaths !== 'object' ) {\r\n      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' )\r\n      ;\r\n      // parse the SVG path\r\n      _.each( svgPath.parse( subpaths ), function( item ) {\r\n        assert && assert( Shape.prototype[item.cmd] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );\r\n        that[item.cmd].apply( that, item.args );\r\n      } );\r\n    }\r\n  };\r\n  var Shape = kite.Shape;\r\n  \r\n  Shape.prototype = {\r\n    constructor: Shape,\r\n    \r\n    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },\r\n    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },\r\n    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },\r\n    moveToPoint: function( point ) {\r\n      return this.addSubpath( new kite.Subpath().addPoint( point ) );\r\n    },\r\n    \r\n    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },\r\n    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },\r\n    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },\r\n    lineToPoint: function( point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-lineto\r\n      if ( this.hasSubpaths() ) {\r\n        var start = this.getLastSubpath().getLastPoint();\r\n        var end = point;\r\n      var line = new kite.Segment.Line( start, end );\r\n        this.getLastSubpath().addPoint( end );\r\n        if ( !line.invalid ) {\r\n          this.getLastSubpath().addSegment( line );\r\n          this.bounds = this.bounds.withPoint( start ).withPoint( end );\r\n          assert && assert( !isNaN( this.bounds.getX() ) );\r\n        }\r\n      } else {\r\n        this.ensure( point );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },\r\n    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },\r\n    \r\n    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },\r\n    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },\r\n    \r\n    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToPointRelative: function( controlPoint, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );\r\n    },\r\n    // TODO: consider a rename to put 'smooth' farther back?\r\n    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },\r\n    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    quadraticCurveToPoint: function( controlPoint, point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\r\n      this.ensure( controlPoint );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var quadratic = new kite.Segment.Quadratic( start, controlPoint, point );\r\n      this.getLastSubpath().addPoint( point );\r\n      if ( !quadratic.invalid ) {\r\n        this.getLastSubpath().addSegment( quadratic );\r\n        this.bounds = this.bounds.union( quadratic.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToPointRelative: function( control1, control2, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );\r\n    },\r\n    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },\r\n    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    cubicCurveToPoint: function( control1, control2, point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\r\n      this.ensure( control1 );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var cubic = new kite.Segment.Cubic( start, control1, control2, point );\r\n      \r\n      if ( !cubic.invalid ) {\r\n        // if there is a cusp, we add the two (split) quadratic segments instead so that stroking treats the 'join' between them with the proper lineJoin\r\n        if ( cubic.hasCusp() ) {\r\n          this.getLastSubpath().addSegment( cubic.startQuadratic );\r\n          this.getLastSubpath().addSegment( cubic.endQuadratic );\r\n        } else {\r\n          this.getLastSubpath().addSegment( cubic );\r\n        }\r\n        \r\n        this.bounds = this.bounds.union( cubic.bounds );\r\n      }\r\n      this.getLastSubpath().addPoint( point );\r\n      \r\n      return this;\r\n    },\r\n    \r\n    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },\r\n    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\r\n      \r\n      var arc = new kite.Segment.Arc( center, radius, startAngle, endAngle, anticlockwise );\r\n      \r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = arc.start;\r\n      var endPoint = arc.end;\r\n      \r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.getLastSubpath().addSegment( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n      \r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n      \r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n      \r\n      if ( !arc.invalid ) {\r\n        this.getLastSubpath().addSegment( arc );\r\n        \r\n        // and update the bounds\r\n        this.bounds = this.bounds.union( arc.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },\r\n    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\r\n      \r\n      var ellipticalArc = new kite.Segment.EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n      \r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = ellipticalArc.start;\r\n      var endPoint = ellipticalArc.end;\r\n      \r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.getLastSubpath().addSegment( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n      \r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n      \r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n      \r\n      if ( !ellipticalArc.invalid ) {\r\n        this.getLastSubpath().addSegment( ellipticalArc );\r\n        \r\n        // and update the bounds\r\n        this.bounds = this.bounds.union( ellipticalArc.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    close: function() {\r\n      if ( this.hasSubpaths() ) {\r\n        var previousPath = this.getLastSubpath();\r\n        var nextPath = new kite.Subpath();\r\n        \r\n        previousPath.close();\r\n        this.addSubpath( nextPath );\r\n        nextPath.addPoint( previousPath.getFirstPoint() );\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html\r\n    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );\r\n    },\r\n    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      throw new Error( 'ellipticalArcTo unimplemented' );\r\n    },\r\n    \r\n    /*\r\n     * Draws a circle using the arc() call with the following parameters:\r\n     * circle( center, radius ) // center is a Vector2\r\n     * circle( centerX, centerY, radius )\r\n     */\r\n    circle: function( centerX, centerY, radius ) {\r\n      if ( typeof centerX === 'object' ) {\r\n        // circle( center, radius )\r\n        var center = centerX;\r\n        radius = centerY;\r\n        return this.arcPoint( center, radius, 0, Math.PI * 2, false );\r\n      } else {\r\n        // circle( centerX, centerY, radius )\r\n        return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n    \r\n    /*\r\n     * Draws an ellipse using the ellipticalArc() call with the following parameters:\r\n     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2\r\n     * ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n     */\r\n    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {\r\n      // TODO: separate into ellipse() and ellipsePoint()?\r\n      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n      if ( typeof centerX === 'object' ) {\r\n        // ellipse( center, radiusX, radiusY, rotation )\r\n        var center = centerX;\r\n        rotation = radiusY;\r\n        radiusY = radiusX;\r\n        radiusX = centerY;\r\n        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      } else {\r\n        // ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n    \r\n    rect: function( x, y, width, height ) {\r\n      var subpath = new kite.Subpath();\r\n      this.addSubpath( subpath );\r\n      subpath.addPoint( v( x, y ) );\r\n      subpath.addPoint( v( x + width, y ) );\r\n      subpath.addPoint( v( x + width, y + height ) );\r\n      subpath.addPoint( v( x, y + height ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[0], subpath.points[1] ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[1], subpath.points[2] ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[2], subpath.points[3] ) );\r\n      subpath.close();\r\n      this.addSubpath( new kite.Subpath() );\r\n      this.getLastSubpath().addPoint( v( x, y ) );\r\n      this.bounds = this.bounds.withCoordinates( x, y ).withCoordinates( x + width, y + height );\r\n      assert && assert( !isNaN( this.bounds.getX() ) );\r\n      \r\n      return this;\r\n    },\r\n\r\n    //Create a round rectangle. All arguments are number.\r\n    roundRect: function( x, y, width, height, arcw, arch ) {\r\n      var lowX = x + arcw;\r\n      var highX = x + width - arcw;\r\n      var lowY = y + arch;\r\n      var highY = y + height - arch;\r\n      // if ( true ) {\r\n      if ( arcw === arch ) {\r\n        // we can use circular arcs, which have well defined stroked offsets\r\n        this.arc( highX, lowY, arcw, -Math.PI / 2, 0, false )\r\n            .arc( highX, highY, arcw, 0, Math.PI / 2, false )\r\n            .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )\r\n            .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )\r\n            .close();\r\n      } else {\r\n        // we have to resort to elliptical arcs\r\n        this.ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )\r\n            .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )\r\n            .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )\r\n            .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )\r\n            .close();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    copy: function() {\r\n      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one\r\n      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );\r\n    },\r\n    \r\n    // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!\r\n    writeToContext: function( context ) {\r\n      _.each( this.subpaths, function( subpath ) {\r\n        subpath.writeToContext( context );\r\n      } );\r\n    },\r\n    \r\n    // returns something like \"M150 0 L75 200 L225 200 Z\" for a triangle\r\n    getSVGPath: function() {\r\n      var subpathStrings = [];\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if( subpath.isDrawable() ) {\r\n          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point\r\n          var startPoint = subpath.getFirstSegment().start;\r\n          assert && assert( startPoint.equals( subpath.getFirstPoint(), 0.00001 ) ); // sanity check\r\n          var string = 'M ' + startPoint.x + ' ' + startPoint.y + ' ';\r\n          \r\n          string += _.map( subpath.segments, function( segment ) { return segment.getSVGPathFragment(); } ).join( ' ' );\r\n          \r\n          if ( subpath.isClosed() ) {\r\n            string += ' Z';\r\n          }\r\n          subpathStrings.push( string );\r\n        }\r\n      } );\r\n      return subpathStrings.join( ' ' );\r\n    },\r\n    \r\n    // return a new Shape that is transformed by the associated matrix\r\n    transformed: function( matrix ) {\r\n      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.computeBounds() ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n    \r\n    // returns the bounds. if lineStyles exists, include the stroke in the bounds\r\n    // TODO: consider renaming to getBounds()?\r\n    computeBounds: function( lineStyles ) {\r\n      if ( lineStyles ) {\r\n        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );\r\n      } else {\r\n        return this.bounds;\r\n      }\r\n    },\r\n    \r\n    containsPoint: function( point ) {\r\n      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape\r\n      var ray = new Ray2( point, p( 1, 0 ) );\r\n      \r\n      return this.windingIntersection( ray ) !== 0;\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var hits = [];\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            _.each( segment.intersection( ray ), function( hit ) {\r\n              hits.push( hit );\r\n            } );\r\n          } );\r\n          \r\n          if ( subpath.hasClosingSegment() ) {\r\n            _.each( subpath.getClosingSegment().intersection( ray ), function( hit ) {\r\n              hits.push( hit );\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return _.sortBy( hits, function( hit ) { return hit.distance; } );\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      \r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            wind += segment.windingIntersection( ray );\r\n          } );\r\n          \r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            wind += subpath.getClosingSegment().windingIntersection( ray );\r\n          }\r\n        }\r\n      } );\r\n      \r\n      return wind;\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      var intersects = false;\r\n      // TODO: break-out-early optimizations\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            intersects = intersects && segment.intersectsBounds( bounds );\r\n          } );\r\n          \r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            intersects = intersects && subpath.getClosingSegment().intersectsBounds( bounds );\r\n          }\r\n        }\r\n      } );\r\n      return intersects;\r\n    },\r\n    \r\n    // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)\r\n    // TODO: rename stroked( lineStyles )\r\n    getStrokedShape: function( lineStyles ) {\r\n      var subpaths = _.flatten( _.map( this.subpaths, function( subpath ) { return subpath.stroked( lineStyles ); } ) );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.computeBounds() ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n    \r\n    toString: function() {\r\n      // TODO: consider a more verbose but safer way?\r\n      return 'new kite.Shape( \\'' + this.getSVGPath() + '\\' )';\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Internal subpath computations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    ensure: function( point ) {\r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new Subpath() );\r\n        this.getLastSubpath().addPoint( point );\r\n      }\r\n    },\r\n    \r\n    addSubpath: function( subpath ) {\r\n      this.subpaths.push( subpath );\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    hasSubpaths: function() {\r\n      return this.subpaths.length > 0;\r\n    },\r\n    \r\n    getLastSubpath: function() {\r\n      return _.last( this.subpaths );\r\n    },\r\n    \r\n    // gets the last point in the last subpath, or null if it doesn't exist\r\n    getLastPoint: function() {\r\n      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;\r\n    },\r\n    \r\n    getLastSegment: function() {\r\n      if ( !this.hasSubpaths() ) { return null; }\r\n      \r\n      var subpath = this.getLastSubpath();\r\n      if ( !subpath.isDrawable() ) { return null; }\r\n      \r\n      return subpath.getLastSegment();\r\n    },\r\n    \r\n    // returns the point to be used for smooth quadratic segments\r\n    getSmoothQuadraticControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      \r\n      var segment = this.getLastSegment();\r\n      if ( !segment || !( segment instanceof kite.Segment.Quadratic ) ) { return lastPoint; }\r\n      \r\n      return lastPoint.plus( lastPoint.minus( segment.control ) );\r\n    },\r\n    \r\n    // returns the point to be used for smooth cubic segments\r\n    getSmoothCubicControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      \r\n      var segment = this.getLastSegment();\r\n      if ( !segment || !( segment instanceof kite.Segment.Cubic ) ) { return lastPoint; }\r\n      \r\n      return lastPoint.plus( lastPoint.minus( segment.control2 ) );\r\n    },\r\n    \r\n    getRelativePoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      return lastPoint ? lastPoint : Vector2.ZERO;\r\n    }\r\n  };\r\n  \r\n  /*---------------------------------------------------------------------------*\r\n  * Shape shortcuts\r\n  *----------------------------------------------------------------------------*/\r\n  \r\n  Shape.rectangle = function( x, y, width, height ) {\r\n    return new Shape().rect( x, y, width, height );\r\n  };\r\n  Shape.rect = Shape.rectangle;\r\n\r\n  //Create a round rectangle. All arguments are number.\r\n  //Rounding is currently using quadraticCurveTo.  Please note, future versions may use arcTo\r\n  //TODO: rewrite with arcTo?\r\n  Shape.roundRect = function( x, y, width, height, arcw, arch ) {\r\n    return new Shape().roundRect( x, y, width, height, arcw, arch );\r\n  };\r\n  Shape.roundRectangle = Shape.roundRect;\r\n  \r\n  Shape.bounds = function( bounds ) {\r\n    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );\r\n  };\r\n\r\n  //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments\r\n  Shape.lineSegment = function( a, b, c, d ) {\r\n    // TODO: add type assertions?\r\n    if ( typeof a === 'number' ) {\r\n      return new Shape().moveTo( a, b ).lineTo( c, d );\r\n    }\r\n    else {\r\n      return new Shape().moveToPoint( a ).lineToPoint( b );\r\n    }\r\n  };\r\n  \r\n  Shape.regularPolygon = function( sides, radius ) {\r\n    var shape = new Shape();\r\n    _.each( _.range( sides ), function( k ) {\r\n      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );\r\n      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );\r\n    } );\r\n    return shape.close();\r\n  };\r\n  \r\n  // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0\r\n  Shape.circle = function( centerX, centerY, radius ) {\r\n    if ( centerY === undefined ) {\r\n      // circle( radius ), center = 0,0\r\n      return new Shape().circle( 0, 0, centerX );\r\n    }\r\n    return new Shape().circle( centerX, centerY, radius ).close();\r\n  };\r\n  \r\n  /*\r\n   * Supports ellipse( centerX, centerY, radiusX, radiusY ), ellipse( center, radiusX, radiusY ), and ellipse( radiusX, radiusY )\r\n   * with the center default to 0,0 and rotation of 0\r\n   */\r\n  Shape.ellipse = function( centerX, centerY, radiusX, radiusY ) {\r\n    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n    if ( radiusX === undefined ) {\r\n      // ellipse( radiusX, radiusY ), center = 0,0\r\n      return new Shape().ellipse( 0, 0, centerX, centerY );\r\n    }\r\n    return new Shape().ellipse( centerX, centerY, radiusX, radiusY ).close();\r\n  };\r\n  \r\n  // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )\r\n  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {\r\n    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );\r\n  };\r\n  \r\n  return Shape;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Module that includes all Kite dependencies, so that requiring this module will return an object\r\n * that consists of the entire exported 'kite' namespace API.\r\n *\r\n * The API is actually generated by the 'kite' module, so if this module (or all other modules) are\r\n * not included, the 'kite' namespace may not be complete.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'main',[\r\n    'KITE/kite',\r\n    \r\n    'KITE/Shape',\r\n    'KITE/segments/Arc',\r\n    'KITE/segments/Cubic',\r\n    'KITE/segments/EllipticalArc',\r\n    'KITE/segments/Line',\r\n    'KITE/segments/Quadratic',\r\n    'KITE/segments/Segment',\r\n    'KITE/util/LineStyles',\r\n    'KITE/util/Subpath',\r\n    \r\n    'KITE/../parser/svgPath'\r\n  ], function(\r\n    kite // note: we don't need any of the other parts, we just need to specify them as dependencies so they fill in the kite namespace\r\n  ) {\r\n  'use strict';\r\n  \r\n  return kite;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Immutable complex number handling\r\n *\r\n * TODO: handle quaternions in a Quaternion.js!\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n * @author Chris Malley\r\n */\r\n\r\ndefine( 'DOT/Complex',['require','ASSERT/assert','DOT/dot','PHET_CORE/inherit','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  \r\n  // not using x,y,width,height so that it can handle infinity-based cases in a better way\r\n  dot.Complex = function Complex( real, imaginary ) {\r\n    Vector2.call( this, real, imaginary );\r\n    this.real = real;\r\n    this.imaginary = imaginary;\r\n  };\r\n  var Complex = dot.Complex;\r\n  \r\n  Complex.real = function( real ) {\r\n    return new Complex( real, 0 );\r\n  };\r\n  \r\n  Complex.imaginary = function( imaginary ) {\r\n    return new Complex( 0, imaginary );\r\n  };\r\n  \r\n  Complex.createPolar = function( magnitude, phase ) {\r\n    return new Complex( magnitude * Math.cos( phase ), magnitude * Math.sin( phase ) );\r\n  };\r\n  \r\n  // inheriting Vector2 for now since many times we may want to treat the complex number as a vector\r\n  // ideally, we should have Vector2-likeness be a mixin?\r\n  // we also inherit the immutable form since we add 'real' and 'imaginary' properties,\r\n  // without adding extra logic to mutators in Vector2\r\n  inherit( Vector2.Immutable, Complex, {\r\n    phase: Vector2.prototype.angle,\r\n    \r\n    // TODO: remove times() from Vector2? or have it do this for vectors\r\n    times: function( c ) {\r\n      return new Complex( this.real * c.real - this.imaginary * c.imaginary, this.real * c.imaginary + this.imaginary * c.real );\r\n    },\r\n    \r\n    dividedBy: function( c ) {\r\n      var cMag = c.magnitudeSquared();\r\n      return new Complex(\r\n        ( this.real * c.real + this.imaginary * c.imaginary ) / cMag,\r\n        ( this.imaginary * c.real - this.real * c.imaginary ) / cMag\r\n      );\r\n    },\r\n    \r\n    // TODO: pow()\r\n    sqrt: function() {\r\n      var mag = this.magnitude();\r\n      return new Complex( Math.sqrt( ( mag + this.real ) / 2 ),\r\n                          ( this.imaginary >= 0 ? 1 : -1 ) * Math.sqrt( ( mag - this.real ) / 2 ) );\r\n    },\r\n    \r\n    conjugate: function() {\r\n      return new Complex( this.real, -this.imaginary );\r\n    },\r\n    \r\n    // e^(a+bi) = ( e^a ) * ( cos(b) + i * sin(b) )\r\n    exponentiated: function() {\r\n      return Complex.createPolar( Math.exp( this.real ), this.imaginary );\r\n    },\r\n    \r\n    toString: function() {\r\n      return \"Complex(\" + this.x + \", \" + this.y + \")\";\r\n    }\r\n  } );\r\n  \r\n  Complex.ZERO = new Complex( 0, 0 );\r\n  Complex.ONE = new Complex( 1, 0 );\r\n  Complex.I = new Complex( 0, 1 );\r\n  \r\n  return Complex;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 2D convex hulls\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/ConvexHull2',['require','ASSERT/assert','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  // counter-clockwise turn if > 0, clockwise turn if < 0, collinear if === 0.\r\n  function ccw( p1, p2, p3 ) {\r\n    return p2.minus( p1 ).crossScalar( p3.minus( p1 ) );\r\n  }\r\n  \r\n  dot.ConvexHull2 = {\r\n    // test: all collinear, multiple ways of having same angle, etc.\r\n    \r\n    // points is an array of Vector2 instances. see http://en.wikipedia.org/wiki/Graham_scan\r\n    grahamScan: function( points, includeCollinear ) {\r\n      if ( points.length <= 2 ) {\r\n        return points;\r\n      }\r\n      \r\n      // find the point 'p' with the lowest y value\r\n      var minY = Number.POSITIVE_INFINITY;\r\n      var p = null;\r\n      _.each( points, function( point ) {\r\n        if ( point.y <= minY ) {\r\n          // if two points have the same y value, take the one with the lowest x\r\n          if ( point.y === minY && p ) {\r\n            if ( point.x < p.x ) {\r\n              p = point;\r\n            }\r\n          } else {\r\n            minY = point.y;\r\n            p = point;\r\n          }\r\n        }\r\n      } );\r\n      \r\n      // sorts the points by their angle. Between 0 and PI\r\n      points = _.sortBy( points, function( point ) {\r\n        return point.minus( p ).angle();\r\n      } );\r\n      \r\n      // remove p from points (relies on the above statement making a defensive copy)\r\n      points.splice( _.indexOf( points, p ), 1 );\r\n      \r\n      // our result array\r\n      var result = [p];\r\n      \r\n      _.each( points, function( point ) {\r\n        // ignore points equal to our starting point\r\n        if ( p.x === point.x && p.y === point.y ) { return; }\r\n        \r\n        function isRightTurn() {\r\n          if ( result.length < 2 ) {\r\n            return false;\r\n          }\r\n          var cross = ccw( result[result.length-2], result[result.length-1], point );\r\n          return includeCollinear ? ( cross < 0 ) : ( cross <= 0 );\r\n        }\r\n        \r\n        while ( isRightTurn() ) {\r\n          result.pop();\r\n        }\r\n        result.push( point );\r\n      } );\r\n      \r\n      return result;\r\n    }\r\n  };\r\n  \r\n  return dot.ConvexHull2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic width and height\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Dimension2',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  dot.Dimension2 = function Dimension2( width, height ) {\r\n    this.width = width;\r\n    this.height = height;\r\n  };\r\n  var Dimension2 = dot.Dimension2;\r\n\r\n  Dimension2.prototype = {\r\n    constructor: Dimension2,\r\n\r\n    toString: function() {\r\n      return \"[\" + this.width + \"w, \" + this.height + \"h]\";\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.width === other.width && this.height === other.height;\r\n    }\r\n  };\r\n  \r\n  return Dimension2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Eigensystem decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * Eigenvalues and eigenvectors of a real matrix.\r\n * <P>\r\n * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is\r\n * diagonal and the eigenvector matrix V is orthogonal.\r\n * I.e. A = V.times(D.times(V.transpose())) and\r\n * V.times(V.transpose()) equals the identity matrix.\r\n * <P>\r\n * If A is not symmetric, then the eigenvalue matrix D is block diagonal\r\n * with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,\r\n * lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The\r\n * columns of V represent the eigenvectors in the sense that A*V = V*D,\r\n * i.e. A.times(V) equals V.times(D).  The matrix V may be badly\r\n * conditioned, or even singular, so the validity of the equation\r\n * A = V*D*inverse(V) depends upon V.cond().\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/EigenvalueDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.EigenvalueDecomposition = function EigenvalueDecomposition( matrix ) {\r\n    var i, j;\r\n\r\n    var A = matrix.entries;\r\n    this.n = matrix.getColumnDimension(); // Row and column dimension (square matrix).\r\n    var n = this.n;\r\n    this.V = new Float32Array( n * n ); // Array for internal storage of eigenvectors.\r\n\r\n    // Arrays for internal storage of eigenvalues.\r\n    this.d = new Float32Array( n );\r\n    this.e = new Float32Array( n );\r\n\r\n    this.issymmetric = true;\r\n    for ( j = 0; (j < n) && this.issymmetric; j++ ) {\r\n      for ( i = 0; (i < n) && this.issymmetric; i++ ) {\r\n        this.issymmetric = (A[i * this.n + j] === A[j * this.n + i]);\r\n      }\r\n    }\r\n\r\n    if ( this.issymmetric ) {\r\n      for ( i = 0; i < n; i++ ) {\r\n        for ( j = 0; j < n; j++ ) {\r\n          this.V[i * this.n + j] = A[i * this.n + j];\r\n        }\r\n      }\r\n\r\n      // Tridiagonalize.\r\n      this.tred2();\r\n\r\n      // Diagonalize.\r\n      this.tql2();\r\n\r\n    }\r\n    else {\r\n      this.H = new Float32Array( n * n ); // Array for internal storage of nonsymmetric Hessenberg form.\r\n      this.ort = new Float32Array( n ); // // Working storage for nonsymmetric algorithm.\r\n\r\n      for ( j = 0; j < n; j++ ) {\r\n        for ( i = 0; i < n; i++ ) {\r\n          this.H[i * this.n + j] = A[i * this.n + j];\r\n        }\r\n      }\r\n\r\n      // Reduce to Hessenberg form.\r\n      this.orthes();\r\n\r\n      // Reduce Hessenberg to real Schur form.\r\n      this.hqr2();\r\n    }\r\n  };\r\n  var EigenvalueDecomposition = dot.EigenvalueDecomposition;\r\n\r\n  EigenvalueDecomposition.prototype = {\r\n    constructor: EigenvalueDecomposition,\r\n\r\n    // Return the eigenvector matrix\r\n    getV: function() {\r\n      return this.V.copy();\r\n    },\r\n\r\n    // {Array} Return the real parts of the eigenvalues\r\n    getRealEigenvalues: function() {\r\n      return this.d;\r\n    },\r\n\r\n    // {Array} Return the imaginary parts of the eigenvalues\r\n    getImagEigenvalues: function() {\r\n      return this.e;\r\n    },\r\n\r\n    // Return the block diagonal eigenvalue matrix\r\n    getD: function() {\r\n      var n = this.n, d = this.d, e = this.e;\r\n\r\n      var X = new dot.Matrix( n, n );\r\n      var D = X.entries;\r\n      for ( var i = 0; i < n; i++ ) {\r\n        for ( var j = 0; j < n; j++ ) {\r\n          D[i * this.n + j] = 0.0;\r\n        }\r\n        D[i * this.n + i] = d[i];\r\n        if ( e[i] > 0 ) {\r\n          D[i * this.n + i + 1] = e[i];\r\n        }\r\n        else if ( e[i] < 0 ) {\r\n          D[i * this.n + i - 1] = e[i];\r\n        }\r\n      }\r\n      return X;\r\n    },\r\n\r\n    // Symmetric Householder reduction to tridiagonal form.\r\n    tred2: function() {\r\n      var n = this.n, V = this.V, d = this.d, e = this.e;\r\n      var i, j, k, f, g, h;\r\n\r\n      //  This is derived from the Algol procedures tred2 by\r\n      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for\r\n      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutine in EISPACK.\r\n\r\n      for ( j = 0; j < n; j++ ) {\r\n        d[j] = V[(n - 1) * n + j];\r\n      }\r\n\r\n      // Householder reduction to tridiagonal form.\r\n\r\n      for ( i = n - 1; i > 0; i-- ) {\r\n\r\n        // Scale to avoid under/overflow.\r\n\r\n        var scale = 0.0;\r\n        h = 0.0;\r\n        for ( k = 0; k < i; k++ ) {\r\n          scale = scale + Math.abs( d[k] );\r\n        }\r\n        if ( scale === 0.0 ) {\r\n          e[i] = d[i - 1];\r\n          for ( j = 0; j < i; j++ ) {\r\n            d[j] = V[(i - 1) * n + j];\r\n            V[i * this.n + j] = 0.0;\r\n            V[j * this.n + i] = 0.0;\r\n          }\r\n        }\r\n        else {\r\n\r\n          // Generate Householder vector.\r\n\r\n          for ( k = 0; k < i; k++ ) {\r\n            d[k] /= scale;\r\n            h += d[k] * d[k];\r\n          }\r\n          f = d[i - 1];\r\n          g = Math.sqrt( h );\r\n          if ( f > 0 ) {\r\n            g = -g;\r\n          }\r\n          e[i] = scale * g;\r\n          h = h - f * g;\r\n          d[i - 1] = f - g;\r\n          for ( j = 0; j < i; j++ ) {\r\n            e[j] = 0.0;\r\n          }\r\n\r\n          // Apply similarity transformation to remaining columns.\r\n\r\n          for ( j = 0; j < i; j++ ) {\r\n            f = d[j];\r\n            V[j * this.n + i] = f;\r\n            g = e[j] + V[j * n + j] * f;\r\n            for ( k = j + 1; k <= i - 1; k++ ) {\r\n              g += V[k * n + j] * d[k];\r\n              e[k] += V[k * n + j] * f;\r\n            }\r\n            e[j] = g;\r\n          }\r\n          f = 0.0;\r\n          for ( j = 0; j < i; j++ ) {\r\n            e[j] /= h;\r\n            f += e[j] * d[j];\r\n          }\r\n          var hh = f / (h + h);\r\n          for ( j = 0; j < i; j++ ) {\r\n            e[j] -= hh * d[j];\r\n          }\r\n          for ( j = 0; j < i; j++ ) {\r\n            f = d[j];\r\n            g = e[j];\r\n            for ( k = j; k <= i - 1; k++ ) {\r\n              V[k * n + j] -= (f * e[k] + g * d[k]);\r\n            }\r\n            d[j] = V[(i - 1) * n + j];\r\n            V[i * this.n + j] = 0.0;\r\n          }\r\n        }\r\n        d[i] = h;\r\n      }\r\n\r\n      // Accumulate transformations.\r\n\r\n      for ( i = 0; i < n - 1; i++ ) {\r\n        V[(n - 1) * n + i] = V[i * n + i];\r\n        V[i * n + i] = 1.0;\r\n        h = d[i + 1];\r\n        if ( h !== 0.0 ) {\r\n          for ( k = 0; k <= i; k++ ) {\r\n            d[k] = V[k * n + (i + 1)] / h;\r\n          }\r\n          for ( j = 0; j <= i; j++ ) {\r\n            g = 0.0;\r\n            for ( k = 0; k <= i; k++ ) {\r\n              g += V[k * n + (i + 1)] * V[k * n + j];\r\n            }\r\n            for ( k = 0; k <= i; k++ ) {\r\n              V[k * n + j] -= g * d[k];\r\n            }\r\n          }\r\n        }\r\n        for ( k = 0; k <= i; k++ ) {\r\n          V[k * n + (i + 1)] = 0.0;\r\n        }\r\n      }\r\n      for ( j = 0; j < n; j++ ) {\r\n        d[j] = V[(n - 1) * n + j];\r\n        V[(n - 1) * n + j] = 0.0;\r\n      }\r\n      V[(n - 1) * n + (n - 1)] = 1.0;\r\n      e[0] = 0.0;\r\n    },\r\n\r\n    // Symmetric tridiagonal QL algorithm.\r\n    tql2: function() {\r\n      var n = this.n, V = this.V, d = this.d, e = this.e;\r\n      var i, j, k, l, g, p;\r\n      var iter;\r\n\r\n      //  This is derived from the Algol procedures tql2, by\r\n      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for\r\n      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutine in EISPACK.\r\n\r\n      for ( i = 1; i < n; i++ ) {\r\n        e[i - 1] = e[i];\r\n      }\r\n      e[n - 1] = 0.0;\r\n\r\n      var f = 0.0;\r\n      var tst1 = 0.0;\r\n      var eps = Math.pow( 2.0, -52.0 );\r\n      for ( l = 0; l < n; l++ ) {\r\n\r\n        // Find small subdiagonal element\r\n\r\n        tst1 = Math.max( tst1, Math.abs( d[l] ) + Math.abs( e[l] ) );\r\n        var m = l;\r\n        while ( m < n ) {\r\n          if ( Math.abs( e[m] ) <= eps * tst1 ) {\r\n            break;\r\n          }\r\n          m++;\r\n        }\r\n\r\n        // If m === l, d[l] is an eigenvalue,\r\n        // otherwise, iterate.\r\n\r\n        if ( m > l ) {\r\n          iter = 0;\r\n          do {\r\n            iter = iter + 1;  // (Could check iteration count here.)\r\n\r\n            // Compute implicit shift\r\n\r\n            g = d[l];\r\n            p = (d[l + 1] - g) / (2.0 * e[l]);\r\n            var r = dot.Matrix.hypot( p, 1.0 );\r\n            if ( p < 0 ) {\r\n              r = -r;\r\n            }\r\n            d[l] = e[l] / (p + r);\r\n            d[l + 1] = e[l] * (p + r);\r\n            var dl1 = d[l + 1];\r\n            var h = g - d[l];\r\n            for ( i = l + 2; i < n; i++ ) {\r\n              d[i] -= h;\r\n            }\r\n            f = f + h;\r\n\r\n            // Implicit QL transformation.\r\n\r\n            p = d[m];\r\n            var c = 1.0;\r\n            var c2 = c;\r\n            var c3 = c;\r\n            var el1 = e[l + 1];\r\n            var s = 0.0;\r\n            var s2 = 0.0;\r\n            for ( i = m - 1; i >= l; i-- ) {\r\n              c3 = c2;\r\n              c2 = c;\r\n              s2 = s;\r\n              g = c * e[i];\r\n              h = c * p;\r\n              r = dot.Matrix.hypot( p, e[i] );\r\n              e[i + 1] = s * r;\r\n              s = e[i] / r;\r\n              c = p / r;\r\n              p = c * d[i] - s * g;\r\n              d[i + 1] = h + s * (c * g + s * d[i]);\r\n\r\n              // Accumulate transformation.\r\n\r\n              for ( k = 0; k < n; k++ ) {\r\n                h = V[k * n + (i + 1)];\r\n                V[k * n + (i + 1)] = s * V[k * n + i] + c * h;\r\n                V[k * n + i] = c * V[k * n + i] - s * h;\r\n              }\r\n            }\r\n            p = -s * s2 * c3 * el1 * e[l] / dl1;\r\n            e[l] = s * p;\r\n            d[l] = c * p;\r\n\r\n            // Check for convergence.\r\n\r\n          } while ( Math.abs( e[l] ) > eps * tst1 );\r\n        }\r\n        d[l] = d[l] + f;\r\n        e[l] = 0.0;\r\n      }\r\n\r\n      // Sort eigenvalues and corresponding vectors.\r\n\r\n      for ( i = 0; i < n - 1; i++ ) {\r\n        k = i;\r\n        p = d[i];\r\n        for ( j = i + 1; j < n; j++ ) {\r\n          if ( d[j] < p ) {\r\n            k = j;\r\n            p = d[j];\r\n          }\r\n        }\r\n        if ( k !== i ) {\r\n          d[k] = d[i];\r\n          d[i] = p;\r\n          for ( j = 0; j < n; j++ ) {\r\n            p = V[j * this.n + i];\r\n            V[j * this.n + i] = V[j * n + k];\r\n            V[j * n + k] = p;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Nonsymmetric reduction to Hessenberg form.\r\n    orthes: function() {\r\n      var n = this.n, V = this.V, H = this.H, ort = this.ort;\r\n      var i, j, m, f, g;\r\n\r\n      //  This is derived from the Algol procedures orthes and ortran,\r\n      //  by Martin and Wilkinson, Handbook for Auto. Comp.,\r\n      //  Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutines in EISPACK.\r\n\r\n      var low = 0;\r\n      var high = n - 1;\r\n\r\n      for ( m = low + 1; m <= high - 1; m++ ) {\r\n\r\n        // Scale column.\r\n\r\n        var scale = 0.0;\r\n        for ( i = m; i <= high; i++ ) {\r\n          scale = scale + Math.abs( H[i * n + (m - 1)] );\r\n        }\r\n        if ( scale !== 0.0 ) {\r\n\r\n          // Compute Householder transformation.\r\n\r\n          var h = 0.0;\r\n          for ( i = high; i >= m; i-- ) {\r\n            ort[i] = H[i * n + (m - 1)] / scale;\r\n            h += ort[i] * ort[i];\r\n          }\r\n          g = Math.sqrt( h );\r\n          if ( ort[m] > 0 ) {\r\n            g = -g;\r\n          }\r\n          h = h - ort[m] * g;\r\n          ort[m] = ort[m] - g;\r\n\r\n          // Apply Householder similarity transformation\r\n          // H = (I-u*u'/h)*H*(I-u*u')/h)\r\n\r\n          for ( j = m; j < n; j++ ) {\r\n            f = 0.0;\r\n            for ( i = high; i >= m; i-- ) {\r\n              f += ort[i] * H[i * this.n + j];\r\n            }\r\n            f = f / h;\r\n            for ( i = m; i <= high; i++ ) {\r\n              H[i * this.n + j] -= f * ort[i];\r\n            }\r\n          }\r\n\r\n          for ( i = 0; i <= high; i++ ) {\r\n            f = 0.0;\r\n            for ( j = high; j >= m; j-- ) {\r\n              f += ort[j] * H[i * this.n + j];\r\n            }\r\n            f = f / h;\r\n            for ( j = m; j <= high; j++ ) {\r\n              H[i * this.n + j] -= f * ort[j];\r\n            }\r\n          }\r\n          ort[m] = scale * ort[m];\r\n          H[m * n + (m - 1)] = scale * g;\r\n        }\r\n      }\r\n\r\n      // Accumulate transformations (Algol's ortran).\r\n\r\n      for ( i = 0; i < n; i++ ) {\r\n        for ( j = 0; j < n; j++ ) {\r\n          V[i * this.n + j] = (i === j ? 1.0 : 0.0);\r\n        }\r\n      }\r\n\r\n      for ( m = high - 1; m >= low + 1; m-- ) {\r\n        if ( H[m * n + (m - 1)] !== 0.0 ) {\r\n          for ( i = m + 1; i <= high; i++ ) {\r\n            ort[i] = H[i * n + (m - 1)];\r\n          }\r\n          for ( j = m; j <= high; j++ ) {\r\n            g = 0.0;\r\n            for ( i = m; i <= high; i++ ) {\r\n              g += ort[i] * V[i * this.n + j];\r\n            }\r\n            // Double division avoids possible underflow\r\n            g = (g / ort[m]) / H[m * n + (m - 1)];\r\n            for ( i = m; i <= high; i++ ) {\r\n              V[i * this.n + j] += g * ort[i];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Complex scalar division.\r\n    cdiv: function( xr, xi, yr, yi ) {\r\n      var r, d;\r\n      if ( Math.abs( yr ) > Math.abs( yi ) ) {\r\n        r = yi / yr;\r\n        d = yr + r * yi;\r\n        this.cdivr = (xr + r * xi) / d;\r\n        this.cdivi = (xi - r * xr) / d;\r\n      }\r\n      else {\r\n        r = yr / yi;\r\n        d = yi + r * yr;\r\n        this.cdivr = (r * xr + xi) / d;\r\n        this.cdivi = (r * xi - xr) / d;\r\n      }\r\n    },\r\n\r\n    // Nonsymmetric reduction from Hessenberg to real Schur form.\r\n    hqr2: function() {\r\n      var n, V = this.V, d = this.d, e = this.e, H = this.H;\r\n      var i, j, k, l, m;\r\n      var iter;\r\n\r\n      //  This is derived from the Algol procedure hqr2,\r\n      //  by Martin and Wilkinson, Handbook for Auto. Comp.,\r\n      //  Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutine in EISPACK.\r\n\r\n      // Initialize\r\n\r\n      var nn = this.n;\r\n      n = nn - 1;\r\n      var low = 0;\r\n      var high = nn - 1;\r\n      var eps = Math.pow( 2.0, -52.0 );\r\n      var exshift = 0.0;\r\n      var p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;\r\n\r\n      // Store roots isolated by balanc and compute matrix norm\r\n\r\n      var norm = 0.0;\r\n      for ( i = 0; i < nn; i++ ) {\r\n        if ( i < low || i > high ) {\r\n          d[i] = H[i * n + i];\r\n          e[i] = 0.0;\r\n        }\r\n        for ( j = Math.max( i - 1, 0 ); j < nn; j++ ) {\r\n          norm = norm + Math.abs( H[i * this.n + j] );\r\n        }\r\n      }\r\n\r\n      // Outer loop over eigenvalue index\r\n\r\n      iter = 0;\r\n      while ( n >= low ) {\r\n\r\n        // Look for single small sub-diagonal element\r\n\r\n        l = n;\r\n        while ( l > low ) {\r\n          s = Math.abs( H[(l - 1) * n + (l - 1)] ) + Math.abs( H[l * n + l] );\r\n          if ( s === 0.0 ) {\r\n            s = norm;\r\n          }\r\n          if ( Math.abs( H[l * n + (l - 1)] ) < eps * s ) {\r\n            break;\r\n          }\r\n          l--;\r\n        }\r\n\r\n        // Check for convergence\r\n        // One root found\r\n\r\n        if ( l === n ) {\r\n          H[n * n + n] = H[n * n + n] + exshift;\r\n          d[n] = H[n * n + n];\r\n          e[n] = 0.0;\r\n          n--;\r\n          iter = 0;\r\n\r\n          // Two roots found\r\n\r\n        }\r\n        else if ( l === n - 1 ) {\r\n          w = H[n * n + n - 1] * H[(n - 1) * n + n];\r\n          p = (H[(n - 1) * n + (n - 1)] - H[n * n + n]) / 2.0;\r\n          q = p * p + w;\r\n          z = Math.sqrt( Math.abs( q ) );\r\n          H[n * n + n] = H[n * n + n] + exshift;\r\n          H[(n - 1) * n + (n - 1)] = H[(n - 1) * n + (n - 1)] + exshift;\r\n          x = H[n * n + n];\r\n\r\n          // Real pair\r\n\r\n          if ( q >= 0 ) {\r\n            if ( p >= 0 ) {\r\n              z = p + z;\r\n            }\r\n            else {\r\n              z = p - z;\r\n            }\r\n            d[n - 1] = x + z;\r\n            d[n] = d[n - 1];\r\n            if ( z !== 0.0 ) {\r\n              d[n] = x - w / z;\r\n            }\r\n            e[n - 1] = 0.0;\r\n            e[n] = 0.0;\r\n            x = H[n * n + n - 1];\r\n            s = Math.abs( x ) + Math.abs( z );\r\n            p = x / s;\r\n            q = z / s;\r\n            r = Math.sqrt( p * p + q * q );\r\n            p = p / r;\r\n            q = q / r;\r\n\r\n            // Row modification\r\n\r\n            for ( j = n - 1; j < nn; j++ ) {\r\n              z = H[(n - 1) * n + j];\r\n              H[(n - 1) * n + j] = q * z + p * H[n * n + j];\r\n              H[n * n + j] = q * H[n * n + j] - p * z;\r\n            }\r\n\r\n            // Column modification\r\n\r\n            for ( i = 0; i <= n; i++ ) {\r\n              z = H[i * n + n - 1];\r\n              H[i * n + n - 1] = q * z + p * H[i * n + n];\r\n              H[i * n + n] = q * H[i * n + n] - p * z;\r\n            }\r\n\r\n            // Accumulate transformations\r\n\r\n            for ( i = low; i <= high; i++ ) {\r\n              z = V[i * n + n - 1];\r\n              V[i * n + n - 1] = q * z + p * V[i * n + n];\r\n              V[i * n + n] = q * V[i * n + n] - p * z;\r\n            }\r\n\r\n            // Complex pair\r\n\r\n          }\r\n          else {\r\n            d[n - 1] = x + p;\r\n            d[n] = x + p;\r\n            e[n - 1] = z;\r\n            e[n] = -z;\r\n          }\r\n          n = n - 2;\r\n          iter = 0;\r\n\r\n          // No convergence yet\r\n\r\n        }\r\n        else {\r\n\r\n          // Form shift\r\n\r\n          x = H[n * n + n];\r\n          y = 0.0;\r\n          w = 0.0;\r\n          if ( l < n ) {\r\n            y = H[(n - 1) * n + (n - 1)];\r\n            w = H[n * n + n - 1] * H[(n - 1) * n + n];\r\n          }\r\n\r\n          // Wilkinson's original ad hoc shift\r\n\r\n          if ( iter === 10 ) {\r\n            exshift += x;\r\n            for ( i = low; i <= n; i++ ) {\r\n              H[i * n + i] -= x;\r\n            }\r\n            s = Math.abs( H[n * n + n - 1] ) + Math.abs( H[(n - 1) * n + n - 2] );\r\n            x = y = 0.75 * s;\r\n            w = -0.4375 * s * s;\r\n          }\r\n\r\n          // MATLAB's new ad hoc shift\r\n\r\n          if ( iter === 30 ) {\r\n            s = (y - x) / 2.0;\r\n            s = s * s + w;\r\n            if ( s > 0 ) {\r\n              s = Math.sqrt( s );\r\n              if ( y < x ) {\r\n                s = -s;\r\n              }\r\n              s = x - w / ((y - x) / 2.0 + s);\r\n              for ( i = low; i <= n; i++ ) {\r\n                H[i * n + i] -= s;\r\n              }\r\n              exshift += s;\r\n              x = y = w = 0.964;\r\n            }\r\n          }\r\n\r\n          iter = iter + 1;   // (Could check iteration count here.)\r\n\r\n          // Look for two consecutive small sub-diagonal elements\r\n\r\n          m = n - 2;\r\n          while ( m >= l ) {\r\n            z = H[m * n + m];\r\n            r = x - z;\r\n            s = y - z;\r\n            p = (r * s - w) / H[(m + 1) * n + m] + H[m * n + m + 1];\r\n            q = H[(m + 1) * n + m + 1] - z - r - s;\r\n            r = H[(m + 2) * n + m + 1];\r\n            s = Math.abs( p ) + Math.abs( q ) + Math.abs( r );\r\n            p = p / s;\r\n            q = q / s;\r\n            r = r / s;\r\n            if ( m === l ) {\r\n              break;\r\n            }\r\n            if ( Math.abs( H[m * n + (m - 1)] ) * (Math.abs( q ) + Math.abs( r )) <\r\n                 eps * (Math.abs( p ) * (Math.abs( H[(m - 1) * n + m - 1] ) + Math.abs( z ) +\r\n                                         Math.abs( H[(m + 1) * n + m + 1] ))) ) {\r\n              break;\r\n            }\r\n            m--;\r\n          }\r\n\r\n          for ( i = m + 2; i <= n; i++ ) {\r\n            H[i * n + i - 2] = 0.0;\r\n            if ( i > m + 2 ) {\r\n              H[i * n + i - 3] = 0.0;\r\n            }\r\n          }\r\n\r\n          // Double QR step involving rows l:n and columns m:n\r\n\r\n          for ( k = m; k <= n - 1; k++ ) {\r\n            var notlast = (k !== n - 1);\r\n            if ( k !== m ) {\r\n              p = H[k * n + k - 1];\r\n              q = H[(k + 1) * n + k - 1];\r\n              r = (notlast ? H[(k + 2) * n + k - 1] : 0.0);\r\n              x = Math.abs( p ) + Math.abs( q ) + Math.abs( r );\r\n              if ( x !== 0.0 ) {\r\n                p = p / x;\r\n                q = q / x;\r\n                r = r / x;\r\n              }\r\n            }\r\n            if ( x === 0.0 ) {\r\n              break;\r\n            }\r\n            s = Math.sqrt( p * p + q * q + r * r );\r\n            if ( p < 0 ) {\r\n              s = -s;\r\n            }\r\n            if ( s !== 0 ) {\r\n              if ( k !== m ) {\r\n                H[k * n + k - 1] = -s * x;\r\n              }\r\n              else if ( l !== m ) {\r\n                H[k * n + k - 1] = -H[k * n + k - 1];\r\n              }\r\n              p = p + s;\r\n              x = p / s;\r\n              y = q / s;\r\n              z = r / s;\r\n              q = q / p;\r\n              r = r / p;\r\n\r\n              // Row modification\r\n\r\n              for ( j = k; j < nn; j++ ) {\r\n                p = H[k * n + j] + q * H[(k + 1) * n + j];\r\n                if ( notlast ) {\r\n                  p = p + r * H[(k + 2) * n + j];\r\n                  H[(k + 2) * n + j] = H[(k + 2) * n + j] - p * z;\r\n                }\r\n                H[k * n + j] = H[k * n + j] - p * x;\r\n                H[(k + 1) * n + j] = H[(k + 1) * n + j] - p * y;\r\n              }\r\n\r\n              // Column modification\r\n\r\n              for ( i = 0; i <= Math.min( n, k + 3 ); i++ ) {\r\n                p = x * H[i * n + k] + y * H[i * n + k + 1];\r\n                if ( notlast ) {\r\n                  p = p + z * H[i * n + k + 2];\r\n                  H[i * n + k + 2] = H[i * n + k + 2] - p * r;\r\n                }\r\n                H[i * n + k] = H[i * n + k] - p;\r\n                H[i * n + k + 1] = H[i * n + k + 1] - p * q;\r\n              }\r\n\r\n              // Accumulate transformations\r\n\r\n              for ( i = low; i <= high; i++ ) {\r\n                p = x * V[i * n + k] + y * V[i * n + k + 1];\r\n                if ( notlast ) {\r\n                  p = p + z * V[i * n + k + 2];\r\n                  V[i * n + k + 2] = V[i * n + k + 2] - p * r;\r\n                }\r\n                V[i * n + k] = V[i * n + k] - p;\r\n                V[i * n + k + 1] = V[i * n + k + 1] - p * q;\r\n              }\r\n            }  // (s !== 0)\r\n          }  // k loop\r\n        }  // check convergence\r\n      }  // while (n >= low)\r\n\r\n      // Backsubstitute to find vectors of upper triangular form\r\n\r\n      if ( norm === 0.0 ) {\r\n        return;\r\n      }\r\n\r\n      for ( n = nn - 1; n >= 0; n-- ) {\r\n        p = d[n];\r\n        q = e[n];\r\n\r\n        // Real vector\r\n\r\n        if ( q === 0 ) {\r\n          l = n;\r\n          H[n * n + n] = 1.0;\r\n          for ( i = n - 1; i >= 0; i-- ) {\r\n            w = H[i * n + i] - p;\r\n            r = 0.0;\r\n            for ( j = l; j <= n; j++ ) {\r\n              r = r + H[i * this.n + j] * H[j * n + n];\r\n            }\r\n            if ( e[i] < 0.0 ) {\r\n              z = w;\r\n              s = r;\r\n            }\r\n            else {\r\n              l = i;\r\n              if ( e[i] === 0.0 ) {\r\n                if ( w !== 0.0 ) {\r\n                  H[i * n + n] = -r / w;\r\n                }\r\n                else {\r\n                  H[i * n + n] = -r / (eps * norm);\r\n                }\r\n\r\n                // Solve real equations\r\n\r\n              }\r\n              else {\r\n                x = H[i * n + i + 1];\r\n                y = H[(i + 1) * n + i];\r\n                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\r\n                t = (x * s - z * r) / q;\r\n                H[i * n + n] = t;\r\n                if ( Math.abs( x ) > Math.abs( z ) ) {\r\n                  H[(i + 1) * n + n] = (-r - w * t) / x;\r\n                }\r\n                else {\r\n                  H[(i + 1) * n + n] = (-s - y * t) / z;\r\n                }\r\n              }\r\n\r\n              // Overflow control\r\n\r\n              t = Math.abs( H[i * n + n] );\r\n              if ( (eps * t) * t > 1 ) {\r\n                for ( j = i; j <= n; j++ ) {\r\n                  H[j * n + n] = H[j * n + n] / t;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Complex vector\r\n\r\n        }\r\n        else if ( q < 0 ) {\r\n          l = n - 1;\r\n\r\n          // Last vector component imaginary so matrix is triangular\r\n\r\n          if ( Math.abs( H[n * n + n - 1] ) > Math.abs( H[(n - 1) * n + n] ) ) {\r\n            H[(n - 1) * n + (n - 1)] = q / H[n * n + n - 1];\r\n            H[(n - 1) * n + n] = -(H[n * n + n] - p) / H[n * n + n - 1];\r\n          }\r\n          else {\r\n            this.cdiv( 0.0, -H[(n - 1) * n + n], H[(n - 1) * n + (n - 1)] - p, q );\r\n            H[(n - 1) * n + (n - 1)] = this.cdivr;\r\n            H[(n - 1) * n + n] = this.cdivi;\r\n          }\r\n          H[n * n + n - 1] = 0.0;\r\n          H[n * n + n] = 1.0;\r\n          for ( i = n - 2; i >= 0; i-- ) {\r\n            var ra, sa, vr, vi;\r\n            ra = 0.0;\r\n            sa = 0.0;\r\n            for ( j = l; j <= n; j++ ) {\r\n              ra = ra + H[i * this.n + j] * H[j * n + n - 1];\r\n              sa = sa + H[i * this.n + j] * H[j * n + n];\r\n            }\r\n            w = H[i * n + i] - p;\r\n\r\n            if ( e[i] < 0.0 ) {\r\n              z = w;\r\n              r = ra;\r\n              s = sa;\r\n            }\r\n            else {\r\n              l = i;\r\n              if ( e[i] === 0 ) {\r\n                this.cdiv( -ra, -sa, w, q );\r\n                H[i * n + n - 1] = this.cdivr;\r\n                H[i * n + n] = this.cdivi;\r\n              }\r\n              else {\r\n\r\n                // Solve complex equations\r\n\r\n                x = H[i * n + i + 1];\r\n                y = H[(i + 1) * n + i];\r\n                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\r\n                vi = (d[i] - p) * 2.0 * q;\r\n                if ( vr === 0.0 && vi === 0.0 ) {\r\n                  vr = eps * norm * (Math.abs( w ) + Math.abs( q ) +\r\n                                     Math.abs( x ) + Math.abs( y ) + Math.abs( z ));\r\n                }\r\n                this.cdiv( x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi );\r\n                H[i * n + n - 1] = this.cdivr;\r\n                H[i * n + n] = this.cdivi;\r\n                if ( Math.abs( x ) > (Math.abs( z ) + Math.abs( q )) ) {\r\n                  H[(i + 1) * n + n - 1] = (-ra - w * H[i * n + n - 1] + q * H[i * n + n]) / x;\r\n                  H[(i + 1) * n + n] = (-sa - w * H[i * n + n] - q * H[i * n + n - 1]) / x;\r\n                }\r\n                else {\r\n                  this.cdiv( -r - y * H[i * n + n - 1], -s - y * H[i * n + n], z, q );\r\n                  H[(i + 1) * n + n - 1] = this.cdivr;\r\n                  H[(i + 1) * n + n] = this.cdivi;\r\n                }\r\n              }\r\n\r\n              // Overflow control\r\n              t = Math.max( Math.abs( H[i * n + n - 1] ), Math.abs( H[i * n + n] ) );\r\n              if ( (eps * t) * t > 1 ) {\r\n                for ( j = i; j <= n; j++ ) {\r\n                  H[j * n + n - 1] = H[j * n + n - 1] / t;\r\n                  H[j * n + n] = H[j * n + n] / t;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Vectors of isolated roots\r\n      for ( i = 0; i < nn; i++ ) {\r\n        if ( i < low || i > high ) {\r\n          for ( j = i; j < nn; j++ ) {\r\n            V[i * this.n + j] = H[i * this.n + j];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Back transformation to get eigenvectors of original matrix\r\n      for ( j = nn - 1; j >= low; j-- ) {\r\n        for ( i = low; i <= high; i++ ) {\r\n          z = 0.0;\r\n          for ( k = low; k <= Math.min( j, high ); k++ ) {\r\n            z = z + V[i * n + k] * H[k * n + j];\r\n          }\r\n          V[i * this.n + j] = z;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return EigenvalueDecomposition;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Function for doing a linear mapping between two domains ('a' and 'b').\r\n * <p>\r\n * Example usage:\r\n * <code>\r\n * var f = new dot.LinearFunction( 0, 100, 0, 200 );\r\n * f( 50 ); // 100\r\n * f.inverse( 100 ); // 50\r\n * </code>\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  // imports\r\n  require( 'DOT/Util' );\r\n  \r\n  /**\r\n   * @param {Number} a1\r\n   * @param {Number} a2\r\n   * @param {Number} b1\r\n   * @param {Number} b2\r\n   * @param {Boolean} clamp clamp the result to the provided ranges, false by default\r\n   * @constructor\r\n   */\r\n  dot.LinearFunction = function LinearFunction( a1, a2, b1, b2, clamp ) {\r\n    \r\n    clamp = _.isUndefined( clamp ) ? false : clamp;\r\n\r\n    /*\r\n     * Linearly interpolate two points and evaluate the line equation for a third point.\r\n     * f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>\r\n     * Optionally clamp the result to the range [b1,b2].\r\n     */\r\n    var map = function( a1, a2, b1, b2, a3, clamp ) {\r\n      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );\r\n      if ( clamp ) {\r\n        var max = Math.max( b1, b2 );\r\n        var min = Math.min( b1, b2 );\r\n        b3 = dot.Util.clamp( b3, min, max );\r\n      }\r\n      return b3;\r\n    };\r\n    \r\n    // Maps from a to b.\r\n    var evaluate = function( a3 ) {\r\n      return map( a1, a2, b1, b2, a3, clamp );\r\n    };\r\n\r\n    // Maps from b to a.\r\n    evaluate.inverse = function( b3 ) {\r\n      return map( b1, b2, a1, a2, b3, clamp );\r\n    };\r\n    \r\n    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)\r\n  };\r\n  \r\n  return dot.LinearFunction;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * LU decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/LUDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var Float32Array = window.Float32Array || Array;\r\n  \r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.LUDecomposition = function LUDecomposition( matrix ) {\r\n    var i, j, k;\r\n\r\n    this.matrix = matrix;\r\n\r\n    // TODO: size!\r\n    this.LU = matrix.getArrayCopy();\r\n    var LU = this.LU;\r\n    this.m = matrix.getRowDimension();\r\n    var m = this.m;\r\n    this.n = matrix.getColumnDimension();\r\n    var n = this.n;\r\n    this.piv = new Uint32Array( m );\r\n    for ( i = 0; i < m; i++ ) {\r\n      this.piv[i] = i;\r\n    }\r\n    this.pivsign = 1;\r\n    var LUcolj = new Float32Array( m );\r\n\r\n    // Outer loop.\r\n\r\n    for ( j = 0; j < n; j++ ) {\r\n\r\n      // Make a copy of the j-th column to localize references.\r\n      for ( i = 0; i < m; i++ ) {\r\n        LUcolj[i] = LU[matrix.index( i, j )];\r\n      }\r\n\r\n      // Apply previous transformations.\r\n\r\n      for ( i = 0; i < m; i++ ) {\r\n        // Most of the time is spent in the following dot product.\r\n        var kmax = Math.min( i, j );\r\n        var s = 0.0;\r\n        for ( k = 0; k < kmax; k++ ) {\r\n          var ik = matrix.index( i, k );\r\n          s += LU[ik] * LUcolj[k];\r\n        }\r\n\r\n        LUcolj[i] -= s;\r\n        LU[matrix.index( i, j )] = LUcolj[i];\r\n      }\r\n\r\n      // Find pivot and exchange if necessary.\r\n\r\n      var p = j;\r\n      for ( i = j + 1; i < m; i++ ) {\r\n        if ( Math.abs( LUcolj[i] ) > Math.abs( LUcolj[p] ) ) {\r\n          p = i;\r\n        }\r\n      }\r\n      if ( p !== j ) {\r\n        for ( k = 0; k < n; k++ ) {\r\n          var pk = matrix.index( p, k );\r\n          var jk = matrix.index( j, k );\r\n          var t = LU[pk];\r\n          LU[pk] = LU[jk];\r\n          LU[jk] = t;\r\n        }\r\n        k = this.piv[p];\r\n        this.piv[p] = this.piv[j];\r\n        this.piv[j] = k;\r\n        this.pivsign = -this.pivsign;\r\n      }\r\n\r\n      // Compute multipliers.\r\n\r\n      if ( j < m && LU[this.matrix.index( j, j )] !== 0.0 ) {\r\n        for ( i = j + 1; i < m; i++ ) {\r\n          LU[matrix.index( i, j )] /= LU[matrix.index( j, j )];\r\n        }\r\n      }\r\n    }\r\n  };\r\n  var LUDecomposition = dot.LUDecomposition;\r\n\r\n  LUDecomposition.prototype = {\r\n    constructor: LUDecomposition,\r\n\r\n    isNonsingular: function() {\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        var index = this.matrix.index( j, j );\r\n        if ( this.LU[index] === 0 ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    getL: function() {\r\n      var result = new dot.Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i > j ) {\r\n            result.entries[result.index( i, j )] = this.LU[this.matrix.index( i, j )];\r\n          }\r\n          else if ( i === j ) {\r\n            result.entries[result.index( i, j )] = 1.0;\r\n          }\r\n          else {\r\n            result.entries[result.index( i, j )] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getU: function() {\r\n      var result = new dot.Matrix( this.n, this.n );\r\n      for ( var i = 0; i < this.n; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i <= j ) {\r\n            result.entries[result.index( i, j )] = this.LU[this.matrix.index( i, j )];\r\n          }\r\n          else {\r\n            result.entries[result.index( i, j )] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getPivot: function() {\r\n      var p = new Uint32Array( this.m );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        p[i] = this.piv[i];\r\n      }\r\n      return p;\r\n    },\r\n\r\n    getDoublePivot: function() {\r\n      var vals = new Float32Array( this.m );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        vals[i] = this.piv[i];\r\n      }\r\n      return vals;\r\n    },\r\n\r\n    det: function() {\r\n      if ( this.m !== this.n ) {\r\n        throw new Error( \"Matrix must be square.\" );\r\n      }\r\n      var d = this.pivsign;\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        d *= this.LU[this.matrix.index( j, j )];\r\n      }\r\n      return d;\r\n    },\r\n\r\n    solve: function( matrix ) {\r\n      var i, j, k;\r\n      if ( matrix.getRowDimension() !== this.m ) {\r\n        throw new Error( \"Matrix row dimensions must agree.\" );\r\n      }\r\n      if ( !this.isNonsingular() ) {\r\n        throw new Error( \"Matrix is singular.\" );\r\n      }\r\n\r\n      // Copy right hand side with pivoting\r\n      var nx = matrix.getColumnDimension();\r\n      var Xmat = matrix.getArrayRowMatrix( this.piv, 0, nx - 1 );\r\n\r\n      // Solve L*Y = B(piv,:)\r\n      for ( k = 0; k < this.n; k++ ) {\r\n        for ( i = k + 1; i < this.n; i++ ) {\r\n          for ( j = 0; j < nx; j++ ) {\r\n            Xmat.entries[Xmat.index( i, j )] -= Xmat.entries[Xmat.index( k, j )] * this.LU[this.matrix.index( i, k )];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Solve U*X = Y;\r\n      for ( k = this.n - 1; k >= 0; k-- ) {\r\n        for ( j = 0; j < nx; j++ ) {\r\n          Xmat.entries[Xmat.index( k, j )] /= this.LU[this.matrix.index( k, k )];\r\n        }\r\n        for ( i = 0; i < k; i++ ) {\r\n          for ( j = 0; j < nx; j++ ) {\r\n            Xmat.entries[Xmat.index( i, j )] -= Xmat.entries[Xmat.index( k, j )] * this.LU[this.matrix.index( i, k )];\r\n          }\r\n        }\r\n      }\r\n      return Xmat;\r\n    }\r\n  };\r\n  \r\n  return LUDecomposition;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Tests whether a reference is to an array.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'PHET_CORE/isArray',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function isArray( array ) {\r\n    // yes, this is actually how to do this. see http://stackoverflow.com/questions/4775722/javascript-check-if-object-is-array\r\n    return Object.prototype.toString.call( array ) === '[object Array]';\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * SVD decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/SingularValueDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var Float32Array = window.Float32Array || Array;\r\n  \r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.SingularValueDecomposition = function SingularValueDecomposition( matrix ) {\r\n    this.matrix = matrix;\r\n\r\n    var Arg = matrix;\r\n\r\n    // Derived from LINPACK code.\r\n    // Initialize.\r\n    var A = Arg.getArrayCopy();\r\n    this.m = Arg.getRowDimension();\r\n    this.n = Arg.getColumnDimension();\r\n    var m = this.m;\r\n    var n = this.n;\r\n\r\n    var min = Math.min;\r\n    var max = Math.max;\r\n    var pow = Math.pow;\r\n    var abs = Math.abs;\r\n\r\n    /* Apparently the failing cases are only a proper subset of (m<n),\r\n     so let's not throw error.  Correct fix to come later?\r\n     if (m<n) {\r\n     throw new IllegalArgumentException(\"Jama SVD only works for m >= n\"); }\r\n     */\r\n    var nu = min( m, n );\r\n    this.s = new Float32Array( min( m + 1, n ) );\r\n    var s = this.s;\r\n    this.U = new Float32Array( m * nu );\r\n    var U = this.U;\r\n    this.V = new Float32Array( n * n );\r\n    var V = this.V;\r\n    var e = new Float32Array( n );\r\n    var work = new Float32Array( m );\r\n    var wantu = true;\r\n    var wantv = true;\r\n\r\n    var i, j, k, t, f;\r\n    var cs,sn;\r\n\r\n    var hypot = dot.Matrix.hypot;\r\n\r\n    // Reduce A to bidiagonal form, storing the diagonal elements\r\n    // in s and the super-diagonal elements in e.\r\n\r\n    var nct = min( m - 1, n );\r\n    var nrt = max( 0, min( n - 2, m ) );\r\n    for ( k = 0; k < max( nct, nrt ); k++ ) {\r\n      if ( k < nct ) {\r\n\r\n        // Compute the transformation for the k-th column and\r\n        // place the k-th diagonal in s[k].\r\n        // Compute 2-norm of k-th column without under/overflow.\r\n        s[k] = 0;\r\n        for ( i = k; i < m; i++ ) {\r\n          s[k] = hypot( s[k], A[i * n + k] );\r\n        }\r\n        if ( s[k] !== 0.0 ) {\r\n          if ( A[k * n + k] < 0.0 ) {\r\n            s[k] = -s[k];\r\n          }\r\n          for ( i = k; i < m; i++ ) {\r\n            A[i * n + k] /= s[k];\r\n          }\r\n          A[k * n + k] += 1.0;\r\n        }\r\n        s[k] = -s[k];\r\n      }\r\n      for ( j = k + 1; j < n; j++ ) {\r\n        if ( (k < nct) && (s[k] !== 0.0) ) {\r\n\r\n          // Apply the transformation.\r\n\r\n          t = 0;\r\n          for ( i = k; i < m; i++ ) {\r\n            t += A[i * n + k] * A[i * n + j];\r\n          }\r\n          t = -t / A[k * n + k];\r\n          for ( i = k; i < m; i++ ) {\r\n            A[i * n + j] += t * A[i * n + k];\r\n          }\r\n        }\r\n\r\n        // Place the k-th row of A into e for the\r\n        // subsequent calculation of the row transformation.\r\n\r\n        e[j] = A[k * n + j];\r\n      }\r\n      if ( wantu && (k < nct) ) {\r\n\r\n        // Place the transformation in U for subsequent back\r\n        // multiplication.\r\n\r\n        for ( i = k; i < m; i++ ) {\r\n          U[i * nu + k] = A[i * n + k];\r\n        }\r\n      }\r\n      if ( k < nrt ) {\r\n\r\n        // Compute the k-th row transformation and place the\r\n        // k-th super-diagonal in e[k].\r\n        // Compute 2-norm without under/overflow.\r\n        e[k] = 0;\r\n        for ( i = k + 1; i < n; i++ ) {\r\n          e[k] = hypot( e[k], e[i] );\r\n        }\r\n        if ( e[k] !== 0.0 ) {\r\n          if ( e[k + 1] < 0.0 ) {\r\n            e[k] = -e[k];\r\n          }\r\n          for ( i = k + 1; i < n; i++ ) {\r\n            e[i] /= e[k];\r\n          }\r\n          e[k + 1] += 1.0;\r\n        }\r\n        e[k] = -e[k];\r\n        if ( (k + 1 < m) && (e[k] !== 0.0) ) {\r\n\r\n          // Apply the transformation.\r\n\r\n          for ( i = k + 1; i < m; i++ ) {\r\n            work[i] = 0.0;\r\n          }\r\n          for ( j = k + 1; j < n; j++ ) {\r\n            for ( i = k + 1; i < m; i++ ) {\r\n              work[i] += e[j] * A[i * n + j];\r\n            }\r\n          }\r\n          for ( j = k + 1; j < n; j++ ) {\r\n            t = -e[j] / e[k + 1];\r\n            for ( i = k + 1; i < m; i++ ) {\r\n              A[i * n + j] += t * work[i];\r\n            }\r\n          }\r\n        }\r\n        if ( wantv ) {\r\n\r\n          // Place the transformation in V for subsequent\r\n          // back multiplication.\r\n\r\n          for ( i = k + 1; i < n; i++ ) {\r\n            V[i * n + k] = e[i];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Set up the final bidiagonal matrix or order p.\r\n\r\n    var p = min( n, m + 1 );\r\n    if ( nct < n ) {\r\n      s[nct] = A[nct * n + nct];\r\n    }\r\n    if ( m < p ) {\r\n      s[p - 1] = 0.0;\r\n    }\r\n    if ( nrt + 1 < p ) {\r\n      e[nrt] = A[nrt * n + p - 1];\r\n    }\r\n    e[p - 1] = 0.0;\r\n\r\n    // If required, generate U.\r\n\r\n    if ( wantu ) {\r\n      for ( j = nct; j < nu; j++ ) {\r\n        for ( i = 0; i < m; i++ ) {\r\n          U[i * nu + j] = 0.0;\r\n        }\r\n        U[j * nu + j] = 1.0;\r\n      }\r\n      for ( k = nct - 1; k >= 0; k-- ) {\r\n        if ( s[k] !== 0.0 ) {\r\n          for ( j = k + 1; j < nu; j++ ) {\r\n            t = 0;\r\n            for ( i = k; i < m; i++ ) {\r\n              t += U[i * nu + k] * U[i * nu + j];\r\n            }\r\n            t = -t / U[k * nu + k];\r\n            for ( i = k; i < m; i++ ) {\r\n              U[i * nu + j] += t * U[i * nu + k];\r\n            }\r\n          }\r\n          for ( i = k; i < m; i++ ) {\r\n            U[i * nu + k] = -U[i * nu + k];\r\n          }\r\n          U[k * nu + k] = 1.0 + U[k * nu + k];\r\n          for ( i = 0; i < k - 1; i++ ) {\r\n            U[i * nu + k] = 0.0;\r\n          }\r\n        }\r\n        else {\r\n          for ( i = 0; i < m; i++ ) {\r\n            U[i * nu + k] = 0.0;\r\n          }\r\n          U[k * nu + k] = 1.0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // If required, generate V.\r\n\r\n    if ( wantv ) {\r\n      for ( k = n - 1; k >= 0; k-- ) {\r\n        if ( (k < nrt) && (e[k] !== 0.0) ) {\r\n          for ( j = k + 1; j < nu; j++ ) {\r\n            t = 0;\r\n            for ( i = k + 1; i < n; i++ ) {\r\n              t += V[i * n + k] * V[i * n + j];\r\n            }\r\n            t = -t / V[(k + 1) * n + k];\r\n            for ( i = k + 1; i < n; i++ ) {\r\n              V[i * n + j] += t * V[i * n + k];\r\n            }\r\n          }\r\n        }\r\n        for ( i = 0; i < n; i++ ) {\r\n          V[i * n + k] = 0.0;\r\n        }\r\n        V[k * n + k] = 1.0;\r\n      }\r\n    }\r\n\r\n    // Main iteration loop for the singular values.\r\n\r\n    var pp = p - 1;\r\n    var iter = 0;\r\n    var eps = pow( 2.0, -52.0 );\r\n    var tiny = pow( 2.0, -966.0 );\r\n    while ( p > 0 ) {\r\n      var kase;\r\n\r\n      // Here is where a test for too many iterations would go.\r\n\r\n      // This section of the program inspects for\r\n      // negligible elements in the s and e arrays.  On\r\n      // completion the variables kase and k are set as follows.\r\n\r\n      // kase = 1   if s(p) and e[k-1] are negligible and k<p\r\n      // kase = 2   if s(k) is negligible and k<p\r\n      // kase = 3   if e[k-1] is negligible, k<p, and\r\n      //        s(k), ..., s(p) are not negligible (qr step).\r\n      // kase = 4   if e(p-1) is negligible (convergence).\r\n\r\n      for ( k = p - 2; k >= -1; k-- ) {\r\n        if ( k === -1 ) {\r\n          break;\r\n        }\r\n        if ( abs( e[k] ) <=\r\n           tiny + eps * (abs( s[k] ) + abs( s[k + 1] )) ) {\r\n          e[k] = 0.0;\r\n          break;\r\n        }\r\n      }\r\n      if ( k === p - 2 ) {\r\n        kase = 4;\r\n      }\r\n      else {\r\n        var ks;\r\n        for ( ks = p - 1; ks >= k; ks-- ) {\r\n          if ( ks === k ) {\r\n            break;\r\n          }\r\n          t = (ks !== p ? abs( e[ks] ) : 0) +\r\n            (ks !== k + 1 ? abs( e[ks - 1] ) : 0);\r\n          if ( abs( s[ks] ) <= tiny + eps * t ) {\r\n            s[ks] = 0.0;\r\n            break;\r\n          }\r\n        }\r\n        if ( ks === k ) {\r\n          kase = 3;\r\n        }\r\n        else if ( ks === p - 1 ) {\r\n          kase = 1;\r\n        }\r\n        else {\r\n          kase = 2;\r\n          k = ks;\r\n        }\r\n      }\r\n      k++;\r\n\r\n      // Perform the task indicated by kase.\r\n\r\n      switch( kase ) {\r\n\r\n        // Deflate negligible s(p).\r\n\r\n        case 1:\r\n        {\r\n          f = e[p - 2];\r\n          e[p - 2] = 0.0;\r\n          for ( j = p - 2; j >= k; j-- ) {\r\n            t = hypot( s[j], f );\r\n            cs = s[j] / t;\r\n            sn = f / t;\r\n            s[j] = t;\r\n            if ( j !== k ) {\r\n              f = -sn * e[j - 1];\r\n              e[j - 1] = cs * e[j - 1];\r\n            }\r\n            if ( wantv ) {\r\n              for ( i = 0; i < n; i++ ) {\r\n                t = cs * V[i * n + j] + sn * V[i * n + p - 1];\r\n                V[i * n + p - 1] = -sn * V[i * n + j] + cs * V[i * n + p - 1];\r\n                V[i * n + j] = t;\r\n              }\r\n            }\r\n          }\r\n        }\r\n          break;\r\n\r\n        // Split at negligible s(k).\r\n\r\n        case 2:\r\n        {\r\n          f = e[k - 1];\r\n          e[k - 1] = 0.0;\r\n          for ( j = k; j < p; j++ ) {\r\n            t = hypot( s[j], f );\r\n            cs = s[j] / t;\r\n            sn = f / t;\r\n            s[j] = t;\r\n            f = -sn * e[j];\r\n            e[j] = cs * e[j];\r\n            if ( wantu ) {\r\n              for ( i = 0; i < m; i++ ) {\r\n                t = cs * U[i * nu + j] + sn * U[i * nu + k - 1];\r\n                U[i * nu + k - 1] = -sn * U[i * nu + j] + cs * U[i * nu + k - 1];\r\n                U[i * nu + j] = t;\r\n              }\r\n            }\r\n          }\r\n        }\r\n          break;\r\n\r\n        // Perform one qr step.\r\n\r\n        case 3:\r\n        {\r\n\r\n          // Calculate the shift.\r\n\r\n          var scale = max( max( max( max(\r\n              abs( s[p - 1] ), abs( s[p - 2] ) ), abs( e[p - 2] ) ),\r\n                          abs( s[k] ) ), abs( e[k] ) );\r\n          var sp = s[p - 1] / scale;\r\n          var spm1 = s[p - 2] / scale;\r\n          var epm1 = e[p - 2] / scale;\r\n          var sk = s[k] / scale;\r\n          var ek = e[k] / scale;\r\n          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\r\n          var c = (sp * epm1) * (sp * epm1);\r\n          var shift = 0.0;\r\n          if ( (b !== 0.0) || (c !== 0.0) ) {\r\n            shift = Math.sqrt( b * b + c );\r\n            if ( b < 0.0 ) {\r\n              shift = -shift;\r\n            }\r\n            shift = c / (b + shift);\r\n          }\r\n          f = (sk + sp) * (sk - sp) + shift;\r\n          var g = sk * ek;\r\n\r\n          // Chase zeros.\r\n\r\n          for ( j = k; j < p - 1; j++ ) {\r\n            t = hypot( f, g );\r\n            cs = f / t;\r\n            sn = g / t;\r\n            if ( j !== k ) {\r\n              e[j - 1] = t;\r\n            }\r\n            f = cs * s[j] + sn * e[j];\r\n            e[j] = cs * e[j] - sn * s[j];\r\n            g = sn * s[j + 1];\r\n            s[j + 1] = cs * s[j + 1];\r\n            if ( wantv ) {\r\n              for ( i = 0; i < n; i++ ) {\r\n                t = cs * V[i * n + j] + sn * V[i * n + j + 1];\r\n                V[i * n + j + 1] = -sn * V[i * n + j] + cs * V[i * n + j + 1];\r\n                V[i * n + j] = t;\r\n              }\r\n            }\r\n            t = hypot( f, g );\r\n            cs = f / t;\r\n            sn = g / t;\r\n            s[j] = t;\r\n            f = cs * e[j] + sn * s[j + 1];\r\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\r\n            g = sn * e[j + 1];\r\n            e[j + 1] = cs * e[j + 1];\r\n            if ( wantu && (j < m - 1) ) {\r\n              for ( i = 0; i < m; i++ ) {\r\n                t = cs * U[i * nu + j] + sn * U[i * nu + j + 1];\r\n                U[i * nu + j + 1] = -sn * U[i * nu + j] + cs * U[i * nu + j + 1];\r\n                U[i * nu + j] = t;\r\n              }\r\n            }\r\n          }\r\n          e[p - 2] = f;\r\n          iter = iter + 1;\r\n        }\r\n          break;\r\n\r\n        // Convergence.\r\n\r\n        case 4:\r\n        {\r\n\r\n          // Make the singular values positive.\r\n\r\n          if ( s[k] <= 0.0 ) {\r\n            s[k] = (s[k] < 0.0 ? -s[k] : 0.0);\r\n            if ( wantv ) {\r\n              for ( i = 0; i <= pp; i++ ) {\r\n                V[i * n + k] = -V[i * n + k];\r\n              }\r\n            }\r\n          }\r\n\r\n          // Order the singular values.\r\n\r\n          while ( k < pp ) {\r\n            if ( s[k] >= s[k + 1] ) {\r\n              break;\r\n            }\r\n            t = s[k];\r\n            s[k] = s[k + 1];\r\n            s[k + 1] = t;\r\n            if ( wantv && (k < n - 1) ) {\r\n              for ( i = 0; i < n; i++ ) {\r\n                t = V[i * n + k + 1];\r\n                V[i * n + k + 1] = V[i * n + k];\r\n                V[i * n + k] = t;\r\n              }\r\n            }\r\n            if ( wantu && (k < m - 1) ) {\r\n              for ( i = 0; i < m; i++ ) {\r\n                t = U[i * nu + k + 1];\r\n                U[i * nu + k + 1] = U[i * nu + k];\r\n                U[i * nu + k] = t;\r\n              }\r\n            }\r\n            k++;\r\n          }\r\n          iter = 0;\r\n          p--;\r\n        }\r\n          break;\r\n      }\r\n    }\r\n  };\r\n  var SingularValueDecomposition = dot.SingularValueDecomposition;\r\n\r\n  SingularValueDecomposition.prototype = {\r\n    constructor: SingularValueDecomposition,\r\n\r\n    getU: function() {\r\n      return new dot.Matrix( this.m, Math.min( this.m + 1, this.n ), this.U, true ); // the \"fast\" flag added, since U is Float32Array\r\n    },\r\n\r\n    getV: function() {\r\n      return new dot.Matrix( this.n, this.n, this.V, true );\r\n    },\r\n\r\n    getSingularValues: function() {\r\n      return this.s;\r\n    },\r\n\r\n    getS: function() {\r\n      var result = new dot.Matrix( this.n, this.n );\r\n      for ( var i = 0; i < this.n; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          result.entries[result.index( i, j )] = 0.0;\r\n        }\r\n        result.entries[result.index( i, i )] = this.s[i];\r\n      }\r\n      return result;\r\n    },\r\n\r\n    norm2: function() {\r\n      return this.s[0];\r\n    },\r\n\r\n    cond: function() {\r\n      return this.s[0] / this.s[Math.min( this.m, this.n ) - 1];\r\n    },\r\n\r\n    rank: function() {\r\n      // changed to 23 from 52 (bits of mantissa), since we are using floats here!\r\n      var eps = Math.pow( 2.0, -23.0 );\r\n      var tol = Math.max( this.m, this.n ) * this.s[0] * eps;\r\n      var r = 0;\r\n      for ( var i = 0; i < this.s.length; i++ ) {\r\n        if ( this.s[i] > tol ) {\r\n          r++;\r\n        }\r\n      }\r\n      return r;\r\n    }\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * QR decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/QRDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var Float32Array = window.Float32Array || Array;\r\n  \r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.QRDecomposition = function QRDecomposition( matrix ) {\r\n    this.matrix = matrix;\r\n\r\n    // TODO: size!\r\n    this.QR = matrix.getArrayCopy();\r\n    var QR = this.QR;\r\n    this.m = matrix.getRowDimension();\r\n    var m = this.m;\r\n    this.n = matrix.getColumnDimension();\r\n    var n = this.n;\r\n\r\n    this.Rdiag = new Float32Array( n );\r\n\r\n    var i, j, k;\r\n\r\n    // Main loop.\r\n    for ( k = 0; k < n; k++ ) {\r\n      // Compute 2-norm of k-th column without under/overflow.\r\n      var nrm = 0;\r\n      for ( i = k; i < m; i++ ) {\r\n        nrm = dot.Matrix.hypot( nrm, QR[this.matrix.index( i, k )] );\r\n      }\r\n\r\n      if ( nrm !== 0.0 ) {\r\n        // Form k-th Householder vector.\r\n        if ( QR[this.matrix.index( k, k )] < 0 ) {\r\n          nrm = -nrm;\r\n        }\r\n        for ( i = k; i < m; i++ ) {\r\n          QR[this.matrix.index( i, k )] /= nrm;\r\n        }\r\n        QR[this.matrix.index( k, k )] += 1.0;\r\n\r\n        // Apply transformation to remaining columns.\r\n        for ( j = k + 1; j < n; j++ ) {\r\n          var s = 0.0;\r\n          for ( i = k; i < m; i++ ) {\r\n            s += QR[this.matrix.index( i, k )] * QR[this.matrix.index( i, j )];\r\n          }\r\n          s = -s / QR[this.matrix.index( k, k )];\r\n          for ( i = k; i < m; i++ ) {\r\n            QR[this.matrix.index( i, j )] += s * QR[this.matrix.index( i, k )];\r\n          }\r\n        }\r\n      }\r\n      this.Rdiag[k] = -nrm;\r\n    }\r\n  };\r\n  var QRDecomposition = dot.QRDecomposition;\r\n\r\n  QRDecomposition.prototype = {\r\n    constructor: QRDecomposition,\r\n\r\n    isFullRank: function() {\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        if ( this.Rdiag[j] === 0 ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    getH: function() {\r\n      var result = new dot.Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i >= j ) {\r\n            result.entries[result.index( i, j )] = this.QR[this.matrix.index( i, j )];\r\n          }\r\n          else {\r\n            result.entries[result.index( i, j )] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getR: function() {\r\n      var result = new dot.Matrix( this.n, this.n );\r\n      for ( var i = 0; i < this.n; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i < j ) {\r\n            result.entries[result.index( i, j )] = this.QR[this.matrix.index( i, j )];\r\n          }\r\n          else if ( i === j ) {\r\n            result.entries[result.index( i, j )] = this.Rdiag[i];\r\n          }\r\n          else {\r\n            result.entries[result.index( i, j )] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getQ: function() {\r\n      var i, j, k;\r\n      var result = new dot.Matrix( this.m, this.n );\r\n      for ( k = this.n - 1; k >= 0; k-- ) {\r\n        for ( i = 0; i < this.m; i++ ) {\r\n          result.entries[result.index( i, k )] = 0.0;\r\n        }\r\n        result.entries[result.index( k, k )] = 1.0;\r\n        for ( j = k; j < this.n; j++ ) {\r\n          if ( this.QR[this.matrix.index( k, k )] !== 0 ) {\r\n            var s = 0.0;\r\n            for ( i = k; i < this.m; i++ ) {\r\n              s += this.QR[this.matrix.index( i, k )] * result.entries[result.index( i, j )];\r\n            }\r\n            s = -s / this.QR[this.matrix.index( k, k )];\r\n            for ( i = k; i < this.m; i++ ) {\r\n              result.entries[result.index( i, j )] += s * this.QR[this.matrix.index( i, k )];\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    solve: function( matrix ) {\r\n      if ( matrix.getRowDimension() !== this.m ) {\r\n        throw new Error( \"Matrix row dimensions must agree.\" );\r\n      }\r\n      if ( !this.isFullRank() ) {\r\n        throw new Error( \"Matrix is rank deficient.\" );\r\n      }\r\n\r\n      var i, j, k;\r\n\r\n      // Copy right hand side\r\n      var nx = matrix.getColumnDimension();\r\n      var X = matrix.getArrayCopy();\r\n\r\n      // Compute Y = transpose(Q)*matrix\r\n      for ( k = 0; k < this.n; k++ ) {\r\n        for ( j = 0; j < nx; j++ ) {\r\n          var s = 0.0;\r\n          for ( i = k; i < this.m; i++ ) {\r\n            s += this.QR[this.matrix.index( i, k )] * X[matrix.index( i, j )];\r\n          }\r\n          s = -s / this.QR[this.matrix.index( k, k )];\r\n          for ( i = k; i < this.m; i++ ) {\r\n            X[matrix.index( i, j )] += s * this.QR[this.matrix.index( i, k )];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Solve R*X = Y;\r\n      for ( k = this.n - 1; k >= 0; k-- ) {\r\n        for ( j = 0; j < nx; j++ ) {\r\n          X[matrix.index( k, j )] /= this.Rdiag[k];\r\n        }\r\n        for ( i = 0; i < k; i++ ) {\r\n          for ( j = 0; j < nx; j++ ) {\r\n            X[matrix.index( i, j )] -= X[matrix.index( k, j )] * this.QR[this.matrix.index( i, k )];\r\n          }\r\n        }\r\n      }\r\n      return new dot.Matrix( X, this.n, nx ).getMatrix( 0, this.n - 1, 0, nx - 1 );\r\n    }\r\n  };\r\n  \r\n  return QRDecomposition;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Arbitrary-dimensional matrix, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Matrix',['require','ASSERT/assert','DOT/dot','PHET_CORE/isArray','DOT/SingularValueDecomposition','DOT/LUDecomposition','DOT/QRDecomposition','DOT/EigenvalueDecomposition','DOT/Vector2','DOT/Vector3','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var Float32Array = window.Float32Array || Array;\r\n  \r\n  var isArray = require( 'PHET_CORE/isArray' );\r\n  \r\n  require( 'DOT/SingularValueDecomposition' );\r\n  require( 'DOT/LUDecomposition' );\r\n  require( 'DOT/QRDecomposition' );\r\n  require( 'DOT/EigenvalueDecomposition' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Vector4' );\r\n  \r\n  dot.Matrix = function Matrix( m, n, filler, fast ) {\r\n    this.m = m;\r\n    this.n = n;\r\n\r\n    var size = m * n;\r\n    this.size = size;\r\n    var i;\r\n\r\n    if ( fast ) {\r\n      this.entries = filler;\r\n    }\r\n    else {\r\n      if ( !filler ) {\r\n        filler = 0;\r\n      }\r\n\r\n      // entries stored in row-major format\r\n      this.entries = new Float32Array( size );\r\n\r\n      if ( isArray( filler ) ) {\r\n        assert && assert( filler.length === size );\r\n\r\n        for ( i = 0; i < size; i++ ) {\r\n          this.entries[i] = filler[i];\r\n        }\r\n      }\r\n      else {\r\n        for ( i = 0; i < size; i++ ) {\r\n          this.entries[i] = filler;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  var Matrix = dot.Matrix;\r\n\r\n  /** sqrt(a^2 + b^2) without under/overflow. **/\r\n  Matrix.hypot = function hypot( a, b ) {\r\n    var r;\r\n    if ( Math.abs( a ) > Math.abs( b ) ) {\r\n      r = b / a;\r\n      r = Math.abs( a ) * Math.sqrt( 1 + r * r );\r\n    }\r\n    else if ( b !== 0 ) {\r\n      r = a / b;\r\n      r = Math.abs( b ) * Math.sqrt( 1 + r * r );\r\n    }\r\n    else {\r\n      r = 0.0;\r\n    }\r\n    return r;\r\n  };\r\n\r\n  Matrix.prototype = {\r\n    constructor: Matrix,\r\n\r\n    copy: function() {\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.size; i++ ) {\r\n        result.entries[i] = this.entries[i];\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getArray: function() {\r\n      return this.entries;\r\n    },\r\n\r\n    getArrayCopy: function() {\r\n      return new Float32Array( this.entries );\r\n    },\r\n\r\n    getRowDimension: function() {\r\n      return this.m;\r\n    },\r\n\r\n    getColumnDimension: function() {\r\n      return this.n;\r\n    },\r\n\r\n    // TODO: inline this places if we aren't using an inlining compiler! (check performance)\r\n    index: function( i, j ) {\r\n      return i * this.n + j;\r\n    },\r\n\r\n    get: function( i, j ) {\r\n      return this.entries[this.index( i, j )];\r\n    },\r\n\r\n    set: function( i, j, s ) {\r\n      this.entries[this.index( i, j )] = s;\r\n    },\r\n\r\n    getMatrix: function( i0, i1, j0, j1 ) {\r\n      var result = new Matrix( i1 - i0 + 1, j1 - j0 + 1 );\r\n      for ( var i = i0; i <= i1; i++ ) {\r\n        for ( var j = j0; j <= j1; j++ ) {\r\n          result.entries[result.index( i - i0, j - j0 )] = this.entries[this.index( i, j )];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    // getMatrix (int[] r, int j0, int j1)\r\n    getArrayRowMatrix: function( r, j0, j1 ) {\r\n      var result = new Matrix( r.length, j1 - j0 + 1 );\r\n      for ( var i = 0; i < r.length; i++ ) {\r\n        for ( var j = j0; j <= j1; j++ ) {\r\n          result.entries[result.index( i, j - j0 )] = this.entries[this.index( r[i], j )];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    transpose: function() {\r\n      var result = new Matrix( this.n, this.m );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          result.entries[result.index( j, i )] = this.entries[this.index( i, j )];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    norm1: function() {\r\n      var f = 0;\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        var s = 0;\r\n        for ( var i = 0; i < this.m; i++ ) {\r\n          s += Math.abs( this.entries[ this.index( i, j ) ] );\r\n        }\r\n        f = Math.max( f, s );\r\n      }\r\n      return f;\r\n    },\r\n\r\n    norm2: function() {\r\n      return (new dot.SingularValueDecomposition( this ).norm2());\r\n    },\r\n\r\n    normInf: function() {\r\n      var f = 0;\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        var s = 0;\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          s += Math.abs( this.entries[ this.index( i, j ) ] );\r\n        }\r\n        f = Math.max( f, s );\r\n      }\r\n      return f;\r\n    },\r\n\r\n    normF: function() {\r\n      var f = 0;\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          f = Matrix.hypot( f, this.entries[ this.index( i, j ) ] );\r\n        }\r\n      }\r\n      return f;\r\n    },\r\n\r\n    uminus: function() {\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          result.entries[result.index( i, j )] = -this.entries[ this.index( i, j ) ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    plus: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = result.index( i, j );\r\n          result.entries[index] = this.entries[index] + matrix.entries[index];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    plusEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = result.index( i, j );\r\n          this.entries[index] = this.entries[index] + matrix.entries[index];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    minus: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          result.entries[index] = this.entries[index] - matrix.entries[index];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    minusEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[index] = this.entries[index] - matrix.entries[index];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    arrayTimes: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = result.index( i, j );\r\n          result.entries[index] = this.entries[index] * matrix.entries[index];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    arrayTimesEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[index] = this.entries[index] * matrix.entries[index];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    arrayRightDivide: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          result.entries[index] = this.entries[index] / matrix.entries[index];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    arrayRightDivideEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[index] = this.entries[index] / matrix.entries[index];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    arrayLeftDivide: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          result.entries[index] = matrix.entries[index] / this.entries[index];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    arrayLeftDivideEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[index] = matrix.entries[index] / this.entries[index];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    times: function( matrixOrScalar ) {\r\n      var result;\r\n      var i, j, k, s;\r\n      var matrix;\r\n      if ( matrixOrScalar.isMatrix ) {\r\n        matrix = matrixOrScalar;\r\n        if ( matrix.m !== this.n ) {\r\n          throw new Error( \"Matrix inner dimensions must agree.\" );\r\n        }\r\n        result = new Matrix( this.m, matrix.n );\r\n        var matrixcolj = new Float32Array( this.n );\r\n        for ( j = 0; j < matrix.n; j++ ) {\r\n          for ( k = 0; k < this.n; k++ ) {\r\n            matrixcolj[k] = matrix.entries[ matrix.index( k, j ) ];\r\n          }\r\n          for ( i = 0; i < this.m; i++ ) {\r\n            s = 0;\r\n            for ( k = 0; k < this.n; k++ ) {\r\n              s += this.entries[this.index( i, k )] * matrixcolj[k];\r\n            }\r\n            result.entries[result.index( i, j )] = s;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      else {\r\n        s = matrixOrScalar;\r\n        result = new Matrix( this.m, this.n );\r\n        for ( i = 0; i < this.m; i++ ) {\r\n          for ( j = 0; j < this.n; j++ ) {\r\n            result.entries[result.index( i, j )] = s * this.entries[this.index( i, j )];\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n    },\r\n\r\n    timesEquals: function( s ) {\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[index] = s * this.entries[index];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    solve: function( matrix ) {\r\n      return (this.m === this.n ? (new dot.LUDecomposition( this )).solve( matrix ) :\r\n          (new dot.QRDecomposition( this )).solve( matrix ));\r\n    },\r\n\r\n    solveTranspose: function( matrix ) {\r\n      return this.transpose().solve( matrix.transpose() );\r\n    },\r\n\r\n    inverse: function() {\r\n      return this.solve( Matrix.identity( this.m, this.m ) );\r\n    },\r\n\r\n    det: function() {\r\n      return new dot.LUDecomposition( this ).det();\r\n    },\r\n\r\n    rank: function() {\r\n      return new dot.SingularValueDecomposition( this ).rank();\r\n    },\r\n\r\n    cond: function() {\r\n      return new dot.SingularValueDecomposition( this ).cond();\r\n    },\r\n\r\n    trace: function() {\r\n      var t = 0;\r\n      for ( var i = 0; i < Math.min( this.m, this.n ); i++ ) {\r\n        t += this.entries[ this.index( i, i ) ];\r\n      }\r\n      return t;\r\n    },\r\n\r\n    checkMatrixDimensions: function( matrix ) {\r\n      if ( matrix.m !== this.m || matrix.n !== this.n ) {\r\n        throw new Error( \"Matrix dimensions must agree.\" );\r\n      }\r\n    },\r\n\r\n    toString: function() {\r\n      var result = \"\";\r\n      result += \"dim: \" + this.getRowDimension() + \"x\" + this.getColumnDimension() + \"\\n\";\r\n      for ( var row = 0; row < this.getRowDimension(); row++ ) {\r\n        for ( var col = 0; col < this.getColumnDimension(); col++ ) {\r\n          result += this.get( row, col ) + \" \";\r\n        }\r\n        result += \"\\n\";\r\n      }\r\n      return result;\r\n    },\r\n\r\n    // returns a vector that is contained in the specified column\r\n    extractVector2: function( column ) {\r\n      assert && assert( this.m === 2 ); // rows should match vector dimension\r\n      return new dot.Vector2( this.get( 0, column ), this.get( 1, column ) );\r\n    },\r\n\r\n    // returns a vector that is contained in the specified column\r\n    extractVector3: function( column ) {\r\n      assert && assert( this.m === 3 ); // rows should match vector dimension\r\n      return new dot.Vector3( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ) );\r\n    },\r\n\r\n    // returns a vector that is contained in the specified column\r\n    extractVector4: function( column ) {\r\n      assert && assert( this.m === 4 ); // rows should match vector dimension\r\n      return new dot.Vector4( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ), this.get( 3, column ) );\r\n    },\r\n\r\n    isMatrix: true\r\n  };\r\n\r\n  Matrix.identity = function( m, n ) {\r\n    var result = new Matrix( m, n );\r\n    for ( var i = 0; i < m; i++ ) {\r\n      for ( var j = 0; j < n; j++ ) {\r\n        result.entries[result.index( i, j )] = (i === j ? 1.0 : 0.0);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  Matrix.rowVector2 = function( vector ) {\r\n    return new Matrix( 1, 2, [vector.x, vector.y] );\r\n  };\r\n\r\n  Matrix.rowVector3 = function( vector ) {\r\n    return new Matrix( 1, 3, [vector.x, vector.y, vector.z] );\r\n  };\r\n\r\n  Matrix.rowVector4 = function( vector ) {\r\n    return new Matrix( 1, 4, [vector.x, vector.y, vector.z, vector.w] );\r\n  };\r\n\r\n  Matrix.rowVector = function( vector ) {\r\n    if ( vector.isVector2 ) {\r\n      return Matrix.rowVector2( vector );\r\n    }\r\n    else if ( vector.isVector3 ) {\r\n      return Matrix.rowVector3( vector );\r\n    }\r\n    else if ( vector.isVector4 ) {\r\n      return Matrix.rowVector4( vector );\r\n    }\r\n    else {\r\n      throw new Error( \"undetected type of vector: \" + vector.toString() );\r\n    }\r\n  };\r\n\r\n  Matrix.columnVector2 = function( vector ) {\r\n    return new Matrix( 2, 1, [vector.x, vector.y] );\r\n  };\r\n\r\n  Matrix.columnVector3 = function( vector ) {\r\n    return new Matrix( 3, 1, [vector.x, vector.y, vector.z] );\r\n  };\r\n\r\n  Matrix.columnVector4 = function( vector ) {\r\n    return new Matrix( 4, 1, [vector.x, vector.y, vector.z, vector.w] );\r\n  };\r\n\r\n  Matrix.columnVector = function( vector ) {\r\n    if ( vector.isVector2 ) {\r\n      return Matrix.columnVector2( vector );\r\n    }\r\n    else if ( vector.isVector3 ) {\r\n      return Matrix.columnVector3( vector );\r\n    }\r\n    else if ( vector.isVector4 ) {\r\n      return Matrix.columnVector4( vector );\r\n    }\r\n    else {\r\n      throw new Error( \"undetected type of vector: \" + vector.toString() );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Create a Matrix where each column is a vector\r\n   */\r\n\r\n  Matrix.fromVectors2 = function( vectors ) {\r\n    var dimension = 2;\r\n    var n = vectors.length;\r\n    var data = new Float32Array( dimension * n );\r\n\r\n    for ( var i = 0; i < n; i++ ) {\r\n      var vector = vectors[i];\r\n      data[i] = vector.x;\r\n      data[i + n] = vector.y;\r\n    }\r\n\r\n    return new Matrix( dimension, n, data, true );\r\n  };\r\n\r\n  Matrix.fromVectors3 = function( vectors ) {\r\n    var dimension = 3;\r\n    var n = vectors.length;\r\n    var data = new Float32Array( dimension * n );\r\n\r\n    for ( var i = 0; i < n; i++ ) {\r\n      var vector = vectors[i];\r\n      data[i] = vector.x;\r\n      data[i + n] = vector.y;\r\n      data[i + 2 * n] = vector.z;\r\n    }\r\n\r\n    return new Matrix( dimension, n, data, true );\r\n  };\r\n\r\n  Matrix.fromVectors4 = function( vectors ) {\r\n    var dimension = 4;\r\n    var n = vectors.length;\r\n    var data = new Float32Array( dimension * n );\r\n\r\n    for ( var i = 0; i < n; i++ ) {\r\n      var vector = vectors[i];\r\n      data[i] = vector.x;\r\n      data[i + n] = vector.y;\r\n      data[i + 2 * n] = vector.z;\r\n      data[i + 3 * n] = vector.w;\r\n    }\r\n\r\n    return new Matrix( dimension, n, data, true );\r\n  };\r\n  \r\n  return Matrix;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * An immutable permutation that can permute an array\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Permutation',['require','ASSERT/assert','DOT/dot','PHET_CORE/isArray','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var isArray = require( 'PHET_CORE/isArray' );\r\n  require( 'DOT/Util' ); // for rangeInclusive\r\n  \r\n  // Creates a permutation that will rearrange a list so that newList[i] = oldList[permutation[i]]\r\n  var Permutation = function Permutation( indices ) {\r\n    this.indices = indices;\r\n  };\r\n\r\n  // An identity permutation with a specific number of elements\r\n  Permutation.identity = function( size ) {\r\n    assert && assert( size >= 0 );\r\n    var indices = new Array( size );\r\n    for ( var i = 0; i < size; i++ ) {\r\n      indices[i] = i;\r\n    }\r\n    return new Permutation( indices );\r\n  };\r\n\r\n  // lists all permutations that have a given size\r\n  Permutation.permutations = function( size ) {\r\n    var result = [];\r\n    Permutation.forEachPermutation( dot.rangeInclusive( 0, size - 1 ), function( integers ) {\r\n      result.push( new Permutation( integers ) );\r\n    } );\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Call our function with each permutation of the provided list PREFIXED by prefix, in lexicographic order\r\n   *\r\n   * @param array   List to generate permutations of\r\n   * @param prefix   Elements that should be inserted at the front of each list before each call\r\n   * @param callback Function to call\r\n   */\r\n  function recursiveForEachPermutation( array, prefix, callback ) {\r\n    if ( array.length === 0 ) {\r\n      callback.call( undefined, prefix );\r\n    }\r\n    else {\r\n      for ( var i = 0; i < array.length; i++ ) {\r\n        var element = array[i];\r\n\r\n        // remove the element from the array\r\n        var nextArray = array.slice( 0 );\r\n        nextArray.splice( i, 1 );\r\n\r\n        // add it into the prefix\r\n        var nextPrefix = prefix.slice( 0 );\r\n        nextPrefix.push( element );\r\n\r\n        recursiveForEachPermutation( nextArray, nextPrefix, callback );\r\n      }\r\n    }\r\n  }\r\n\r\n  Permutation.forEachPermutation = function( array, callback ) {\r\n    recursiveForEachPermutation( array, [], callback );\r\n  };\r\n\r\n  Permutation.prototype = {\r\n    constructor: Permutation,\r\n\r\n    size: function() {\r\n      return this.indices.length;\r\n    },\r\n\r\n    apply: function( arrayOrInt ) {\r\n      if ( isArray( arrayOrInt ) ) {\r\n        if ( arrayOrInt.length !== this.size() ) {\r\n          throw new Error( \"Permutation length \" + this.size() + \" not equal to list length \" + arrayOrInt.length );\r\n        }\r\n\r\n        // permute it as an array\r\n        var result = new Array( arrayOrInt.length );\r\n        for ( var i = 0; i < arrayOrInt.length; i++ ) {\r\n          result[i] = arrayOrInt[ this.indices[i] ];\r\n        }\r\n        return result;\r\n      }\r\n      else {\r\n        // permute a single index\r\n        return this.indices[ arrayOrInt ];\r\n      }\r\n    },\r\n\r\n    // The inverse of this permutation\r\n    inverted: function() {\r\n      var newPermutation = new Array( this.size() );\r\n      for ( var i = 0; i < this.size(); i++ ) {\r\n        newPermutation[this.indices[i]] = i;\r\n      }\r\n      return new Permutation( newPermutation );\r\n    },\r\n\r\n    withIndicesPermuted: function( indices ) {\r\n      var result = [];\r\n      var that = this;\r\n      Permutation.forEachPermutation( indices, function( integers ) {\r\n        var oldIndices = that.indices;\r\n        var newPermutation = oldIndices.slice( 0 );\r\n\r\n        for ( var i = 0; i < indices.length; i++ ) {\r\n          newPermutation[indices[i]] = oldIndices[integers[i]];\r\n        }\r\n        result.push( new Permutation( newPermutation ) );\r\n      } );\r\n      return result;\r\n    },\r\n\r\n    toString: function() {\r\n      return \"P[\" + this.indices.join( \", \" ) + \"]\";\r\n    }\r\n  };\r\n\r\n  Permutation.testMe = function( console ) {\r\n    var a = new Permutation( [ 1, 4, 3, 2, 0 ] );\r\n    console.log( a.toString() );\r\n\r\n    var b = a.inverted();\r\n    console.log( b.toString() );\r\n\r\n    console.log( b.withIndicesPermuted( [ 0, 3, 4 ] ).toString() );\r\n\r\n    console.log( Permutation.permutations( 4 ).toString() );\r\n  };\r\n  \r\n  return Permutation;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 3-dimensional ray\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Ray3',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  dot.Ray3 = function Ray3( pos, dir ) {\r\n    this.pos = pos;\r\n    this.dir = dir;\r\n  };\r\n  var Ray3 = dot.Ray3;\r\n  \r\n  Ray3.prototype = {\r\n    constructor: Ray3,\r\n\r\n    shifted: function( distance ) {\r\n      return new Ray3( this.pointAtDistance( distance ), this.dir );\r\n    },\r\n\r\n    pointAtDistance: function( distance ) {\r\n      return this.pos.plus( this.dir.timesScalar( distance ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return this.pos.toString() + \" => \" + this.dir.toString();\r\n    }\r\n  };\r\n  \r\n  return Ray3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Forward and inverse transforms with 4x4 matrices, allowing flexibility including affine and perspective transformations.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Transform4',['require','DOT/dot','DOT/Matrix4','DOT/Vector3','DOT/Ray3'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Matrix4' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Ray3' );\r\n  \r\n  // takes a 4x4 matrix\r\n  dot.Transform4 = function Transform4( matrix ) {\r\n    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices\r\n    this.set( matrix === undefined ? dot.Matrix4.IDENTITY : matrix );\r\n  };\r\n  var Transform4 = dot.Transform4;\r\n  \r\n  Transform4.prototype = {\r\n    constructor: Transform4,\r\n    \r\n    set: function( matrix ) {\r\n      this.matrix = matrix;\r\n      \r\n      // compute these lazily\r\n      this.inverse = null;\r\n      this.matrixTransposed = null; // since WebGL won't allow transpose == true\r\n      this.inverseTransposed = null;\r\n    },\r\n    \r\n    getMatrix: function() {\r\n      return this.matrix;\r\n    },\r\n    \r\n    getInverse: function() {\r\n      if ( this.inverse === null ) {\r\n        this.inverse = this.matrix.inverted();\r\n      }\r\n      return this.inverse;\r\n    },\r\n    \r\n    getMatrixTransposed: function() {\r\n      if ( this.matrixTransposed === null ) {\r\n        this.matrixTransposed = this.matrix.transposed();\r\n      }\r\n      return this.matrixTransposed;\r\n    },\r\n    \r\n    getInverseTransposed: function() {\r\n      if ( this.inverseTransposed === null ) {\r\n        this.inverseTransposed = this.getInverse().transposed();\r\n      }\r\n      return this.inverseTransposed;\r\n    },\r\n    \r\n    prepend: function( matrix ) {\r\n      this.set( matrix.timesMatrix( this.matrix ) );\r\n    },\r\n    \r\n    append: function( matrix ) {\r\n      this.set( this.matrix.timesMatrix( matrix ) );\r\n    },\r\n    \r\n    prependTransform: function( transform ) {\r\n      this.prepend( transform.matrix );\r\n    },\r\n    \r\n    appendTransform: function( transform ) {\r\n      this.append( transform.matrix );\r\n    },\r\n    \r\n    isIdentity: function() {\r\n      return this.matrix.type === dot.Matrix4.Types.IDENTITY;\r\n    },\r\n    \r\n    // applies the 2D affine transform part of the transformation\r\n    applyToCanvasContext: function( context ) {\r\n      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m03(), this.matrix.m13() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * forward transforms (for Vector3 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n     \r\n    // transform a position (includes translation)\r\n    transformPosition3: function( vec3 ) {\r\n      return this.matrix.timesVector3( vec3 );\r\n    },\r\n    \r\n    // transform a vector (exclude translation)\r\n    transformDelta3: function( vec3 ) {\r\n      return this.matrix.timesRelativeVector3( vec3 );\r\n    },\r\n    \r\n    // transform a normal vector (different than a normal vector)\r\n    transformNormal3: function( vec3 ) {\r\n      return this.getInverse().timesTransposeVector3( vec3 );\r\n    },\r\n    \r\n    transformDeltaX: function( x ) {\r\n      return this.transformDelta3( new dot.Vector3( x, 0, 0 ) ).x;\r\n    },\r\n    \r\n    transformDeltaY: function( y ) {\r\n      return this.transformDelta3( new dot.Vector3( 0, y, 0 ) ).y;\r\n    },\r\n    \r\n    transformDeltaZ: function( z ) {\r\n      return this.transformDelta3( new dot.Vector3( 0, 0, z ) ).z;\r\n    },\r\n    \r\n    transformRay: function( ray ) {\r\n      return new dot.Ray3(\r\n          this.transformPosition3( ray.pos ),\r\n          this.transformPosition3( ray.pos.plus( ray.dir ) ).minus( this.transformPosition3( ray.pos ) ) );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * inverse transforms (for Vector3 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n     \r\n    inversePosition3: function( vec3 ) {\r\n      return this.getInverse().timesVector3( vec3 );\r\n    },\r\n    \r\n    inverseDelta3: function( vec3 ) {\r\n      // inverse actually has the translation rolled into the other coefficients, so we have to make this longer\r\n      return this.inversePosition3( vec3 ).minus( this.inversePosition3( dot.Vector3.ZERO ) );\r\n    },\r\n    \r\n    inverseNormal3: function( vec3 ) {\r\n      return this.matrix.timesTransposeVector3( vec3 );\r\n    },\r\n    \r\n    inverseDeltaX: function( x ) {\r\n      return this.inverseDelta3( new dot.Vector3( x, 0, 0 ) ).x;\r\n    },\r\n    \r\n    inverseDeltaY: function( y ) {\r\n      return this.inverseDelta3( new dot.Vector3( 0, y, 0 ) ).y;\r\n    },\r\n    \r\n    inverseDeltaZ: function( z ) {\r\n      return this.inverseDelta3( new dot.Vector3( 0, 0, z ) ).z;\r\n    },\r\n    \r\n    inverseRay: function( ray ) {\r\n      return new dot.Ray3(\r\n          this.inversePosition3( ray.pos ),\r\n          this.inversePosition3( ray.pos.plus( ray.dir ) ).minus( this.inversePosition3( ray.pos ) )\r\n      );\r\n    }\r\n  };\r\n  \r\n  return Transform4;\r\n} );\r\n","\n\r\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\ndefine( 'DOT/main',[\r\n  'DOT/dot',\r\n  'DOT/Bounds2',\r\n  'DOT/Complex',\r\n  'DOT/ConvexHull2',\r\n  'DOT/Dimension2',\r\n  'DOT/EigenvalueDecomposition',\r\n  'DOT/LinearFunction',\r\n  'DOT/LUDecomposition',\r\n  'DOT/Matrix',\r\n  'DOT/Matrix3',\r\n  'DOT/Matrix4',\r\n  'DOT/Permutation',\r\n  'DOT/QRDecomposition',\r\n  'DOT/Ray2',\r\n  'DOT/Ray3',\r\n  'DOT/SingularValueDecomposition',\r\n  'DOT/Transform3',\r\n  'DOT/Transform4',\r\n  'DOT/Util',\r\n  'DOT/Vector2',\r\n  'DOT/Vector3',\r\n  'DOT/Vector4'\r\n  ], function( dot ) {\r\n    'use strict';\r\n    return dot;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A method of calling an overridden super-type method.\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'PHET_CORE/callSuper',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  /**\r\n   * A somewhat ugly method of calling an overridden super-type method.\r\n   * <p>\r\n   * Example:\r\n   * <code>\r\n   * function SuperType() {\r\n   * }\r\n   *\r\n   * SuperType.prototype.reset = function() {...}\r\n   *\r\n   * function SubType() {\r\n   *    SuperType.call( this ); // constructor stealing\r\n   * }\r\n   *\r\n   * SubType.prototype = new SuperType(); // prototype chaining\r\n   *\r\n   * SubType.prototype.reset = function() {\r\n   *     Inheritance.callSuper( SuperType, \"reset\", this ); // call overridden super method\r\n   *     // do subtype-specific stuff\r\n   * }\r\n   * </code>\r\n   *\r\n   * @param supertype\r\n   * @param {String} name\r\n   * @param context typically this\r\n   * @return {Function}\r\n   */\r\n  function callSuper( supertype, name, context ) {\r\n    (function () {\r\n      var fn = supertype.prototype[name];\r\n      Function.call.apply( fn, arguments );\r\n    })( context );\r\n  }\r\n\r\n  return callSuper;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Creates an array of results from an iterator that takes a callback.\r\n *\r\n * For instance, if calling a function f( g ) will call g( 1 ), g( 2 ), and g( 3 ),\r\n * collect( function( callback ) { f( callback ); } );\r\n * will return [1,2,3].\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'PHET_CORE/collect',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function collect( iterate ) {\r\n    var result = [];\r\n    iterate( function( ob ) {\r\n      result.push( ob );\r\n    } );\r\n    return result;\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Escaping of HTML content that will be placed in the body, inside an element as a node.\r\n *\r\n * This is NOT for escaping something in other HTML contexts, for example as an attribute value\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\ndefine( 'PHET_CORE/escapeHTML',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function escapeHTML( str ) {\r\n    // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet\r\n    // HTML Entity Encoding\r\n    return str.replace( /&/g, '&amp;' )\r\n              .replace( /</g, '&lt;' )\r\n              .replace( />/g, '&gt;' )\r\n              .replace( /\\\"/g, '&quot;' )\r\n              .replace( /\\'/g, '&#x27;' )\r\n              .replace( /\\//g, '&#x2F;' );\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Prototype chaining using Parasitic Combination Inheritance\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'PHET_CORE/inheritPrototype',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  /**\r\n   * Use this function to do prototype chaining using Parasitic Combination Inheritance.\r\n   * Instead of calling the supertype's constructor to assign a prototype (as is done\r\n   * in Combination Inheritance), you create a copy of the supertype's prototype.\r\n   * <br>\r\n   * Here's the basic pattern:\r\n   * <br>\r\n   * <code>\r\n   * function Supertype(...) {...}\r\n   *\r\n   * function Subtype(...) {\r\n           *     Supertype.call(this, ...); // constructor stealing, called second\r\n           *     ...\r\n           * }\r\n   *\r\n   * inheritPrototype( Subtype, Supertype ); // prototype chaining, called first\r\n   * </code>\r\n   * <br>\r\n   * (source: JavaScript for Web Developers, N. Zakas, Wrox Press, p. 212-215)\r\n   */\r\n  function inheritPrototype( subtype, supertype ) {\r\n    var prototype = Object( supertype.prototype ); // create a clone of the supertype's prototype\r\n    prototype.constructor = subtype; // account for losing the default constructor when prototype is overwritten\r\n    subtype.prototype = prototype; // assign cloned prototype to subtype\r\n  }\r\n\r\n  return inheritPrototype;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Loads a script\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'PHET_CORE/loadScript',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  /*\r\n   * Load a script. The only required argument is src, and can be specified either as\r\n   * loadScript( \"<url>\" ) or loadScript( { src: \"<url>\", ... other options ... } ).\r\n   *\r\n   * Arguments:\r\n   *   src:         The source of the script to load\r\n   *   callback:    A callback to call (with no arguments) once the script is loaded and has been executed\r\n   *   async:       Whether the script should be loaded asynchronously. Defaults to true\r\n   *   cacheBuster: Whether the URL should have an appended query string to work around caches\r\n   */\r\n  return function loadScript( args ) {\r\n    // handle a string argument\r\n    if ( typeof args === 'string' ) {\r\n      args = { src: args };\r\n    }\r\n    \r\n    var src         = args.src;\r\n    var callback    = args.callback;\r\n    var async       = args.async === undefined ? true : args.async;\r\n    var cacheBuster = args.cacheBuster === undefined ? false : args.cacheBuster;\r\n    \r\n    var called = false;\r\n    \r\n    var script = document.createElement( 'script' );\r\n    script.type = 'text/javascript';\r\n    script.async = async;\r\n    script.onload = script.onreadystatechange = function() {\r\n      var state = this.readyState;\r\n      if ( state && state !== \"complete\" && state !== \"loaded\" ) {\r\n        return;\r\n      }\r\n      \r\n      if ( !called ) {\r\n        called = true;\r\n        \r\n        if ( callback ) {\r\n          callback();\r\n        }\r\n      }\r\n    };\r\n    \r\n    // make sure things aren't cached, just in case\r\n    script.src = src + ( cacheBuster ? '?random=' + Math.random().toFixed( 10 ) : '' );\r\n    \r\n    var other = document.getElementsByTagName( 'script' )[0];\r\n    other.parentNode.insertBefore( script, other );\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\ndefine( 'PHET_CORE/main',['require','PHET_CORE/callSuper','PHET_CORE/collect','PHET_CORE/escapeHTML','PHET_CORE/inherit','PHET_CORE/inheritPrototype','PHET_CORE/isArray','PHET_CORE/extend','PHET_CORE/loadScript'],function( require ) {\r\n  'use strict';\r\n  \r\n  return {\r\n    callSuper: require( 'PHET_CORE/callSuper' ),\r\n    collect: require( 'PHET_CORE/collect' ),\r\n    escapeHTML: require( 'PHET_CORE/escapeHTML' ),\r\n    inherit: require( 'PHET_CORE/inherit' ),\r\n    inheritPrototype: require( 'PHET_CORE/inheritPrototype' ),\r\n    isArray: require( 'PHET_CORE/isArray' ),\r\n    extend: require( 'PHET_CORE/extend' ),\r\n    loadScript: require( 'PHET_CORE/loadScript' )\r\n  };\r\n} );\r\n","\n\r\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\nif ( window.has ) {\r\n  window.has.add( 'assert.kite', function( global, document, anElement ) {\r\n    'use strict';\r\n    return false;\r\n  } );\r\n  window.has.add( 'assert.kite.extra', function( global, document, anElement ) {\r\n    'use strict';\r\n    return false;\r\n  } );\r\n}\r\n\r\nwindow.loadedKiteConfig = true;\r\n\r\nrequire.config( {\r\n  deps: [ 'main', 'DOT/main', 'PHET_CORE/main' ],\r\n\r\n  paths: {\r\n    underscore: '../lib/lodash.min-1.0.0-rc.3',\r\n    KITE: '.',\r\n    DOT: '../common/dot/js',\r\n    PHET_CORE: '../common/phet-core/js',\r\n    ASSERT: '../common/assert/js'\r\n  },\r\n  \r\n  shim: {\r\n    underscore: { exports: '_' }\r\n  },\r\n\r\n  urlArgs: new Date().getTime() // add cache buster query string to make browser refresh actually reload everything\r\n} );\r\n\ndefine(\"production-config\", function(){});\n"]}