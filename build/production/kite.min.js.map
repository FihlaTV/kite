{"version":3,"file":"kite.min.js","sources":["../node_modules/grunt-requirejs/node_modules/almond/almond.js","../../phet-core/js/phetAllocation.js","../../phet-core/js/core.js","kite.js","../../dot/js/dot.js","../../phet-core/js/extend.js","../../phet-core/js/inherit.js","../../phet-core/js/Poolable.js","../../dot/js/Util.js","../../dot/js/Vector2.js","../../dot/js/Bounds2.js","segments/Segment.js","../../dot/js/Ray2.js","segments/Line.js","segments/Arc.js","util/Subpath.js","parser/svgPath.js","util/LineStyles.js","../../dot/js/Vector4.js","../../dot/js/Vector3.js","../../dot/js/Matrix4.js","../../dot/js/Matrix3.js","segments/Quadratic.js","segments/Cubic.js","../../dot/js/Transform3.js","segments/EllipticalArc.js","Shape.js","../../dot/js/Bounds3.js","main.js","../../dot/js/Complex.js","../../dot/js/ConvexHull2.js","../../dot/js/Dimension2.js","../../dot/js/EigenvalueDecomposition.js","../../dot/js/LinearFunction.js","../../dot/js/LUDecomposition.js","../../dot/js/SingularValueDecomposition.js","../../phet-core/js/isArray.js","../../dot/js/QRDecomposition.js","../../dot/js/Matrix.js","../../axon/js/Property.js","../../axon/js/axon.js","../../dot/js/ObservableBounds2.js","../../dot/js/ObservableMatrix3.js","../../dot/js/ObservableVector2.js","../../dot/js/Permutation.js","../../dot/js/Plane3.js","../../dot/js/Quaternion.js","../../dot/js/Rectangle.js","../../dot/js/Ray3.js","../../dot/js/Sphere3.js","../../dot/js/Transform4.js","../../phet-core/js/arrayRemove.js","../../dot/js/main.js","../../phet-core/js/cleanArray.js","../../phet-core/js/collect.js","../../phet-core/js/detectPrefix.js","../../phet-core/js/detectPrefixEvent.js","../../phet-core/js/escapeHTML.js","../../phet-core/js/EventTimer.js","../../phet-core/js/loadScript.js","../../phet-core/js/partition.js","../../phet-core/js/pairs.js","../../phet-core/js/platform.js","../../phet-core/js/profiler.js","config.js","../../phet-core/js/main.js"],"names":[],"mappings":"CAAA,WACA,IAAA,OAAA,eAAA,KACA,KAAA,IAAA,OAAA,mCASA,WAGA,OAAA,WAAA,OAAA,eACA,OAAA,WAAA,eAAA,OAAA,WAAA,gBAAA,SAAA,EAAA,GACA,GAAA,GAAA,kBAAA,GAAA,IAAA,CAEA,KAAA,EAAA,CAGA,GAAA,OAAA,WAAA,gCAAA,OAAA,UAAA,QACA,IAAA,KAAA,IAAA,OACA,MAAA,GAAA,EAAA,EAAA,aAAA,EAAA,MAGA,KAAA,IAAA,OAAA,qBAAA,KAIA,OAAA,OAAA,OAAA,QAAA,KACA,OAAA,WAAA,OAAA,YAAA,KAEA,OAAA,WAAA,aAAA,WACA,OAAA,OAAA,OAAA,WAAA,eACA,OAAA,SAAA,OAAA,QAAA,KAAA,OAAA,QAAA,IAAA,oBAEA,OAAA,WAAA,cAAA,WACA,OAAA,OAAA,KACA,OAAA,SAAA,OAAA,QAAA,KAAA,OAAA,QAAA,IAAA,qBAGA,OAAA,WAAA,iBAAA,WACA,OAAA,WAAA,OAAA,WAAA,eACA,OAAA,SAAA,OAAA,QAAA,KAAA,OAAA,QAAA,IAAA,wBAEA,OAAA,WAAA,kBAAA,WACA,OAAA,WAAA,KACA,OAAA,SAAA,OAAA,QAAA,KAAA,OAAA,QAAA,IAAA,2BAaA,IAAA,GAAA,EAAA,GACA,SAAA,GAUA,QAAA,GAAA,EAAA,GACA,MAAA,GAAA,KAAA,EAAA,GAWA,QAAA,GAAA,EAAA,GACA,GAAA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,MAAA,KACA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,QAGA,IAAA,GAAA,MAAA,EAAA,OAAA,GAIA,GAAA,EAAA,CAkBA,IAZA,EAAA,EAAA,MAAA,EAAA,EAAA,OAAA,GACA,EAAA,EAAA,MAAA,KACA,EAAA,EAAA,OAAA,EAGA,EAAA,cAAA,EAAA,KAAA,EAAA,MACA,EAAA,GAAA,EAAA,GAAA,QAAA,EAAA,KAGA,EAAA,EAAA,OAAA,GAGA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EAEA,GADA,EAAA,EAAA,GACA,MAAA,EACA,EAAA,OAAA,EAAA,GACA,GAAA,MAEA,IAAA,OAAA,EAAA,CACA,GAAA,IAAA,IAAA,OAAA,EAAA,IAAA,OAAA,EAAA,IAOA,KAEA,GAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,GAAA,GAMA,EAAA,EAAA,KAAA,SAEA,KAAA,EAAA,QAAA,QAGA,EAAA,EAAA,UAAA,GAKA,KAAA,GAAA,IAAA,EAAA,CAGA,IAFA,EAAA,EAAA,MAAA,KAEA,EAAA,EAAA,OAAA,EAAA,EAAA,GAAA,EAAA,CAGA,GAFA,EAAA,EAAA,MAAA,EAAA,GAAA,KAAA,KAEA,EAGA,IAAA,EAAA,EAAA,OAAA,EAAA,EAAA,GAAA,EAKA,GAJA,EAAA,EAAA,EAAA,MAAA,EAAA,GAAA,KAAA,MAIA,IACA,EAAA,EAAA,IACA,CAEA,EAAA,EACA,EAAA,CACA,OAMA,GAAA,EACA,OAMA,GAAA,GAAA,EAAA,KACA,EAAA,EAAA,GACA,EAAA,IAIA,GAAA,IACA,EAAA,EACA,EAAA,GAGA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,EAAA,EAAA,KAAA,MAIA,MAAA,GAGA,QAAA,GAAA,EAAA,GACA,MAAA,YAIA,MAAA,GAAA,MAAA,EAAA,EAAA,KAAA,UAAA,GAAA,QAAA,EAAA,MAIA,QAAA,GAAA,GACA,MAAA,UAAA,GACA,MAAA,GAAA,EAAA,IAIA,QAAA,GAAA,GACA,MAAA,UAAA,GACA,EAAA,GAAA,GAIA,QAAA,GAAA,GACA,GAAA,EAAA,EAAA,GAAA,CACA,GAAA,GAAA,EAAA,SACA,GAAA,GACA,EAAA,IAAA,EACA,EAAA,MAAA,EAAA,GAGA,IAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GACA,KAAA,IAAA,OAAA,MAAA,EAEA,OAAA,GAAA,GAMA,QAAA,GAAA,GACA,GAAA,GACA,EAAA,EAAA,EAAA,QAAA,KAAA,EAKA,OAJA,GAAA,KACA,EAAA,EAAA,UAAA,EAAA,GACA,EAAA,EAAA,UAAA,EAAA,EAAA,EAAA,UAEA,EAAA,GAgDA,QAAA,GAAA,GACA,MAAA,YACA,MAAA,IAAA,EAAA,QAAA,EAAA,OAAA,QAzOA,GAAA,GAAA,EAAA,EAAA,EACA,KACA,KACA,KACA,KACA,EAAA,OAAA,UAAA,eACA,KAAA,MACA,EAAA,OAwLA,GAAA,SAAA,EAAA,GACA,GAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,EA6BA,OA3BA,GAAA,EAAA,GAEA,IACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,IAIA,EAEA,EADA,GAAA,EAAA,UACA,EAAA,UAAA,EAAA,EAAA,IAGA,EAAA,EAAA,IAIA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,IACA,EAAA,EAAA,MAMA,EAAA,EAAA,EAAA,IAAA,EAAA,EACA,EAAA,EACA,GAAA,EACA,EAAA,IAUA,GACA,QAAA,SAAA,GACA,MAAA,GAAA,IAEA,QAAA,SAAA,GACA,GAAA,GAAA,EAAA,EACA,OAAA,mBAAA,GACA,EAGA,EAAA,OAGA,OAAA,SAAA,GACA,OACA,GAAA,EACA,IAAA,GACA,QAAA,EAAA,GACA,OAAA,EAAA,MAKA,EAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EAAA,EAAA,EAGA,EAFA,KACA,QAAA,EAOA,IAHA,EAAA,GAAA,EAGA,cAAA,GAAA,aAAA,EAAA,CAKA,IADA,GAAA,EAAA,QAAA,EAAA,QAAA,UAAA,UAAA,UAAA,EACA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EAKA,GAJA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,EAAA,EAGA,YAAA,EACA,EAAA,GAAA,EAAA,QAAA,OAEA,IAAA,YAAA,EAEA,EAAA,GAAA,EAAA,QAAA,GACA,GAAA,MAEA,IAAA,WAAA,EAEA,EAAA,EAAA,GAAA,EAAA,OAAA,OAEA,IAAA,EAAA,EAAA,IACA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,OAEA,CAAA,IAAA,EAAA,EAKA,KAAA,IAAA,OAAA,EAAA,YAAA,EAJA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,OACA,EAAA,GAAA,EAAA,GAOA,EAAA,EAAA,EAAA,MAAA,EAAA,GAAA,GAAA,OAEA,IAIA,GAAA,EAAA,UAAA,GACA,EAAA,UAAA,EAAA,GACA,EAAA,GAAA,EAAA,QAEA,IAAA,GAAA,IAEA,EAAA,GAAA,QAIA,KAGA,EAAA,GAAA,IAIA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,gBAAA,GACA,MAAA,GAAA,GAEA,EAAA,GAAA,GAMA,EAAA,EAAA,EAAA,GAAA,EAEA,KAAA,EAAA,OAAA,CAMA,GAJA,EAAA,EACA,EAAA,MACA,EAAA,EAAA,KAAA,EAAA,WAEA,EACA,MAGA,GAAA,QAGA,EAAA,EACA,EAAA,EACA,EAAA,MAGA,EAAA,ECraA,MD0aA,GAAA,GAAA,aAIA,kBAAA,KACA,EAAA,EACA,EAAA,GAIA,EACA,EAAA,EAAA,EAAA,EAAA,GE/aA,WAAA,WACA,EAAA,EAAA,EAAA,EAAA,IACA,GDRA,GAOA,EAAA,OAAA,SAAA,GACA,MAAA,GAAA,IAMA,EAAA,SAAA,EAEA,EAAA,SAAA,EAAA,EAAA,GAGA,EAAA,SAIA,EAAA,EACA,MAGA,EAAA,EAAA,IAAA,EAAA,EAAA,KACA,EAAA,IAAA,EAAA,EAAA,KAIA,EAAA,KACA,QAAA,MAIA,EAAA,SAAA,cAIA,EAAA,kBAAA,WAAA,WAMA,WEhCA,EAAA,4BAAA,UAAA,kBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBCNA,ODQA,GAAA,eAAA,SAAA,GACA,GAAA,OAAA,MAAA,CACA,GAAA,EACA,KAAA,KAAA,IAAA,OACA,MAAA,GAAA,EAAA,EAAA,MAEA,OAAA,MAAA,KACA,OAAA,MAAA,IAAA,MAAA,EAAA,WAEA,IAAA,GAAA,OAAA,MAAA,EAEA,GAAA,QACA,EAAA,OAAA,GChCA,EAAA,OAAA,IAAA,EDiCA,EAAA,OAAA,GAAA,EC/BA,EAAA,OAAA,WACA,GAAA,GAAA,OAAA,KAAA,EAAA,OACA,GAAA,EAAA,OAAA,EAAA,SAAA,GAAA,MAAA,GAAA,OAAA,KACA,EAAA,KAAA,EAAA,SAAA,GACA,QAAA,IAAA,EAAA,OAAA,GAAA,KAAA,QAMA,EAAA,iBAcA,EAAA,aAAA,UAAA,4BAAA,SAAA,GAIA,OAAA,eAAA,EAAA,4BAGA,OAAA,KAAA,OAAA,MAAA,IClCA,IAAA,IACA,UAAA,SAAA,GACA,MAAA,GAAA,QAAA,KAUA,OALA,QAAA,OACA,OAAA,KAAA,KAAA,GAIA,IAKA,EAAA,WAAA,UAAA,4BAAA,SAAA,GAIA,OAAA,eAAA,EAAA,4BAGA,OAAA,KAAA,OAAA,MAAA,IAEA,IAAA,GAAA,QAAA,KACA,OAAA,UAAA,QC3BA,IAAA,GACA,MAAA,IAAA,GAAA,QAAA,UAAA,GAAA,UAAA,GACA,KAAA,GACA,MAAA,IAAA,GAAA,QAAA,UAAA,GAAA,UAAA,GAAA,UAAA,GACA,KAAA,GACA,MAAA,IAAA,GAAA,QAAA,UAAA,GAAA,UAAA,GAAA,UAAA,GAAA,UAAA,GACA,SACA,KAAA,IAAA,OAAA,4BAaA,OARA,GAAA,UAAA,OAAA,aAAA,OAAA,aAAA,OAAA,MAGA,OAAA,OACA,OAAA,KAAA,IAAA,GAIA,IAaA,EAAA,oBAAA,UAAA,kBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,iBAaA,OAXA,GAAA,OAAA,SAAA,GAQA,MAPA,GAAA,KAAA,MAAA,UAAA,MAAA,KAAA,UAAA,GAAA,SAAA,GACA,GAAA,EACA,IAAA,GAAA,KAAA,GACA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,MAIA,GAGA,EAAA,SC/BA,EAAA,qBAAA,UAAA,iBAAA,oBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,kBACA,EAAA,EAAA,mBA2BA,OAnBA,GAAA,QAAA,SAAA,EAAA,EAAA,EAAA,GAGA,QAAA,MAaA,MAXA,GAAA,UAAA,EAAA,UAEA,EAAA,UAAA,EACA,GAAA,IACA,YAAA,GACA,GAIA,EAAA,EAAA,GAEA,GAGA,EAAA,UAUA,EAAA,sBAAA,UAAA,iBAAA,oBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,kBACA,EAAA,EAAA,mBCdA,ODmBA,GAAA,UACA,MAAA,SAAA,EAAA,GACA,GAAA,GAAA,EAAA,SAGA,GAAA,GACA,YAAA,GACA,YAAA,GACA,EAEA,IAAA,GAAA,EAAA,OAKA,GAAA,iBACA,EAAA,cAAA,WACA,MAAA,GAAA,OCpFA,EAAA,MAIA,EAAA,kBAKA,EAAA,SAAA,SAAA,GAEA,KAAA,EAAA,OAAA,GACA,EAAA,KAAA,EAAA,mBAKA,EAAA,SAAA,EAAA,cAgBA,EAAA,8BACA,EAAA,eAAA,EAAA,4BAAA,IAMA,EAAA,WAAA,WACA,EAAA,OAAA,EAAA,aACA,EAAA,KAAA,SAMA,EAAA,WAUA,EAAA,YAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAGA,GAAA,MACA,WAAA,WACA,MAAA,qBAGA,MAAA,SAAA,EAAA,EAAA,GACA,MAAA,GAAA,EACA,EAEA,EAAA,EACA,EAGA,GAKA,kBAAA,SAAA,EAAA,EAAA,GAGA,GAAA,GAAA,EAAA,EAGA,GAAA,EAAA,GAAA,CAMA,OALA,GAAA,IAEA,GAAA,GAGA,EAAA,GAIA,gBAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,mBAAA,GAAA,GAAA,IAIA,eAAA,SAAA,EAAA,GACA,GAAA,EAAA,EACA,QAGA,KAAA,GADA,GAAA,GAAA,OAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,IACA,EAAA,EAAA,GAAA,CAEA,OAAA,IAIA,eAAA,SAAA,EAAA,GACA,MAAA,GAAA,eAAA,EAAA,EAAA,EAAA,IAGA,UAAA,SAAA,GACA,MAAA,MAAA,GAAA,EAAA,KAGA,UAAA,SAAA,GACA,MAAA,KAAA,EAAA,KAAA,IAIA,IAAA,SAAA,EAAA,GACA,MAAA,KAAA,EAAA,EAAA,KAAA,IAAA,EAAA,EAAA,IAIA,qBAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAEA,EAAA,EAAA,EAAA,EAAA,EAEA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CAEA,OAAA,IAAA,GAAA,SACA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,EAAA,EAAA,GAAA,IAKA,sBAAA,SAAA,EAAA,EAAA,GACA,EAAA,SAAA,EAAA,KAAA,CAGA,IAAA,GAAA,GAAA,GAAA,QAEA,EAAA,EAAA,IACA,EAAA,EAAA,IACA,EAAA,EAAA,MAAA,GAGA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,mBACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAEA,MAAA,KAGA,IAAA,GAAA,EAAA,IAAA,GAAA,EAAA,IAAA,GACA,EAAA,KAAA,KAAA,GAAA,EAGA,EAAA,EAAA,EAGA,EAAA,EAAA,CAEA,IAAA,EAAA,EAEA,MAAA,KAGA,IAAA,GAAA,EAAA,gBAAA,GACA,EAAA,EAAA,MAAA,GAAA,YAEA,IAAA,EAAA,EAGA,OACA,SAAA,EACA,SAAA,EACA,OAAA,EAAA,UACA,aAAA,EAKA,IAAA,GAAA,EAAA,gBAAA,GACA,EAAA,EAAA,MAAA,GAAA,YAGA,QACA,SAAA,EACA,SAAA,EACA,OAAA,EACA,aAAA,IAMA,wBAAA,SAAA,EAAA,EAAA,GACA,GAAA,GAAA,GAGA,IAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,KAAA,IAAA,EAAA,GAAA,EACA,QAAA,EAAA,EAGA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,CACA,IAAA,EAAA,EACA,QAEA,IAAA,GAAA,KAAA,KAAA,EAGA,UACA,EAAA,IAAA,EAAA,KACA,EAAA,IAAA,EAAA,KAKA,oBAAA,SAAA,EAAA,EAAA,EAAA,GAIA,GAAA,GAAA,GAEA,IAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,KAAA,IAAA,EAAA,GAAA,EACA,MAAA,GAAA,wBAAA,EAAA,EAAA,EAEA,IAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,KAAA,IAAA,EAAA,GAAA,EACA,MAAA,GAAA,wBAAA,EAAA,EAAA,EAGA,IAAA,EACA,GAAA,EACA,GAAA,CAEA,IAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EACA,KAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,CAEA,IAAA,EAAA,EAAA,CAEA,GAAA,GAAA,KAAA,KAAA,EACA,QAAA,EAAA,SAAA,EAAA,GAAA,EAAA,SAAA,EAAA,GAAA,GAIA,GAAA,IAAA,EAAA,CAEA,GAAA,GAAA,EAAA,SAAA,GACA,EAAA,EAAA,CACA,SAAA,EAAA,EAAA,EAAA,EAAA,GAIA,GAAA,IAAA,EAAA,EAAA,CACA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,GACA,IAAA,GAAA,EAAA,KAAA,MAAA,EACA,SACA,EAAA,EAAA,KAAA,IAAA,EAAA,IACA,EAAA,EAAA,KAAA,KAAA,EAAA,EAAA,KAAA,IAAA,IACA,EAAA,EAAA,KAAA,KAAA,EAAA,EAAA,KAAA,IAAA,KAKA,SAAA,SAAA,GACA,MAAA,IAAA,EAAA,KAAA,IAAA,EAAA,EAAA,IAAA,KAAA,KAAA,EAAA,EAAA,IAKA,OAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,GAWA,QAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,IAAA,GAAA,GACA,EAAA,KAAA,MAAA,EAAA,GAAA,CACA,OAAA,GAAA,QAAA,IAIA,cAAA,SAAA,EAAA,GACA,MAAA,YAAA,EAAA,QAAA,EAAA,KAGA,UAAA,SAAA,GACA,MAAA,gBAAA,IAAA,EAAA,IAAA,GAUA,wBAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GACA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GACA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAGA,IAAA,IAAA,EACA,MAAA,KAGA,IAAA,GAAA,EAAA,EACA,EAAA,EAAA,CAGA,IAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,EAGA,CACA,GAAA,GAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,EACA,OAAA,IAAA,GAAA,QAAA,EAAA,GALA,MAAA,OAmBA,qBAAA,SAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,gBAAA,EACA,IAAA,IAAA,EAAA,MAAA,GAAA,gBAAA,EACA,IAAA,KAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,CACA,OAAA,GAAA,gBAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,GAAA,GAAA,QAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,MCpWA,cAAA,SAAA,EAAA,EAAA,GAAA,MAAA,MAAA,KAAA,KAAA,qBAAA,EAAA,EAAA,KAEA,mBAAA,SAAA,EAAA,EAAA,EAAA,GAIA,MAHA,UAAA,IACA,EAAA,GAEA,EAAA,aAAA,EAAA,EAAA,IAAA,GAGA,aAAA,SAAA,EAAA,EAAA,GACA,MAAA,MAAA,IAAA,EAAA,mBAAA,EAAA,EAAA,KAIA,mBAAA,SAAA,EAAA,EAAA,GACA,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAGA,MAAA,SAAA,GACA,MAAA,MAAA,IAAA,GAAA,KAAA,MAGA,IAAA,GAAA,EAAA,IAkBA,OAfA,GAAA,WAAA,EAAA,WACA,EAAA,MAAA,EAAA,MACA,EAAA,kBAAA,EAAA,kBACA,EAAA,gBAAA,EAAA,gBACA,EAAA,eAAA,EAAA,eACA,EAAA,eAAA,EAAA,eACA,EAAA,UAAA,EAAA,UACA,EAAA,UAAA,EAAA,UACA,EAAA,qBAAA,EAAA,qBACA,EAAA,sBAAA,EAAA,sBACA,EAAA,wBAAA,EAAA,wBACA,EAAA,oBAAA,EAAA,oBACA,EAAA,SAAA,EAAA,SACA,EAAA,OAAA,EAAA,OAEA,IAWA,EAAA,eAAA,UAAA,UAAA,oBAAA,qBAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WAEA,EAAA,EAAA,qBACA,EAAA,EAAA,qBACA,GAAA,YAGA,EAAA,QAAA,SAAA,EAAA,GAEA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EAOA,IAAA,GAAA,EAAA,OAEA,GAAA,YAAA,SAAA,EAAA,GACA,OAAA,GAAA,IAAA,SAAA,EAAA,IAGA,EAAA,WACA,YAAA,EACA,WAAA,EACA,UAAA,EAEA,UAAA,WACA,MAAA,MAAA,KAAA,KAAA,qBAGA,iBAAA,WACA,MAAA,MAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,GAIA,SAAA,SAAA,GACA,MAAA,MAAA,KAAA,KAAA,gBAAA,KAIA,WAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,EAAA,EACA,EAAA,KAAA,EAAA,CACA,OAAA,MAAA,KAAA,EAAA,EAAA,EAAA,IAIA,gBAAA,SAAA,GACA,GAAA,GAAA,KAAA,EAAA,EAAA,EACA,EAAA,KAAA,EAAA,EAAA,CACA,OAAA,GAAA,EAAA,EAAA,GAIA,kBAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,EAAA,EACA,EAAA,KAAA,EAAA,CACA,OAAA,GAAA,EAAA,EAAA,GAGA,IAAA,SAAA,GACA,MAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAGA,MAAA,SAAA,EAAA,GACA,MAAA,MAAA,EAAA,EAAA,KAAA,EAAA,GAGA,OAAA,SAAA,GACA,MAAA,MAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAGA,cAAA,SAAA,EAAA,GAIA,MAHA,KACA,EAAA,GAEA,KAAA,IAAA,KAAA,IAAA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,KAAA,EAAA,EAAA,KAAA,GAGA,SAAA,WACA,MAAA,UAAA,KAAA,IAAA,SAAA,KAAA,IAQA,KAAA,SAAA,GACA,MAAA,GACA,EAAA,IAAA,MAGA,GAAA,GAAA,KAAA,EAAA,KAAA,IAKA,YAAA,SAAA,GACA,MAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAGA,WAAA,WACA,GAAA,GAAA,KAAA,WACA,IAAA,IAAA,EACA,KAAA,IAAA,OAAA,2CAGA,OAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAIA,cAAA,SAAA,GACA,MAAA,MAAA,OAAA,aAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,MAAA,SAAA,GAGA,MAAA,MAAA,YAAA,IAGA,eAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,KAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,OAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,MAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,QAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,QAAA,WACA,MAAA,IAAA,IAAA,KAAA,GAAA,KAAA,IAGA,MAAA,WACA,MAAA,MAAA,MAAA,KAAA,EAAA,KAAA,IAIA,cAAA,WACA,MAAA,IAAA,GAAA,KAAA,GAAA,KAAA,IAGA,aAAA,SAAA,GACA,GAAA,GAAA,KAAA,YACA,EAAA,EAAA,WACA,OAAA,MAAA,KAAA,EAAA,OAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,KAGA,QAAA,SAAA,GACA,GAAA,GAAA,KAAA,QAAA,EACA,EAAA,KAAA,WACA,OAAA,IAAA,GAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,KAIA,MAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GAAA,IAIA,QAAA,SAAA,GACA,MAAA,MAAA,MAAA,EAAA,KAGA,SAAA,WACA,MAAA,WAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAGA,UAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,EAAA,KAAA,IAQA,MAAA,SAAA,EAAA,GAGA,MAFA,MAAA,EAAA,EACA,KAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAGA,IAAA,SAAA,GACA,MAAA,MAAA,MAAA,EAAA,EAAA,EAAA,IAIA,aAAA,SAAA,GACA,GAAA,GAAA,EAAA,KAAA,WACA,OAAA,MAAA,eAAA,IAGA,IAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,MAAA,SAAA,EAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,UAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,SAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,SAAA,SAAA,GAGA,MAAA,MAAA,eAAA,IAGA,kBAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,aAAA,SAAA,GACA,MAAA,MAAA,MAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,OAAA,WACA,MAAA,MAAA,OAAA,KAAA,GAAA,KAAA,IAGA,UAAA,WACA,GAAA,GAAA,KAAA,WACA,IAAA,IAAA,EACA,KAAA,IAAA,OAAA,2CAGA,OAAA,MAAA,aAAA,IAIA,OAAA,SAAA,GACA,GAAA,GAAA,KAAA,QAAA,EACA,EAAA,KAAA,WACA,OAAA,MAAA,MAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,KC5VA,SAAA,SAAA,EAAA,GACA,MAAA,MAAA,MAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,MAKA,EAAA,MAAA,GACA,eAAA,WAAA,MAAA,IAAA,IACA,4BAAA,SAAA,GACA,MAAA,UAAA,EAAA,GACA,MAAA,GAAA,OACA,EAAA,MAAA,MAAA,EAAA,GAGA,GAAA,GAAA,EAAA,OASA,EAAA,UAAA,SAAA,EAAA,GACA,EAAA,KAAA,KAAA,EAAA,GAEA,IAAA,GAAA,EAAA,SAqBA,OAnBA,GAAA,EAAA,GAGA,EAAA,sBAAA,SAAA,GACA,EAAA,UAAA,GAAA,WACA,KAAA,IAAA,OAAA,+BAAA,EAAA,4BAKA,EAAA,sBAAA,SACA,EAAA,sBAAA,QACA,EAAA,sBAAA,QAGA,EAAA,KAAA,GAAA,GAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,GAEA,IAkBA,EAAA,eAAA,UAAA,UAAA,qBAAA,eAAA,SAAA,GAGA,GAAA,GAAA,EAAA,WACA,EAAA,EAAA,qBAEA,GAAA,cAGA,IAAA,GAAA,GAAA,GAAA,OAGA,GAAA,QAAA,SAAA,EAAA,EAAA,EAAA,GAEA,KAAA,KAAA,EACA,KAAA,KAAA,EACA,KAAA,KAAA,EACA,KAAA,KAAA,EAIA,IAAA,GAAA,EAAA,OCjFA,ODmFA,GAAA,WACA,YAAA,EAEA,UAAA,EACA,UAAA,EAMA,SAAA,WAAA,MAAA,MAAA,KAAA,KAAA,MACA,GAAA,SAAA,MAAA,MAAA,YAEA,UAAA,WAAA,MAAA,MAAA,KAAA,KAAA,MACA,GAAA,UAAA,MAAA,MAAA,aAYA,KAAA,WAAA,MAAA,MAAA,MACA,GAAA,KAAA,MAAA,MAAA,QACA,KAAA,WAAA,MAAA,MAAA,MACA,GAAA,KAAA,MAAA,MAAA,QAEA,QAAA,WAAA,MAAA,MAAA,MACA,GAAA,QAAA,MAAA,MAAA,MACA,QAAA,WAAA,MAAA,MAAA,MACA,GAAA,OAAA,MAAA,MAAA,MACA,QAAA,WAAA,MAAA,MAAA,MACA,GAAA,SAAA,MAAA,MAAA,MACA,QAAA,WAAA,MAAA,MAAA,MACA,GAAA,UAAA,MAAA,MAAA,MAEA,WAAA,WAAA,OAAA,KAAA,KAAA,KAAA,MAAA,GACA,GAAA,WAAA,MAAA,MAAA,cACA,WAAA,WAAA,OAAA,KAAA,KAAA,KAAA,MAAA,GACA,GAAA,WAAA,MAAA,MAAA,cAEA,WAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,OACA,GAAA,WAAA,MAAA,MAAA,cACA,aAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,aAAA,KAAA,OACA,GAAA,aAAA,MAAA,MAAA,gBACA,YAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,OACA,GAAA,YAAA,MAAA,MAAA,eACA,cAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,eACA,GAAA,cAAA,MAAA,MAAA,iBACA,UAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,aAAA,KAAA,eACA,GAAA,UAAA,MAAA,MAAA,aACA,eAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,eACA,GAAA,eAAA,MAAA,MAAA,kBACA,cAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,OACA,GAAA,cAAA,MAAA,MAAA,iBACA,gBAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,aAAA,KAAA,OACA,GAAA,gBAAA,MAAA,MAAA,mBACA,eAAA,WAAA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,KAAA,OACA,GAAA,eAAA,MAAA,MAAA,kBAEA,QAAA,WAAA,MAAA,MAAA,WAAA,GAAA,KAAA,YAAA,GAEA,SAAA,WACA,MAAA,UAAA,KAAA,OAAA,SAAA,KAAA,OAAA,SAAA,KAAA,OAAA,SAAA,KAAA,OAGA,eAAA,WACA,MAAA,MAAA,WAAA,GAAA,KAAA,YAAA,GAGA,QAAA,WACA,OAAA,KAAA,WAAA,KAAA,YAIA,oBAAA,SAAA,EAAA,GACA,MAAA,MAAA,MAAA,GAAA,GAAA,KAAA,MAAA,KAAA,MAAA,GAAA,GAAA,KAAA,MAIA,cAAA,SAAA,GACA,MAAA,MAAA,oBAAA,EAAA,EAAA,EAAA,IAIA,eAAA,SAAA,GACA,MAAA,MAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAIA,iBAAA,SAAA,GAEA,OAAA,KAAA,aAAA,GAAA,WAIA,8BAAA,SAAA,GACA,GAEA,GAFA,EAAA,EAAA,EAAA,KAAA,KAAA,KAAA,KAAA,EAAA,EAAA,KAAA,KAAA,KAAA,KAAA,KACA,EAAA,EAAA,EAAA,KAAA,KAAA,KAAA,KAAA,EAAA,EAAA,KAAA,KAAA,KAAA,KAAA,IAEA,IAAA,OAAA,GAAA,OAAA,EAEA,MAAA,EAEA,IAAA,OAAA,EAGA,MADA,GAAA,EAAA,EAAA,EACA,EAAA,CAEA,IAAA,OAAA,EAGA,MADA,GAAA,EAAA,EAAA,EACA,EAAA,CAIA,IAAA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,CACA,OAAA,GAAA,EAAA,EAAA,GAKA,8BAAA,SAAA,GACA,GAAA,GAAA,EAAA,EAAA,KAAA,aAAA,KAAA,KAAA,KAAA,KACA,EAAA,EAAA,EAAA,KAAA,aAAA,KAAA,KAAA,KAAA,IAGA,OAFA,IAAA,EAAA,EACA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAGA,SAAA,WACA,MAAA,OAAA,KAAA,KAAA,IAAA,KAAA,KAAA,QAAA,KAAA,KAAA,IAAA,KAAA,KAAA,MAGA,OAAA,SAAA,GACA,MAAA,MAAA,OAAA,EAAA,MAAA,KAAA,OAAA,EAAA,MAAA,KAAA,OAAA,EAAA,MAAA,KAAA,OAAA,EAAA,MAGA,cAAA,SAAA,EAAA,GACA,EAAA,GAAA,CACA,IAAA,GAAA,KAAA,WACA,EAAA,EAAA,UACA,OAAA,IAAA,EAEA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,GACA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,GACA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,GACA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,EAEA,IAAA,GACA,EAEA,OAAA,GACA,GAIA,SAAA,KAAA,KAAA,EAAA,MAAA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,EAAA,KAAA,OAAA,EAAA,QACA,SAAA,KAAA,KAAA,EAAA,MAAA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,EAAA,KAAA,OAAA,EAAA,QACA,SAAA,KAAA,KAAA,EAAA,MAAA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,EAAA,KAAA,OAAA,EAAA,QACA,SAAA,KAAA,KAAA,EAAA,MAAA,KAAA,IAAA,KAAA,KAAA,EAAA,MAAA,EAAA,KAAA,OAAA,EAAA,OASA,KAAA,SAAA,GACA,MAAA,GACA,EAAA,IAAA,MAGA,GAAA,GAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,OAKA,MAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,QAGA,aAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,QAKA,gBAAA,SAAA,EAAA,GACA,MAAA,IAAA,GACA,KAAA,IAAA,KAAA,KAAA,GACA,KAAA,IAAA,KAAA,KAAA,GACA,KAAA,IAAA,KAAA,KAAA,GACA,KAAA,IAAA,KAAA,KAAA,KAKA,UAAA,SAAA,GACA,MAAA,MAAA,gBAAA,EAAA,EAAA,EAAA,IAGA,SAAA,SAAA,GAAA,MAAA,IAAA,GAAA,EAAA,KAAA,KAAA,KAAA,KAAA,KAAA,OACA,SAAA,SAAA,GAAA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,OACA,SAAA,SAAA,GAAA,MAAA,IAAA,GAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,OACA,SAAA,SAAA,GAAA,MAAA,IAAA,GAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,IAGA,WAAA,WACA,MAAA,IAAA,GACA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MACA,KAAA,KAAA,KAAA,MACA,KAAA,KAAA,KAAA,QAKA,UAAA,WACA,MAAA,IAAA,GACA,KAAA,KAAA,KAAA,MACA,KAAA,KAAA,KAAA,MACA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,QAMA,YAAA,SAAA,GACA,MAAA,MAAA,OAAA,UAAA,IAIA,QAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IAIA,SAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,OAIA,SAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,IAIA,UAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IAIA,OAAA,SAAA,GAAA,MAAA,MAAA,SAAA,IACA,QAAA,SAAA,GAAA,MAAA,MAAA,UAAA,IACA,QAAA,SAAA,GAAA,MAAA,MAAA,UAAA,IACA,SAAA,SAAA,EAAA,GAAA,MAAA,MAAA,WAAA,GAAA,IAEA,SAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,OAGA,SAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,IAGA,QAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IAQA,UAAA,SAAA,EAAA,EAAA,EAAA,GAKA,MAJA,MAAA,KAAA,EACA,KAAA,KAAA,EACA,KAAA,KAAA,EACA,KAAA,KAAA,EACA,MAEA,QAAA,SAAA,GAEA,MADA,MAAA,KAAA,EACA,MAEA,QAAA,SAAA,GAEA,MADA,MAAA,KAAA,EACA,MAEA,QAAA,SAAA,GAEA,MADA,MAAA,KAAA,EACA,MAEA,QAAA,SAAA,GAEA,MADA,MAAA,KAAA,EACA,MAGA,IAAA,SAAA,GACA,MAAA,MAAA,UAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,OAIA,cAAA,SAAA,GACA,MAAA,MAAA,UACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,QAKA,gBAAA,SAAA,GACA,MAAA,MAAA,UACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,MACA,KAAA,IAAA,KAAA,KAAA,EAAA,QAIA,eAAA,SAAA,EAAA,GACA,MAAA,MAAA,UACA,KAAA,IAAA,KAAA,KAAA,GACA,KAAA,IAAA,KAAA,KAAA,GACA,KAAA,IAAA,KAAA,KAAA,GACA,KAAA,IAAA,KAAA,KAAA,KAIA,SAAA,SAAA,GACA,MAAA,MAAA,eAAA,EAAA,EAAA,EAAA,IAIA,SAAA,WACA,MAAA,MAAA,UACA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MACA,KAAA,KAAA,KAAA,MACA,KAAA,KAAA,KAAA,QAKA,QAAA,WACA,MAAA,MAAA,UACA,KAAA,KAAA,KAAA,MACA,KAAA,KAAA,KAAA,MACA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,QAMA,UAAA,SAAA,GAEA,GAAA,KAAA,UACA,MAAA,KAIA,IAAA,EAAA,aACA,MAAA,KAGA,IAAA,GAAA,KAAA,KACA,EAAA,KAAA,KACA,EAAA,KAAA,KACA,EAAA,KAAA,IAUA,OATA,MAAA,IAAA,EAAA,QAAA,SAKA,KAAA,SAAA,EAAA,gBAAA,EAAA,MAAA,EAAA,KACA,KAAA,SAAA,EAAA,gBAAA,EAAA,MAAA,EAAA,KACA,KAAA,SAAA,EAAA,gBAAA,EAAA,MAAA,EAAA,KACA,KAAA,SAAA,EAAA,gBAAA,EAAA,MAAA,EAAA,KACA,MAIA,OAAA,SAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IAIA,QAAA,SAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,OAIA,QAAA,SAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,IAIA,SAAA,SAAA,EAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IAIA,MAAA,SAAA,GAAA,MAAA,MAAA,QAAA,IACA,OAAA,SAAA,GAAA,MAAA,MAAA,SAAA,IACA,OAAA,SAAA,GAAA,MAAA,MAAA,SAAA,IACA,QAAA,SAAA,EAAA,GAAA,MAAA,MAAA,UAAA,GAAA,IAEA,OAAA,SAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,OAGA,OAAA,SAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAAA,KAAA,IAGA,MAAA,SAAA,EAAA,GACA,MAAA,MAAA,UAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IE5gBA,gBAAA,SAAA,EAAA,EAAA,GAWA,MAVA,GACA,EAAA,MAAA,EAAA,GAGA,EAAA,GAAA,GAAA,QAAA,EAAA,GAEA,EAAA,EAAA,KAAA,OAAA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,OAAA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,OAAA,EAAA,EAAA,KAAA,MACA,EAAA,EAAA,KAAA,OAAA,EAAA,EAAA,KAAA,MACA,IAIA,EAAA,KAAA,SAAA,EAAA,EAAA,EAAA,GACA,MAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAIA,EAAA,MAAA,SAAA,EAAA,GACA,GAAA,YAAA,GAAA,QAAA,CACA,GAAA,GAAA,CACA,OAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAGA,MAAA,IAAA,GAAA,EAAA,EAAA,EAAA,IAIA,EAAA,MAAA,GACA,eAAA,WAAA,MAAA,GAAA,QAAA,QACA,4BAAA,SAAA,GACA,MAAA,UAAA,EAAA,EAAA,EAAA,GACA,MAAA,GAAA,OACA,EAAA,MAAA,UAAA,EAAA,EAAA,EAAA,GAGA,GAAA,GAAA,EAAA,EAAA,EAAA,ODnCA,EAAA,WAAA,GAAA,GAAA,OAAA,kBAAA,OAAA,kBAAA,OAAA,kBAAA,OAAA,mBACA,EAAA,QAAA,GAAA,GAAA,OAAA,kBAAA,OAAA,kBAAA,OAAA,kBAAA,OAAA,mBAEA,IAWA,EAAA,YAAA,UAAA,WAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,KAAA,SAAA,EAAA,GACA,KAAA,IAAA,EACA,KAAA,IAAA,EAMA,IAAA,GAAA,EAAA,IAkBA,OAhBA,GAAA,WACA,YAAA,EAEA,QAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,gBAAA,GAAA,KAAA,MAGA,gBAAA,SAAA,GACA,MAAA,MAAA,IAAA,KAAA,KAAA,IAAA,YAAA,KAGA,SAAA,WACA,MAAA,MAAA,IAAA,WAAA,OAAA,KAAA,IAAA,aAIA,IAWA,EAAA,yBAAA,UAAA,YAAA,WAAA,eAAA,SAAA,GAGA,GAAA,GAAA,EAAA,aAEA,EAAA,EAAA,YACA,EAAA,EAAA,cA0BA,GAAA,QAAA,YACA,IAAA,GAAA,EAAA,QAEA,EAAA,SAAA,GAAA,MAAA,GE9CA,OFgDA,GAAA,WACA,YAAA,EAGA,uBAAA,SAAA,GACA,GAAA,GAAA,KAAA,YAAA,EACA,OAAA,GAAA,aAIA,aAAA,SAAA,GAIA,IAAA,GAFA,GAAA,KACA,KACA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAEA,GAAA,GAAA,EAAA,GACA,EAAA,EAAA,WAAA,EAEA,GAAA,KAAA,EAAA,IACA,EAAA,EAAA,EAGA,KAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,GAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAIA,MADA,GAAA,KAAA,GACA,GAIA,uBAAA,WACA,MAAA,MAAA,aAAA,KAAA,yBAaA,0BAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAEA,EAAA,SAAA,EAAA,EAAA,UAAA,EACA,EAAA,SAAA,EAAA,EAAA,UAAA,EACA,EAAA,KACA,IAAA,GAAA,EAAA,UAAA,CAGA,GAAA,GAAA,EAAA,KAAA,OACA,EAAA,GAAA,EAAA,KAAA,IACA,IAAA,GAAA,EAAA,KAAA,WAAA,KAQA,EAAA,IAAA,CAQA,KAPA,GAAA,GAAA,IAEA,GAAA,OAAA,EAAA,cAAA,EAAA,qBAAA,EAAA,EAAA,GAAA,EAAA,gBAAA,GAAA,EAAA,gBAEA,OAAA,EAAA,iBAAA,EAAA,qBAAA,EAAA,EAAA,GAAA,EAAA,kBAGA,EACA,EAAA,KAAA,GAAA,GAAA,KAAA,EAAA,QAEA,CACA,GAAA,GAAA,KAAA,WAAA,GACA,GAAA,GAAA,0BAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,GAAA,0BAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAEA,MAAA,KAOA,EAAA,eAAA,SAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EACA,KACA,KACA,EAAA,OAAA,kBACA,GAAA,CAgDA,KA9CA,EAAA,KAAA,EAAA,SAAA,GAEA,GAAA,EAAA,uBAAA,CACA,GAAA,GAAA,EAAA,uBAAA,EACA,GAAA,KAAA,EAAA,SAAA,GACA,EAAA,gBAAA,GACA,GAAA,GACA,EAAA,EAAA,iBAEA,EAAA,kBAAA,GACA,EAAA,KAAA,SAQA,KAAA,GADA,IAAA,GAAA,OAAA,EAAA,wBAAA,QAAA,IACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,CACA,GAAA,GAAA,EAAA,GACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,WAAA,GACA,EAAA,EAAA,WAAA,GACA,EAAA,EAAA,MAAA,GAAA,SAAA,GACA,EAAA,EAAA,8BAAA,EACA,IAAA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,8BAAA,EACA,GAAA,IACA,EAAA,EACA,MAEA,EAAA,MACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,QAAA,EACA,OAAA,EACA,IAAA,EACA,IAAA,QAOA,EAAA,SAAA,GAAA,CACA,GAAA,GAAA,CACA,MAGA,GAAA,EAEA,EAAA,KAAA,EAAA,SAAA,GACA,KAAA,EAAA,mBAAA,GAAA,CAGA,GAAA,EAAA,GAAA,gBAAA,EAAA,IAAA,IACA,GAAA,EAEA,IAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EACA,EAAA,EAAA,QAAA,WAAA,GACA,EAAA,EAAA,MAAA,EAAA,IAAA,SAAA,GACA,EAAA,EAAA,MAAA,EAAA,IAAA,SAAA,GACA,EAAA,EAAA,8BAAA,GACA,EAAA,EAAA,8BAAA,EACA,IAAA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,8BAAA,EACA,GAAA,IACA,EAAA,EACA,MElQA,EAAA,MACA,GAAA,EAAA,GACA,GAAA,EACA,GAAA,EAAA,GACA,GAAA,EACA,QAAA,EAAA,QACA,OAAA,EACA,IAAA,EACA,IAAA,IAGA,GAAA,GAAA,EAAA,CACA,GAAA,GAAA,EAAA,8BAAA,EACA,GAAA,IACA,EAAA,EACA,MAEA,EAAA,MACA,GAAA,EACA,GAAA,EAAA,GACA,GAAA,EACA,GAAA,EAAA,GACA,QAAA,EAAA,QACA,OAAA,EACA,IAAA,EACA,IAAA,QAkBA,MAXA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EACA,EAAA,EAAA,QAAA,WAAA,EACA,GAAA,MACA,QAAA,EAAA,QACA,EAAA,EACA,aAAA,EACA,gBAAA,EAAA,gBAAA,OAIA,GAGA,IAWA,EAAA,sBAAA,UAAA,oBAAA,cAAA,cAAA,WAAA,YAAA,yBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,YAEA,EAAA,EAAA,aACA,EAAA,EAAA,yBAEA,EAAA,GAAA,ECtBA,ODwBA,GAAA,KAAA,SAAA,EAAA,GACA,KAAA,OAAA,EACA,KAAA,KAAA,EAGA,KAAA,SAAA,OACA,KAAA,QAAA,QAEA,EAAA,EAAA,EAAA,MAEA,SAAA,WACA,MAAA,MAAA,QAEA,GAAA,SAAA,MAAA,MAAA,QAEA,OAAA,WACA,MAAA,MAAA,MAEA,GAAA,OAAA,MAAA,MAAA,MAEA,gBAAA,WAKA,MAJA,UAAA,KAAA,WAEA,KAAA,SAAA,KAAA,KAAA,MAAA,KAAA,QAAA,cAEA,KAAA,UAEA,GAAA,gBAAA,MAAA,MAAA,mBAEA,cAAA,WACA,MAAA,MAAA,mBAEA,GAAA,cAAA,MAAA,MAAA,iBAEA,UAAA,WAKA,MAHA,UAAA,KAAA,UACA,KAAA,QAAA,EAAA,QAAA,OAAA,SAAA,KAAA,QAAA,SAAA,KAAA,OAEA,KAAA,SAEA,GAAA,UAAA,MAAA,MAAA,aAEA,uBAAA,SAAA,GAEA,GAAA,GAAA,EAAA,QAAA,MAGA,OAFA,GAAA,SAAA,EAAA,gBAAA,EAAA,IAAA,KAAA,UACA,EAAA,SAAA,EAAA,gBAAA,EAAA,IAAA,KAAA,QACA,GAGA,yBAAA,WAEA,MAAA,MAAA,OAAA,OAAA,KAAA,UAIA,OAIA,WAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,KAAA,KAAA,MAAA,KAAA,QAAA,MAAA,KAGA,UAAA,WAEA,MAAA,MAAA,mBAGA,YAAA,WACA,MAAA,IAGA,mBAAA,WACA,MAAA,KAAA,EAAA,UAAA,KAAA,KAAA,GAAA,IAAA,EAAA,UAAA,KAAA,KAAA,IAGA,WAAA,SAAA,GACA,GAAA,GAAA,KAAA,gBAAA,gBAAA,UAAA,MAAA,EAAA,EACA,QAAA,GAAA,GAAA,KAAA,KAAA,OAAA,KAAA,GAAA,KAAA,KAAA,KAAA,MAGA,YAAA,SAAA,GACA,GAAA,GAAA,KAAA,kBAAA,gBAAA,MAAA,EAAA,EACA,QAAA,GAAA,GAAA,KAAA,KAAA,KAAA,KAAA,GAAA,KAAA,OAAA,KAAA,MAIA,qBAAA,WAAA,UAEA,WAAA,SAAA,GACA,GAAA,GAAA,KAAA,WAAA,EACA,QACA,GAAA,GAAA,KAAA,KAAA,OAAA,GACA,GAAA,GAAA,KAAA,EAAA,KAAA,QAIA,iBAAA,WACA,KAAA,IAAA,OAAA,gDAGA,aAAA,SAAA,GAIA,GAAA,MAEA,EAAA,KAAA,OACA,EAAA,KAAA,KAEA,EAAA,EAAA,MAAA,EAEA,IAAA,IAAA,EAAA,mBACA,MAAA,EAGA,IAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,CAGA,IAAA,IAAA,EACA,MAAA,EAIA,IAAA,IAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,IAAA,IAAA,CAGA,IAAA,EAAA,GAAA,GAAA,EACA,MAAA,EAIA,IAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,IAAA,CAGA,IAAA,KAAA,EACA,MAAA,EAIA,IAAA,GAAA,EAAA,eAQA,OAPA,GAAA,MACA,SAAA,EACA,MAAA,EAAA,KAAA,EAAA,MAAA,IACA,OAAA,EAAA,IAAA,EAAA,KAAA,EAAA,EAAA,UAAA,EACA,KAAA,EAAA,IAAA,gBAAA,IAAA,GAAA,EAAA,EAAA,GACA,QAAA,OAEA,GAIA,oBAAA,SAAA,GACA,GAAA,GAAA,KAAA,aAAA,EACA,OAAA,GAAA,OACA,EAAA,GAAA,KAGA,GCnOA,eAAA,SAAA,GACA,EAAA,OAAA,KAAA,KAAA,EAAA,KAAA,KAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,aAAA,KAAA,QAAA,EAAA,aAAA,KAAA,QAGA,uBAAA,SAAA,GACA,GAAA,GAAA,KAAA,KAAA,MAAA,KAAA,QACA,EAAA,EAAA,MAAA,KAAA,QAAA,IAAA,GAAA,EAAA,kBACA,GAAA,EAAA,MAAA,EAAA,EAAA,EACA,IAAA,GAAA,KAAA,WAAA,EACA,SAEA,QAAA,KACA,EAAA,EACA,aAAA,EACA,gBAAA,EAAA,gBAAA,MAMA,gBAAA,SAAA,EAAA,GACA,MAAA,IAAA,GAAA,KAAA,KAAA,WAAA,GAAA,KAAA,WAAA,EAAA,KAGA,iBAAA,SAAA,GACA,MAAA,MAAA,OAAA,IAAA,KAAA,KAAA,GAEA,GAAA,GAAA,KAAA,EAAA,YAAA,KAAA,OAAA,EAAA,KAAA,OAAA,GAAA,EAAA,YAAA,KAAA,KAAA,EAAA,KAAA,KAAA,KAEA,KAAA,OAAA,IAAA,KAAA,KAAA,GAEA,GAAA,GAAA,IAAA,EAAA,KAAA,KAAA,OAAA,EAAA,KAAA,OAAA,EAAA,KAAA,KAAA,EAAA,KAAA,OAAA,EAAA,KAAA,KAAA,IAGA,KAAA,0BAAA,MAKA,EAAA,OAWA,EAAA,qBAAA,UAAA,oBAAA,cAAA,cAAA,WAAA,YAAA,yBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,qBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,YAEA,EAAA,EAAA,aACA,EAAA,EAAA,wBCpBA,ODsBA,GAAA,IAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,IAEA,GAAA,EACA,GAAA,KAAA,GACA,GAAA,KAAA,IAGA,KAAA,QAAA,EACA,KAAA,QAAA,EACA,KAAA,YAAA,EACA,KAAA,UAAA,EACA,KAAA,eAAA,EAGA,KAAA,OAAA,OACA,KAAA,KAAA,OACA,KAAA,cAAA,OACA,KAAA,YAAA,OACA,KAAA,gBAAA,OACA,KAAA,iBAAA,OACA,KAAA,iBAAA,QAMA,EAAA,EAAA,EAAA,KAEA,UAAA,WACA,MAAA,MAAA,SAEA,GAAA,UAAA,MAAA,MAAA,aAEA,UAAA,WACA,MAAA,MAAA,SAEA,GAAA,UAAA,MAAA,MAAA,aAEA,cAAA,WACA,MAAA,MAAA,aAEA,GAAA,cAAA,MAAA,MAAA,iBAEA,YAAA,WACA,MAAA,MAAA,WAEA,GAAA,YAAA,MAAA,MAAA,eAEA,iBAAA,WACA,MAAA,MAAA,gBAEA,GAAA,iBAAA,MAAA,MAAA,oBAEA,SAAA,WAIA,MAHA,UAAA,KAAA,SACA,KAAA,OAAA,KAAA,gBAAA,KAAA,cAEA,KAAA,QAEA,GAAA,SAAA,MAAA,MAAA,YAEA,OAAA,WAIA,MAHA,UAAA,KAAA,OACA,KAAA,KAAA,KAAA,gBAAA,KAAA,YAEA,KAAA,MAEA,GAAA,OAAA,MAAA,MAAA,UAEA,gBAAA,WAIA,MAHA,UAAA,KAAA,gBACA,KAAA,cAAA,KAAA,eAAA,KAAA,cAEA,KAAA,eAEA,GAAA,gBAAA,MAAA,MAAA,mBAEA,cAAA,WAIA,MAHA,UAAA,KAAA,cACA,KAAA,YAAA,KAAA,eAAA,KAAA,YAEA,KAAA,aAEA,GAAA,cAAA,MAAA,MAAA,iBAEA,kBAAA,WAgCA,MA/BA,UAAA,KAAA,kBAMA,KAAA,gBAJA,KAAA,eAGA,KAAA,YAAA,KAAA,UACA,KAAA,UAEA,KAAA,YAAA,KAAA,UACA,KAAA,UAAA,EAAA,KAAA,GAIA,KAAA,YAMA,KAAA,YAAA,KAAA,UACA,KAAA,UAEA,KAAA,YAAA,KAAA,UACA,KAAA,UAAA,EAAA,KAAA,GAIA,KAAA,aAIA,KAAA,iBAEA,GAAA,kBAAA,MAAA,MAAA,qBAEA,mBAAA,WAIA,MAHA,UAAA,KAAA,mBACA,KAAA,kBAAA,KAAA,gBAAA,KAAA,UAAA,KAAA,aAAA,EAAA,KAAA,IAAA,KAAA,gBAAA,KAAA,YAAA,KAAA,WAAA,EAAA,KAAA,IAEA,KAAA;EAEA,GAAA,mBAAA,MAAA,MAAA,sBAEA,mBAAA,WASA,MARA,UAAA,KAAA,mBAEA,KAAA,iBAAA,KAAA,eAAA,KAAA,YAAA,KAAA,UAAA,KAAA,UAAA,KAAA,YACA,KAAA,iBAAA,IACA,KAAA,kBAAA,EAAA,KAAA,KAIA,KAAA,kBAEA,GAAA,mBAAA,MAAA,MAAA,sBAEA,UAAA,WAeA,MAdA,UAAA,KAAA,UAEA,KAAA,QAAA,EAAA,QAAA,OAAA,UAAA,KAAA,YACA,UAAA,KAAA,UAGA,KAAA,cAAA,KAAA,YAEA,KAAA,qBAAA,GACA,KAAA,qBAAA,KAAA,GAAA,GACA,KAAA,qBAAA,KAAA,IACA,KAAA,qBAAA,EAAA,KAAA,GAAA,KAGA,KAAA,SAEA,GAAA,UAAA,MAAA,MAAA,aAEA,yBAAA,WACA,MAAA,MAAA,SAAA,GAAA,KAAA,cAAA,KAAA,cAIA,OAIA,qBAAA,SAAA,GACA,KAAA,cAAA,KAEA,KAAA,QAAA,KAAA,QAAA,UAAA,KAAA,QAAA,KAAA,EAAA,YAAA,KAAA,QAAA,OAKA,SAAA,SAAA,GAEA,MAAA,MAAA,YAAA,KAAA,oBACA,EAAA,gBAAA,EAAA,KAAA,YAAA,EAAA,KAAA,GAAA,KAAA,aACA,EAAA,kBAAA,EAAA,KAAA,YAAA,KAAA,YAAA,EAAA,KAAA,KAGA,SAAA,SAAA,GACA,OAAA,KAAA,SAAA,GAAA,KAAA,cAAA,KAAA,oBAAA,KAAA,cAGA,QAAA,SAAA,GACA,MAAA,MAAA,aAAA,KAAA,oBAAA,KAAA,aAAA,GAGA,WAAA,SAAA,GACA,MAAA,MAAA,gBAAA,KAAA,QAAA,KAGA,UAAA,SAAA,GACA,MAAA,MAAA,eAAA,KAAA,QAAA,KAGA,YAAA,WACA,OAAA,KAAA,eAAA,GAAA,GAAA,KAAA,SAGA,gBAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,YAAA,KAAA,QAAA,KAGA,eAAA,SAAA,GACA,GAAA,GAAA,EAAA,YAAA,EAAA,EAEA,OAAA,MAAA,eAAA,EAAA,gBAAA,EAAA,gBAAA,WAIA,cAAA,SAAA,GAGA,GAAA,GAAA,KAAA,eAAA,EAAA,KAAA,UAAA,EAAA,KAAA,YAGA,EAAA,EAAA,kBAAA,EAAA,EAAA,EAAA,KAAA,GAEA,OAAA,IAAA,KAAA,iBAGA,mBAAA,WAIA,GAEA,GAFA,EAAA,IACA,EAAA,KAAA,eAAA,IAAA,GAEA,IAAA,KAAA,gBAAA,EAAA,KAAA,GAAA,EAEA,MADA,GAAA,KAAA,gBAAA,KAAA,GAAA,IAAA,IACA,KAAA,EAAA,UAAA,KAAA,SAAA,IAAA,EAAA,UAAA,KAAA,SAAA,MAAA,EACA,IAAA,EAAA,IAAA,EAAA,UAAA,KAAA,IAAA,GAAA,IAAA,EAAA,UAAA,KAAA,IAAA,EAOA,IAAA,IAAA,KAAA,YAAA,KAAA,WAAA,EACA,EAAA,KAAA,QAAA,KAAA,EAAA,YAAA,KAAA,QAAA,GAEA,GAAA,GAEA,IAAA,GAAA,KAAA,EAAA,UAAA,KAAA,SAAA,IAAA,EAAA,UAAA,KAAA,SAAA,MACA,EAAA,IAAA,EAAA,IAAA,EAAA,UAAA,EAAA,GAAA,IAAA,EAAA,UAAA,EAAA,GACA,EAAA,KAAA,EAAA,UAAA,KAAA,SAAA,IAAA,EAAA,UAAA,KAAA,SAAA,MACA,EAAA,IAAA,EAAA,IAAA,EAAA,UAAA,KAAA,IAAA,GAAA,IAAA,EAAA,UAAA,KAAA,IAAA,EAEA,OAAA,GAAA,IAAA,GAIA,WAAA,SAAA,GACA,OAAA,GAAA,GAAA,IAAA,KAAA,QAAA,KAAA,SAAA,KAAA,eAAA,EAAA,IAAA,EAAA,EAAA,KAAA,YAAA,KAAA,UAAA,KAAA,kBAGA,YAAA,SAAA,GACA,OAAA,GAAA,GAAA,IAAA,KAAA,QAAA,KAAA,SAAA,KAAA,eAAA,GAAA,GAAA,EAAA,EAAA,KAAA,UAAA,KAAA,aAAA,KAAA,kBAIA,qBAAA,WACA,GAAA,GAAA,KACA,IAUA,OATA,GAAA,MAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,EAAA,KAAA,GAAA,GAAA,SAAA,GACA,GAAA,EAAA,cAAA,GAAA,CACA,GAAA,GAAA,EAAA,SAAA,GACA,EAAA,KACA,GAAA,GAAA,EAAA,EAAA,GACA,EAAA,KAAA,MAIA,EAAA,QAGA,WAAA,SAAA,GAEA,GAAA,GAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,GACA,EAAA,KAAA,QAAA,EACA,QACA,GAAA,GAAA,IAAA,KAAA,QAAA,KAAA,QAAA,EAAA,EAAA,KAAA,gBACA,GAAA,GAAA,IAAA,KAAA,QAAA,KAAA,QAAA,EAAA,EAAA,KAAA,kBAIA,iBAAA,WACA,KAAA,IAAA,OAAA,4CAGA,aAAA,SAAA,GACA,GAAA,MAGA,EAAA,EAKA,EAAA,EAAA,IAAA,MAAA,KAAA,SACA,EAAA,EAAA,IAAA,IAAA,GACA,EAAA,EAAA,mBACA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,KAAA,QAAA,KAAA,QACA,IAAA,EAAA,EAEA,MAAA,EAEA,IAAA,GAAA,EAAA,IAAA,IAAA,KAAA,SAAA,EAAA,IAAA,IAAA,EAAA,KACA,EAAA,KAAA,KAAA,GAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,CAEA,IAAA,EAAA,EAEA,MAAA,EAGA,IAAA,GAAA,EAAA,gBAAA,GACA,EAAA,EAAA,MAAA,KAAA,SAAA,YAEA,IAAA,EAAA,EAEA,KAAA,cAAA,EAAA,UACA,EAAA,MACA,SAAA,EACA,MAAA,EACA,OAAA,EAAA,UACA,KAAA,KAAA,eAAA,GAAA,QAIA,CAEA,GAAA,GAAA,EAAA,gBAAA,GACA,EAAA,EAAA,MAAA,KAAA,SAAA,YAEA,MAAA,cAAA,EAAA,UACA,EAAA,MACA,SAAA,EACA,MAAA,EACA,OAAA,EACA,KAAA,KAAA,eAAA,EAAA,KAGA,KAAA,cAAA,EAAA,UACA,EAAA,MACA,SAAA,EACA,MAAA,EACA,OAAA,EAAA,UC1aA,KAAA,KAAA,eAAA,GAAA,IAKA,MAAA,IAIA,oBAAA,SAAA,GACA,GAAA,GAAA,EACA,EAAA,KAAA,aAAA,EAIA,OAHA,GAAA,KAAA,EAAA,SAAA,GACA,GAAA,EAAA,OAEA,GAGA,eAAA,SAAA,GACA,EAAA,IAAA,KAAA,QAAA,EAAA,KAAA,QAAA,EAAA,KAAA,QAAA,KAAA,YAAA,KAAA,UAAA,KAAA,iBAIA,YAAA,SAAA,GAEA,GAAA,GAAA,EAAA,aAAA,EAAA,YAAA,EAAA,KAAA,cAAA,MAAA,EAAA,aAAA,EAAA,OAAA,QACA,EAAA,EAAA,aAAA,EAAA,YAAA,EAAA,KAAA,YAAA,MAAA,EAAA,aAAA,EAAA,OAAA,QAGA,EAAA,EAAA,kBAAA,EAAA,KAAA,gBAAA,KAAA,cAEA,MAAA,IAAA,KAAA,UAAA,KAAA,eAAA,EAAA,KAAA,KACA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GAGA,IAAA,GAAA,EAAA,gBACA,IAAA,EAAA,IAAA,EAAA,EAAA,CACA,GAAA,GAAA,EAAA,EAAA,KAAA,QACA,EAAA,EAAA,EAAA,KAAA,OACA,OAAA,IAAA,GAAA,cAAA,EAAA,aAAA,KAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAGA,GAAA,GAAA,EAAA,EAAA,KAAA,OACA,OAAA,IAAA,GAAA,IAAA,EAAA,aAAA,KAAA,SAAA,EAAA,EAAA,EAAA,MAKA,EAAA,MAcA,EAAA,qBAAA,UAAA,cAAA,YAAA,qBAAA,qBAAA,SAAA,GAGA,GAAA,GAAA,EAAA,eAEA,EAAA,EAAA,YAEA,GAAA,sBACA,EAAA,qBAGA,EAAA,QAAA,SAAA,EAAA,EAAA,GACA,KAAA,SAAA,MAGA,KAAA,OAAA,IAAA,GAAA,EAAA,OAAA,EAAA,IAAA,EAAA,SAAA,GAAA,MAAA,GAAA,QAAA,OAAA,EAAA,EAAA,OAAA,GAAA,SACA,KAAA,SAAA,EAGA,KAAA,iBAAA,KACA,KAAA,0BAAA,EACA,KAAA,eAAA,IAEA,IAAA,GAAA,KAAA,OAAA,EAAA,QAAA,MACA,GAAA,KAAA,KAAA,SAAA,SAAA,GACA,EAAA,cAAA,EAAA,UAGA,IAAA,GAAA,EAAA,OC1CA,OD2CA,GAAA,WACA,KAAA,WACA,MAAA,IAAA,GAAA,KAAA,SAAA,MAAA,GAAA,KAAA,OAAA,MAAA,GAAA,KAAA,SAGA,WAAA,WACA,KAAA,0BAAA,GAGA,SAAA,SAAA,GAGA,MAFA,MAAA,OAAA,KAAA,GAEA,MAGA,mBAAA,SAAA,GAWA,MALA,MAAA,SAAA,KAAA,GACA,KAAA,aAEA,KAAA,OAAA,cAAA,EAAA,aAEA,MAGA,WAAA,SAAA,GACA,GAAA,GAAA,IAKA,OAJA,GAAA,KAAA,EAAA,2BAAA,SAAA,GACA,EAAA,mBAAA,KAGA,MAKA,kBAAA,WACA,GAAA,KAAA,oBAAA,CACA,GAAA,GAAA,KAAA,mBACA,MAAA,mBAAA,GACA,KAAA,SAAA,KAAA,iBACA,KAAA,QAAA,IAKA,MAAA,WACA,KAAA,QAAA,GAGA,UAAA,WACA,MAAA,MAAA,OAAA,QAGA,cAAA,WACA,MAAA,GAAA,MAAA,KAAA,SAGA,aAAA,WACA,MAAA,GAAA,KAAA,KAAA,SAGA,gBAAA,WACA,MAAA,GAAA,MAAA,KAAA,WAGA,eAAA,WACA,MAAA,GAAA,KAAA,KAAA,WAGA,WAAA,WACA,MAAA,MAAA,SAAA,OAAA,GAGA,SAAA,WACA,MAAA,MAAA,QAGA,kBAAA,WACA,OAAA,KAAA,gBAAA,cAAA,KAAA,eAAA,OAGA,kBAAA,WAEA,MAAA,IAAA,GAAA,QAAA,KAAA,KAAA,eAAA,KAAA,kBAGA,eAAA,SAAA,GACA,GAAA,KAAA,aAAA,CACA,GAAA,GAAA,KAAA,kBAAA,KACA,GAAA,OAAA,EAAA,EAAA,EAAA,EAGA,KAAA,GADA,GAAA,KAAA,SAAA,OACA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,SAAA,GAAA,eAAA,EAGA,MAAA,QACA,EAAA,cAMA,kBAAA,SAAA,GAEA,MAAA,IAAA,GAAA,EAAA,QAAA,EAAA,IAAA,KAAA,SAAA,SAAA,GACA,MAAA,GAAA,0BAAA,MACA,KAAA,KAAA,SAGA,YAAA,SAAA,GACA,MAAA,IAAA,GACA,EAAA,IAAA,KAAA,SAAA,SAAA,GAAA,MAAA,GAAA,YAAA,KACA,EAAA,IAAA,KAAA,OAAA,SAAA,GAAA,MAAA,GAAA,aAAA,KACA,KAAA,SAKA,qBAAA,SAAA,GAOA,MAJA,MAAA,QAAA,KAAA,qBACA,KAAA,oBAGA,GAAA,GAAA,EAAA,QAAA,EAAA,IAAA,KAAA,SAAA,SAAA,GAEA,MAAA,GAAA,YAAA,EAAA,EAAA,YACA,EAAA,EAAA,YAAA,GAGA,EAAA,0BAAA,MAEA,KAAA,KAAA,SAGA,uBAAA,SAAA,GAGA,IAAA,GAFA,GAAA,EAAA,QAAA,OACA,EAAA,KAAA,SAAA,OACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,cAAA,KAAA,SAAA,GAAA,uBAAA,GAEA,OAAA,IAIA,OAAA,SAAA,GACA,IAAA,KAAA,aACA,MAAA,IAAA,MAAA,KAAA,KAAA,OAEA,IAAA,IAAA,EACA,MAAA,IAAA,GAAA,KAAA,SAAA,QAAA,KAAA,KAAA,OAGA,IAAA,GAEA,EAAA,KAAA,SAAA,OACA,MAAA,QAAA,KAAA,qBACA,EAAA,KAAA,KAAA,oBAEA,IAAA,KAEA,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,KAAA,EAAA,GAAA,WAAA,EAAA,GAGA,IAAA,KACA,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CACA,GAAA,KAAA,QAAA,EAAA,EAAA,CACA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,QAAA,EACA,EAAA,EAAA,GAAA,MACA,EAAA,EAAA,GAAA,WACA,EAAA,EAAA,GAAA,aAEA,EAAA,EAAA,gBAAA,UAAA,MAAA,GAAA,QACA,EAAA,EAAA,gBAAA,UAAA,MAAA,GAAA,QACA,EAAA,EAAA,gBAAA,IAAA,GAAA,CACA,GAAA,KAAA,GAAA,GAAA,QAAA,IAAA,EAAA,KAAA,IAAA,GAAA,EAAA,EAAA,IAEA,EAAA,EAAA,OAAA,EAAA,IAGA,MAAA,IAAA,GAAA,EAAA,KAAA,KAAA,SAIA,QAAA,SAAA,GAuBA,QAAA,GAAA,GACA,EAAA,EAAA,OAAA,GAGA,QAAA,GAAA,GACA,EAAA,EAAA,OAAA,GA1BA,IAAA,KAAA,aACA,QAQA,IALA,SAAA,IACA,EAAA,GAAA,GAAA,YAIA,KAAA,0BAAA,KAAA,eAAA,OAAA,GACA,MAAA,MAAA,gBAGA,IAEA,GAFA,EAAA,EAAA,UAGA,KACA,KACA,EAAA,KAAA,kBACA,EAAA,KAAA,iBAWA,EAAA,EAAA,IAAA,OAAA,EAAA,OAEA,EAAA,EAAA,KAAA,GAAA,GAAA,QAAA,KAAA,KAAA,SAAA,KAAA,SAAA,OAAA,GAAA,IAAA,KAAA,SAAA,GAAA,MAGA,KAAA,EAAA,EAAA,EAAA,KAAA,SAAA,OAAA,IACA,EAAA,GACA,EAAA,EAAA,SAAA,KAAA,SAAA,GAAA,MAAA,KAAA,SAAA,EAAA,GAAA,WAAA,KAAA,SAAA,GAAA,eAEA,EAAA,KAAA,SAAA,GAAA,WAAA,GCnUA,KAAA,EAAA,KAAA,SAAA,OAAA,EAAA,GAAA,EAAA,IACA,EAAA,KAAA,SAAA,OAAA,GACA,EAAA,EAAA,UAAA,KAAA,SAAA,GAAA,IAAA,KAAA,SAAA,GAAA,WAAA,KAAA,SAAA,EAAA,GAAA,eAEA,EAAA,KAAA,SAAA,GAAA,YAAA,GAGA,IAAA,EAoCA,OAnCA,MAAA,QACA,GAEA,EAAA,EAAA,SAAA,EAAA,IAAA,EAAA,WAAA,EAAA,eACA,EAAA,EAAA,UAAA,EAAA,IAAA,EAAA,WAAA,EAAA,iBAIA,EAAA,EAAA,SAAA,EAAA,MAAA,EAAA,WAAA,EAAA,eACA,EAAA,EAAA,WAAA,IACA,EAAA,EAAA,SAAA,EAAA,IAAA,EAAA,WAAA,EAAA,eAGA,EAAA,EAAA,UAAA,EAAA,IAAA,EAAA,WAAA,EAAA,eACA,EAAA,EAAA,YAAA,IACA,EAAA,EAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,gBAEA,GACA,GAAA,GAAA,EAAA,MAAA,GACA,GAAA,GAAA,EAAA,MAAA,KAIA,GACA,GAAA,GAAA,EAAA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,aACA,OAAA,GACA,OAAA,EAAA,IAAA,EAAA,MAAA,EAAA,aAAA,YACA,MAAA,IAIA,KAAA,iBAAA,EACA,KAAA,0BAAA,EACA,KAAA,eAAA,GAAA,GAAA,WAAA,GAEA,IAIA,EAAA,UAKA,EAAA,uBAAA,UAAA,aAAA,SAAA,GAUA,QAAA,GAAA,GAWA,MAAA,IAAA,EACA,QAAA,MAAA,QACA,QAAA,KAAA,OACA,QAAA,QAAA,OACA,QAAA,MAAA,OACA,QAAA,MAAA,OACA,QAAA,MAAA,OACA,QAAA,MAAA,OACA,QAAA,uCAAA,QACA,IA5BA,GAAA,GAAA,EAAA,YA+BA,GAAA,SAOA,MAAA,SAAA,EAAA,GAuFA,QAAA,GAAA,GACA,EAAA,IAIA,EAAA,IACA,EAAA,EACA,MAGA,EAAA,KAAA,IAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EACA,EAAA,CAMA,KAJA,EAAA,EACA,EAAA,EACA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,IAAA,OAAA,EAGA,GAFA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,MAIA,GAAA,KACA,EAAA,CAQA,OANA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,MAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAKA,IAHA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAkBA,OAhBA,QAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAKA,IAHA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAQA,OANA,QAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,OAAA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAKA,IAHA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAkBA,OAhBA,QAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,EA2BA,OAzBA,GAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,IACA,OAAA,IACA,EAAA,YASA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAQA,IANA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,GAAA,IAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,GAAA,GAAA,IAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GACA,CA+BA,OA7BA,GAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,SAIA,OAAA,IACA,EAAA,WAAA,OAAA,IAAA,UAAA,EAAA,IAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,SACA,MAAA,EAAA,EAAA,EAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,iBACA,MAAA,EAAA,EAAA,EAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,mBACA,MAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,2BACA,MAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,iBACA,MAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,yBACA,MAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,eACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,uBACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,CAgDA,OA9CA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,qBACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,6BACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAiCA,OA/BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,mBACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,2BACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAiCA,OA/BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,yBACA,MAAA,EAAA,EAAA,EAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,iCACA,MAAA,EAAA,EAAA,EAAA,OAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAcA,IAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAeA,IAbA,OAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,kBACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,EAAA,CAaA,GAZA,EAAA,EACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAEA,QAAA,IACA,EAAA,SAAA,EAAA,GACA,MAAA,GAAA,IAAA,SAAA,GACA,OACA,IAAA,0BACA,KAAA,MAGA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAGA,MAAA,GAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA2CA,OAzCA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,OAAA,IAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,CA4FA,OA1FA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,MAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAiCA,OA/BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,GACA,CAoBA,OAlBA,GAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,YAAA,EAAA,KAAA,EAAA,IAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,IACA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,UAAA,EAAA,KAAA,EAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EACA,EAAA,CAoDA,OAlDA,GAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,YAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,UAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GACA,CAsCA,OApCA,GAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,EAAA,WAAA,OAAA,GAAA,IAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,EAAA,WAAA,OAAA,GAAA,IAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EAAA,EACA,CAIA,IAFA,EAAA,EACA,EAAA,IACA,OAAA,EAEA,IADA,KACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,QAIA,GAAA,IAEA,IAAA,OAAA,EAGA,GAFA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,MAIA,GAAA,KACA,EAAA,CAEA,IAAA,OAAA,EAGA,GAFA,EAAA,EACA,EAAA,IACA,OAAA,EAAA,CAGA,IAFA,KACA,EAAA,IACA,OAAA,GACA,EAAA,KAAA,GACA,EAAA,GAEA,QAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,OAIA,GAAA,KACA,EAAA,CAGA,OAAA,GAGA,QAAA,KACA,GAAA,EAYA,OAVA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,EAGA,QAAA,KACA,GAAA,GAAA,EACA,EAAA,CAmDA,OAjDA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CA4EA,OA1EA,GAAA,EACA,EAAA,EACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,GAAA,MAAA,IAAA,EAAA,EAAA,KAEA,OAAA,IACA,EAAA,IAGA,EAGA,QAAA,KACA,GAAA,GAAA,EAAA,EACA,EAAA,CAsDA,OApDA,GAAA,EACA,EAAA,EACA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,SAIA,OAAA,GACA,EAAA,IACA,EAAA,OAAA,EAAA,EAAA,GACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,MAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,EAGA,QAAA,KACA,GAAA,EAwBA,OAtBA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,SAIA,EAGA,QAAA,KACA,GAAA,GAAA,EACA,EAAA,CA4BA,OA1BA,GAAA,EACA,EAAA,EACA,EAAA,IACA,OAAA,GACA,EAAA,IACA,OAAA,EACA,GAAA,EAAA,IAGA,EAAA,KACA,EAAA,KAIA,EAAA,KACA,EAAA,GAEA,OAAA,IACA,EAAA,SAAA,EAAA,EAAA,GAAA,MAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAEA,OAAA,IACA,EAAA,GAEA,OAAA,IACA,EAAA,KAEA,EAGA,QAAA,KACA,GAAA,EAYA,OAVA,SAAA,KAAA,EAAA,OAAA,KACA,EAAA,EAAA,OAAA,GACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,UAGA,EAGA,QAAA,KACA,GAAA,EAgDA,OA9CA,MAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,QAGA,OAAA,IACA,IAAA,EAAA,WAAA,IACA,EAAA,IACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,UAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,KACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,UAGA,OAAA,IACA,KAAA,EAAA,WAAA,IACA,EAAA,KACA,MAGA,EAAA,KACA,IAAA,GACA,EAAA,aAMA,EAIA,QAAA,GAAA,GACA,EAAA,MAIA,KAAA,GAFA,GAAA,KACA,KACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,KAAA,IACA,EAAA,KAAA,EAAA,IACA,EAAA,EAAA,GAGA,OAAA,GAGA,QAAA,KAYA,IAAA,GAJA,GAAA,EACA,EAAA,EACA,GAAA,EAEA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,GAAA,IAAA,CACA,GAAA,GAAA,EAAA,OAAA,EACA,QAAA,GACA,GAAA,IACA,EAAA,EACA,GAAA,GAEA,OAAA,GAAA,WAAA,GAAA,WAAA,GACA,IACA,EAAA,EACA,GAAA,IAGA,IACA,GAAA,GAIA,OAAA,KAAA,EAAA,OAAA,GAIA,QAAA,GAAA,EAAA,GACA,GAAA,KAEA,IAAA,EAAA,iBAAA,SACA,MAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAKA,IAAA,EAAA,OAAA,EACA,IAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,MACA,IAAA,EAAA,iBAAA,SACA,MAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAIA,OAAA,GAnlFA,GAAA,IACA,QAAA,EACA,0BAAA,EACA,yBAAA,EACA,eAAA,EACA,cAAA,EACA,OAAA,EACA,uBAAA,EACA,UAAA,EACA,OAAA,EACA,uBAAA,EACA,iBAAA,EACA,iCAAA,EACA,eAAA,EACA,+BAAA,EACA,QAAA,EACA,wBAAA,EACA,gBAAA,EACA,cAAA,EACA,8BAAA,EACA,sBAAA,EACA,uBAAA,EACA,uCAAA,EACA,+BAAA,EACA,6BAAA,EACA,6CAAA,EACA,cAAA,EACA,8BAAA,EACA,sBAAA,EACA,eAAA,EACA,kBAAA,EACA,OAAA,EACA,KAAA,EACA,SAAA,EACA,MAAA,EACA,sBAAA,EACA,mBAAA,EACA,SAAA,EACA,KAAA,EACA,cAAA,EACA,MAAA,EACA,IAAA,EAGA,IAAA,SAAA,GACA,GAAA,SAAA,EAAA,GACA,KAAA,IAAA,OAAA,sBAAA,EAAA,GAAA,SAIA,GAAA,SAGA,IAAA,GAAA,EACA,EAAA,EACA,EAAA,EACA,KA+hFA,EAAA,EAAA,IA0BA,IAAA,OAAA,GAAA,IAAA,EAAA,OAAA,CACA,GAAA,IAAA,KAAA,IAAA,EAAA,GACA,GAAA,GAAA,EAAA,OAAA,EAAA,OAAA,IAAA,KACA,GAAA,GAEA,MAAA,IAAA,MAAA,YACA,EAAA,GACA,GACA,GCvtFA,GAAA,KACA,GAAA,QAIA,MAAA,IAIA,SAAA,WAAA,MAAA,MAAA,SAEA,IAAA,GAAA,EAAA,OAqCA,OAjCA,GAAA,YAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,QAAA,GAAA,EAAA,GACA,GAAA,GAAA,CAEA,QAAA,EAAA,QACA,IAAA,GACA,EAAA,cACA,MACA,KAAA,GACA,EAAA,EAAA,EACA,MACA,SACA,EAAA,EAAA,MAAA,EAAA,EAAA,OAAA,GAAA,KAAA,MACA,OACA,EAAA,EAAA,OAAA,GAKA,MAFA,GAAA,EAAA,EAAA,GAAA,eAEA,YAAA,EAAA,QAAA,EAAA,UAGA,KAAA,KAAA,cACA,KAAA,SAAA,EACA,KAAA,MAAA,EACA,KAAA,QAAA,EAAA,EAAA,GACA,KAAA,OAAA,EACA,KAAA,KAAA,EACA,KAAA,OAAA,GAGA,EAAA,YAAA,UAAA,MAAA,UAEA,IAWA,EAAA,wBAAA,UAAA,YAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,aACA,EAAA,EAAA,YAAA,oBAEA,GAAA,WAAA,SAAA,GACA,SAAA,IACA,MAEA,KAAA,UAAA,SAAA,EAAA,UAAA,EAAA,UAAA,EACA,KAAA,QAAA,SAAA,EAAA,QAAA,EAAA,QAAA,OACA,KAAA,SAAA,SAAA,EAAA,SAAA,EAAA,SAAA,QACA,KAAA,SAAA,EAAA,SAAA,EAAA,YACA,KAAA,eAAA,SAAA,EAAA,eAAA,EAAA,eAAA,EACA,KAAA,WAAA,SAAA,EAAA,WAAA,EAAA,WAAA,GAIA,IAAA,GAAA,EAAA,UC9BA,OD+BA,GAAA,WACA,YAAA,EAEA,OAAA,SAAA,GACA,GAAA,GAAA,KAAA,YAAA,EAAA,WACA,KAAA,UAAA,EAAA,SACA,KAAA,WAAA,EAAA,UACA,KAAA,aAAA,EAAA,YACA,KAAA,iBAAA,EAAA,cACA,KAAA,EACA,OAAA,CAGA,IAAA,KAAA,SAAA,SAAA,EAAA,SAAA,OASA,OAAA,CARA,KAAA,GAAA,GAAA,EAAA,EAAA,KAAA,SAAA,OAAA,IACA,GAAA,KAAA,SAAA,KAAA,EAAA,SAAA,GACA,OAAA,CASA,QAAA,GASA,SAAA,SAAA,EAAA,EAAA,GAEA,GAAA,GAAA,EAAA,KAAA,EAAA,gBAAA,UAAA,MAAA,KAAA,UAAA,IACA,EAAA,EAAA,KAAA,EAAA,gBAAA,UAAA,MAAA,KAAA,UAAA,IAEA,EAAA,EAAA,OAAA,OAAA,GAAA,GAAA,QAAA,KAAA,EAAA,GAGA,MAAA,EAAA,gBAAA,IAAA,GAAA,GCpHA,MAAA,EDqHA,QAAA,KAAA,UACA,IAAA,QACA,GAAA,GAAA,EAAA,QAAA,KAAA,GAAA,EACA,EAAA,EAAA,QAAA,KAAA,GAAA,CACA,QAAA,GAAA,GAAA,QAAA,IAAA,EAAA,KAAA,UAAA,EAAA,EAAA,GAAA,GACA,KAAA,QACA,GAAA,GAAA,EAAA,aAAA,EAAA,UACA,IAAA,EAAA,KAAA,IAAA,EAAA,IAAA,KAAA,YAAA,EAAA,KAAA,GAAA,KAAA,CAEA,GAAA,GAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GACA,QACA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,GAAA,GAAA,QAAA,KAAA,EAAA,IAKA,MAAA,EAGA,KAAA,QACA,MAAA,KChIA,UAAA,SAAA,EAAA,EAAA,GACA,MAAA,MAAA,SAAA,EAAA,EAAA,UAAA,EAAA,YAMA,IAAA,SAAA,EAAA,GACA,GAAA,GAAA,EAAA,KAAA,EAAA,gBAAA,OAAA,KAAA,UAAA,IACA,EAAA,EAAA,KAAA,EAAA,gBAAA,MAAA,KAAA,UAAA,GAEA,QAAA,KAAA,SACA,IAAA,OACA,OAAA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,KAAA,QACA,GAAA,GAAA,EAAA,OACA,QAAA,GAAA,GAAA,QAAA,IAAA,EAAA,KAAA,UAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,KAAA,GAAA,GAAA,GACA,KAAA,SACA,GAAA,GAAA,EAAA,gBAAA,UAAA,MAAA,KAAA,UAAA,GACA,EAAA,EAAA,gBAAA,MAAA,KAAA,UAAA,GACA,EAAA,EAAA,MAAA,KAAA,UAAA,GAEA,EAAA,EAAA,KAAA,GAAA,KAAA,GACA,EAAA,EAAA,KAAA,GAAA,KAAA,EACA,QACA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,GAAA,GAAA,QAAA,KAAA,EAAA,GACA,GAAA,GAAA,QAAA,KAAA,EAAA,OAMA,EAAA,aAcA,EAAA,eAAA,UAAA,UAAA,YAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,YAGA,EAAA,QAAA,SAAA,EAAA,EAAA,EAAA,GAEA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,SAAA,EAAA,EAAA,EAEA,IAAA,GAAA,EAAA,OAEA,GAAA,WACA,YAAA,EACA,WAAA,EACA,UAAA,EAEA,UAAA,WACA,MAAA,MAAA,KAAA,KAAA,qBAGA,iBAAA,WACA,KAAA,IAAA,OAIA,SAAA,SAAA,GACA,MAAA,MAAA,MAAA,GAAA,aAIA,gBAAA,SAAA,GACA,MAAA,MAAA,MAAA,GAAA,oBAGA,IAAA,SAAA,GACA,MAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAGA,SAAA,WACA,MAAA,UAAA,KAAA,IAAA,SAAA,KAAA,IAAA,SAAA,KAAA,IAAA,SAAA,KAAA,IAGA,OAAA,SAAA,GACA,MAAA,MAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAGA,cAAA,SAAA,EAAA,GAIA,MAHA,KACA,EAAA,GAEA,KAAA,IAAA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,KAAA,EAAA,EAAA,IAAA,GAQA,KAAA,SAAA,GACA,MAAA,GACA,EAAA,IAAA,MAGA,GAAA,GAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,IAIA,WAAA,WACA,GAAA,GAAA,KAAA,WACA,IAAA,IAAA,EACA,KAAA,IAAA,OAAA,2CAGA,OAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAIA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,MAAA,SAAA,GAGA,MAAA,MAAA,YAAA,IAGA,eAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,KAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,MAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,QAAA,WACA,MAAA,IAAA,IAAA,KAAA,GAAA,KAAA,GAAA,KAAA,GAAA,KAAA,IAGA,aAAA,SAAA,GACA,MAAA,MAAA,KAAA,EAAA,MAAA,KAAA,aAAA,IAAA,EAAA,cAAA,GAAA,KAIA,MAAA,SAAA,EAAA,GACA,MAAA,MAAA,KAAA,EAAA,MAAA,MAAA,MAAA,KAIA,QAAA,SAAA,GACA,MAAA,MAAA,MAAA,EAAA,KAGA,SAAA,WACA,MAAA,WAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA;EAGA,UAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,EAAA,KAAA,EAAA,KAAA,IAQA,QAAA,SAAA,EAAA,EAAA,EAAA,GAKA,MAJA,MAAA,EAAA,EACA,KAAA,EAAA,EACA,KAAA,EAAA,EACA,KAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAGA,IAAA,SAAA,GACA,MAAA,MAAA,QAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGA,IAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,UAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,SAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,SAAA,SAAA,GAGA,MAAA,MAAA,eAAA,IAGA,kBAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,aAAA,SAAA,GACA,MAAA,MAAA,QAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,OAAA,WACA,MAAA,MAAA,SAAA,KAAA,GAAA,KAAA,GAAA,KAAA,GAAA,KAAA,IChRA,UAAA,WACA,GAAA,GAAA,KAAA,WACA,IAAA,IAAA,EACA,KAAA,IAAA,OAAA,2CAGA,OAAA,MAAA,aAAA,KASA,EAAA,UAAA,SAAA,EAAA,EAAA,EAAA,GACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,SAAA,EAAA,EAAA,EAEA,IAAA,GAAA,EAAA,SA0BA,OAxBA,GAAA,UAAA,GAAA,GACA,EAAA,UAAA,YAAA,EAGA,EAAA,sBAAA,SAAA,GACA,EAAA,UAAA,GAAA,WACA,KAAA,IAAA,OAAA,+BAAA,EAAA,4BAKA,EAAA,sBAAA,WACA,EAAA,sBAAA,QACA,EAAA,sBAAA,QACA,EAAA,sBAAA,QACA,EAAA,sBAAA,QAGA,EAAA,KAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAEA,IAaA,EAAA,eAAA,UAAA,UAAA,WAAA,cAAA,eAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,YACA,EAAA,eACA,EAAA,eAEA,EAAA,QAAA,SAAA,EAAA,EAAA,GAEA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EAEA,IAAA,GAAA,EAAA,OAEA,GAAA,WACA,YAAA,EACA,WAAA,EACA,UAAA,EAEA,UAAA,WACA,MAAA,MAAA,KAAA,KAAA,qBAGA,iBAAA,WACA,MAAA,MAAA,IAAA,OAIA,SAAA,SAAA,GACA,MAAA,MAAA,KAAA,KAAA,gBAAA,KAIA,gBAAA,SAAA,GACA,GAAA,GAAA,KAAA,EAAA,EAAA,EACA,EAAA,KAAA,EAAA,EAAA,EACA,EAAA,KAAA,EAAA,EAAA,CACA,OAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAGA,IAAA,SAAA,GACA,MAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAGA,SAAA,WACA,MAAA,UAAA,KAAA,IAAA,SAAA,KAAA,IAAA,SAAA,KAAA,IAGA,OAAA,SAAA,GACA,MAAA,MAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GAGA,cAAA,SAAA,EAAA,GAIA,MAHA,KACA,EAAA,GAEA,KAAA,IAAA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,KAAA,EAAA,EAAA,GAAA,KAAA,IAAA,KAAA,EAAA,EAAA,IAAA,GAQA,KAAA,SAAA,GACA,MAAA,GACA,EAAA,IAAA,MAGA,GAAA,GAAA,KAAA,EAAA,KAAA,EAAA,KAAA,IAIA,MAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EACA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EACA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAIA,WAAA,WACA,GAAA,GAAA,KAAA,WACA,IAAA,IAAA,EACA,KAAA,IAAA,OAAA,2CAGA,OAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAIA,cAAA,SAAA,GACA,MAAA,MAAA,OAAA,aAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,MAAA,SAAA,GAGA,MAAA,MAAA,YAAA,IAGA,eAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,KAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,WAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,MAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,YAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,cAAA,SAAA,GACA,MAAA,IAAA,GAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,QAAA,WACA,MAAA,IAAA,IAAA,KAAA,GAAA,KAAA,GAAA,KAAA,IAGA,aAAA,SAAA,GACA,MAAA,MAAA,KAAA,EAAA,MAAA,KAAA,aAAA,IAAA,EAAA,cAAA,GAAA,KAIA,MAAA,SAAA,EAAA,GACA,MAAA,MAAA,KAAA,EAAA,MAAA,MAAA,MAAA,KAIA,QAAA,SAAA,GACA,MAAA,MAAA,MAAA,EAAA,KAGA,SAAA,WACA,MAAA,WAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAGA,UAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,EAAA,KAAA,IAGA,UAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,EAAA,KAAA,EAAA,KAAA,IAQA,OAAA,SAAA,EAAA,EAAA,GAIA,MAHA,MAAA,EAAA,EACA,KAAA,EAAA,EACA,KAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAEA,KAAA,SAAA,GAEA,MADA,MAAA,EAAA,EACA,MAGA,IAAA,SAAA,GACA,MAAA,MAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAIA,aAAA,SAAA,GACA,GAAA,GAAA,EAAA,KAAA,WACA,OAAA,MAAA,eAAA,IAGA,IAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,UAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,SAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,eAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,SAAA,SAAA,GAGA,MAAA,MAAA,eAAA,IAGA,kBAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,IAGA,aAAA,SAAA,GACA,MAAA,MAAA,OAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,IAGA,OAAA,WACA,MAAA,MAAA,QAAA,KAAA,GAAA,KAAA,GAAA,KAAA,IAGA,UAAA,WACA,GAAA,GAAA,KAAA,WACA,IAAA,IAAA,EACA,KAAA,IAAA,OAAA,2CAGA,OAAA,MAAA,aAAA,KClSA,EAAA,MAAA,SAAA,EAAA,EAAA,GAEA,MAAA,GAAA,WAAA,MAAA,GAAA,GAAA,WAAA,EAAA,WAAA,sBAAA,EAAA,GAAA,GAAA,aAAA,IAMA,EAAA,UAAA,SAAA,EAAA,EAAA,GACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EAEA,IAAA,GAAA,EAAA,SAwBA,OAtBA,GAAA,UAAA,GAAA,GACA,EAAA,UAAA,YAAA,EAGA,EAAA,sBAAA,SAAA,GACA,EAAA,UAAA,GAAA,WACA,KAAA,IAAA,OAAA,+BAAA,EAAA,4BAKA,EAAA,sBAAA,UACA,EAAA,sBAAA,QACA,EAAA,sBAAA,QACA,EAAA,sBAAA,QAGA,EAAA,KAAA,GAAA,GAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,GACA,EAAA,OAAA,GAAA,GAAA,EAAA,EAAA,GAEA,IAcA,EAAA,eAAA,UAAA,UAAA,cAAA,eAAA,SAAA,GAGA,GAAA,GAAA,EAAA,UAEA,GAAA,eACA,EAAA,cAEA,IAAA,GAAA,OAAA,cAAA,KAEA,GAAA,QAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAGA,KAAA,QAAA,GAAA,GAAA,IAEA,KAAA,SACA,SAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EACA,GAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EACA,GAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,EACA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,EACA,GAEA,IAAA,GAAA,EAAA,OAEA,GAAA,OACA,MAAA,EACA,SAAA,EACA,eAAA,EACA,QAAA,EACA,OAAA,EAKA,IAAA,GAAA,EAAA,KChDA,ODkDA,GAAA,SAAA,WACA,MAAA,IAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,WAGA,EAAA,YAAA,SAAA,EAAA,EAAA,GACA,MAAA,IAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,iBAGA,EAAA,sBAAA,SAAA,GAAA,MAAA,GAAA,YAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAEA,EAAA,QAAA,SAAA,EAAA,EAAA,GAKA,MAHA,GAAA,SAAA,EAAA,EAAA,EACA,EAAA,SAAA,EAAA,EAAA,EAEA,GAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,UAIA,EAAA,kBAAA,SAAA,EAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,GACA,EAAA,EAAA,CAEA,OAAA,IAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,SAKA,EAAA,UAAA,SAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,SAGA,EAAA,UAAA,SAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,SAGA,EAAA,UAAA,SAAA,GACA,GAAA,GAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GACA,GAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,SAIA,EAAA,eAAA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,EAEA,OAAA,IAAA,GACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,IAGA,EAAA,WACA,YAAA,EAEA,SAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAoBA,MAnBA,MAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,GAAA,EACA,KAAA,QAAA,IAAA,EACA,KAAA,QAAA,IAAA,EACA,KAAA,QAAA,IAAA,EACA,KAAA,QAAA,IAAA,EACA,KAAA,QAAA,IAAA,EACA,KAAA,QAAA,IAAA,EAGA,KAAA,KAAA,SAAA,EAAA,IAAA,GAAA,IAAA,GAAA,IAAA,GAAA,IAAA,EAAA,EAAA,OAAA,EAAA,MAAA,EACA,MAGA,YAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,MAAA,MAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGA,IAAA,SAAA,GACA,MAAA,MAAA,SACA,EAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAA,MACA,EAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAA,MACA,EAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAA,MACA,EAAA,MAAA,EAAA,MAAA,EAAA,MAAA,EAAA,MACA,EAAA,OAIA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,KACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,KACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,KACA,IAAA,WAAA,MAAA,MAAA,QAAA,KACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,IACA,IAAA,WAAA,MAAA,MAAA,QAAA,KACA,IAAA,WAAA,MAAA,MAAA,QAAA,KAEA,SAAA,WACA,MAAA,UAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QACA,SAAA,KAAA,QAIA,eAAA,WACA,MAAA,IAAA,GAAA,QAAA,KAAA,MAAA,KAAA,MAAA,KAAA,QAEA,GAAA,eAAA,MAAA,MAAA,kBAIA,eAAA,WACA,GAAA,GAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,MACA,EAAA,KAAA,MAAA,KAAA,KACA,OAAA,IAAA,GAAA,QACA,KAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,KAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,KAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAEA,GAAA,eAAA,MAAA,MAAA,kBAEA,gBAAA,WAQA,MAAA,YACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,GAAA,QAAA,IAAA,IACA,KAAA,QAAA,IAAA,QAAA,IAAA,IACA,KAAA,QAAA,IAAA,QAAA,IAAA,IACA,KAAA,QAAA,IAAA,QAAA,IAAA,IACA,KAAA,QAAA,IAAA,QAAA,IAAA,IACA,KAAA,QAAA,IAAA,QAAA,IAAA,IACA,KAAA,QAAA,IAAA,QAAA,IAAA,KAEA,GAAA,gBAAA,MAAA,MAAA,mBAGA,OAAA,SAAA,GACA,MAAA,MAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OACA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OACA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OACA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAAA,KAAA,QAAA,EAAA,OAIA,cAAA,SAAA,EAAA,GACA,MAAA,MAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GACA,KAAA,IAAA,KAAA,MAAA,EAAA,OAAA,GAOA,KAAA,WACA,MAAA,IAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,OAIA,KAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAIA,MAAA,SAAA,GACA,MAAA,IAAA,GACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,QAIA,WAAA,WACA,MAAA,IAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,QAGA,QAAA,WACA,MAAA,IAAA,IACA,KAAA,OAAA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,OAAA,KAAA,OACA,KAAA,OAAA,KAAA,OAAA,KAAA,OAAA,KAAA,QAGA,SAAA,WACA,OAAA,KAAA,MACA,IAAA,GAAA,SACA,MAAA,KACA,KAAA,GAAA,eACA,MAAA,IAAA,GACA,EAAA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,GAAA,KAAA,MACA,EAAA,EAAA,EAAA,EAAA,EAAA,eACA,KAAA,GAAA,QACA,MAAA,IAAA,GACA,EAAA,KAAA,MAAA,EAAA,EAAA,EACA,EAAA,EAAA,KAAA,MAAA,EAAA,EACA,EAAA,EAAA,EAAA,KAAA,MAAA,EACA,EAAA,EAAA,EAAA,EAAA,KAAA,MAAA,EAAA,QACA,KAAA,GAAA,OACA,IAAA,GAAA,MACA,GAAA,GAAA,KAAA,gBACA,IAAA,IAAA,EACA,MAAA,IAAA,KACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,EAIA,MAAA,IAAA,OAAA,kDAGA,SACA,KAAA,IAAA,OAAA,uCAAA,KAAA,QAIA,YAAA,SAAA,GAEA,GAAA,KAAA,OAAA,EAAA,UAAA,EAAA,OAAA,EAAA,SACA,MAAA,MAAA,OAAA,EAAA,SAAA,EAAA,IAGA,IAAA,KAAA,OAAA,EAAA,KAAA,CAEA,GAAA,KAAA,OAAA,EAAA,eAEA,MAAA,IAAA,GACA,EAAA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,EAAA,KAAA,MAAA,EAAA,MACA,EAAA,EAAA,EAAA,EAAA,EAAA,eAEA,IAAA,KAAA,OAAA,EAAA,QAEA,MAAA,IAAA,GACA,KAAA,MAAA,EAAA,MAAA,EAAA,EAAA,EACA,EAAA,KAAA,MAAA,EAAA,MAAA,EAAA,EACA,EAAA,EAAA,KAAA,MAAA,EAAA,MAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,SAIA,MAAA,MAAA,OAAA,EAAA,OAAA,EAAA,OAAA,EAAA,MAIA,GAAA,GACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MACA,EAAA,EAAA,EAAA,EAAA,EAAA,QAIA,GAAA,GACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MACA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAAA,EAAA,MAAA,KAAA,MAA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","sourcesContent":["/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function( undef ) {\n  var main, req, makeMap, handlers,\n    defined = {},\n    waiting = {},\n    config = {},\n    defining = {},\n    hasOwn = Object.prototype.hasOwnProperty,\n    aps = [].slice,\n    jsSuffixRegExp = /\\.js$/;\n\n  function hasProp( obj, prop ) {\n    return hasOwn.call( obj, prop );\n  }\n\n  /**\n   * Given a relative module name, like ./something, normalize it to\n   * a real name that can be mapped to a path.\n   * @param {String} name the relative name\n   * @param {String} baseName a real name that the name arg is relative\n   * to.\n   * @returns {String} normalized name\n   */\n  function normalize( name, baseName ) {\n    var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n      foundI, foundStarMap, starI, i, j, part,\n      baseParts = baseName && baseName.split( \"/\" ),\n      map = config.map,\n      starMap = (map && map[ '*' ]) || {};\n\n    //Adjust any relative paths.\n    if ( name && name.charAt( 0 ) === \".\" ) {\n      //If have a base name, try to normalize against it,\n      //otherwise, assume it is a top-level require that will\n      //be relative to baseUrl in the end.\n      if ( baseName ) {\n        //Convert baseName to array, and lop off the last part,\n        //so that . matches that \"directory\" and not name of the baseName's\n        //module. For instance, baseName of \"one/two/three\", maps to\n        //\"one/two/three.js\", but we want the directory, \"one/two\" for\n        //this normalization.\n        baseParts = baseParts.slice( 0, baseParts.length - 1 );\n        name = name.split( '/' );\n        lastIndex = name.length - 1;\n\n        // Node .js allowance:\n        if ( config.nodeIdCompat && jsSuffixRegExp.test( name[ lastIndex ] ) ) {\n          name[ lastIndex ] = name[ lastIndex ].replace( jsSuffixRegExp, '' );\n        }\n\n        name = baseParts.concat( name );\n\n        //start trimDots\n        for ( i = 0; i < name.length; i += 1 ) {\n          part = name[ i ];\n          if ( part === \".\" ) {\n            name.splice( i, 1 );\n            i -= 1;\n          }\n          else if ( part === \"..\" ) {\n            if ( i === 1 && (name[ 2 ] === '..' || name[ 0 ] === '..') ) {\n              //End of the line. Keep at least one non-dot\n              //path segment at the front so it can be mapped\n              //correctly to disk. Otherwise, there is likely\n              //no path mapping for a path starting with '..'.\n              //This can still fail, but catches the most reasonable\n              //uses of ..\n              break;\n            }\n            else if ( i > 0 ) {\n              name.splice( i - 1, 2 );\n              i -= 2;\n            }\n          }\n        }\n        //end trimDots\n\n        name = name.join( \"/\" );\n      }\n      else if ( name.indexOf( './' ) === 0 ) {\n        // No baseName, so this is ID is resolved relative\n        // to baseUrl, pull off the leading dot.\n        name = name.substring( 2 );\n      }\n    }\n\n    //Apply map config if available.\n    if ( (baseParts || starMap) && map ) {\n      nameParts = name.split( '/' );\n\n      for ( i = nameParts.length; i > 0; i -= 1 ) {\n        nameSegment = nameParts.slice( 0, i ).join( \"/\" );\n\n        if ( baseParts ) {\n          //Find the longest baseName segment match in the config.\n          //So, do joins on the biggest to smallest lengths of baseParts.\n          for ( j = baseParts.length; j > 0; j -= 1 ) {\n            mapValue = map[ baseParts.slice( 0, j ).join( '/' ) ];\n\n            //baseName segment has  config, find if it has one for\n            //this name.\n            if ( mapValue ) {\n              mapValue = mapValue[ nameSegment ];\n              if ( mapValue ) {\n                //Match, update name to the new value.\n                foundMap = mapValue;\n                foundI = i;\n                break;\n              }\n            }\n          }\n        }\n\n        if ( foundMap ) {\n          break;\n        }\n\n        //Check for a star map match, but just hold on to it,\n        //if there is a shorter segment match later in a matching\n        //config, then favor over this star map.\n        if ( !foundStarMap && starMap && starMap[ nameSegment ] ) {\n          foundStarMap = starMap[ nameSegment ];\n          starI = i;\n        }\n      }\n\n      if ( !foundMap && foundStarMap ) {\n        foundMap = foundStarMap;\n        foundI = starI;\n      }\n\n      if ( foundMap ) {\n        nameParts.splice( 0, foundI, foundMap );\n        name = nameParts.join( '/' );\n      }\n    }\n\n    return name;\n  }\n\n  function makeRequire( relName, forceSync ) {\n    return function() {\n      //A version of a require function that passes a moduleName\n      //value for items that may need to\n      //look up paths relative to the moduleName\n      return req.apply( undef, aps.call( arguments, 0 ).concat( [ relName, forceSync ] ) );\n    };\n  }\n\n  function makeNormalize( relName ) {\n    return function( name ) {\n      return normalize( name, relName );\n    };\n  }\n\n  function makeLoad( depName ) {\n    return function( value ) {\n      defined[ depName ] = value;\n    };\n  }\n\n  function callDep( name ) {\n    if ( hasProp( waiting, name ) ) {\n      var args = waiting[ name ];\n      delete waiting[ name ];\n      defining[ name ] = true;\n      main.apply( undef, args );\n    }\n\n    if ( !hasProp( defined, name ) && !hasProp( defining, name ) ) {\n      throw new Error( 'No ' + name );\n    }\n    return defined[ name ];\n  }\n\n  //Turns a plugin!resource to [plugin, resource]\n  //with the plugin being undefined if the name\n  //did not have a plugin prefix.\n  function splitPrefix( name ) {\n    var prefix,\n      index = name ? name.indexOf( '!' ) : -1;\n    if ( index > -1 ) {\n      prefix = name.substring( 0, index );\n      name = name.substring( index + 1, name.length );\n    }\n    return [ prefix, name ];\n  }\n\n  /**\n   * Makes a name map, normalizing the name, and using a plugin\n   * for normalization if necessary. Grabs a ref to plugin\n   * too, as an optimization.\n   */\n  makeMap = function( name, relName ) {\n    var plugin,\n      parts = splitPrefix( name ),\n      prefix = parts[ 0 ];\n\n    name = parts[ 1 ];\n\n    if ( prefix ) {\n      prefix = normalize( prefix, relName );\n      plugin = callDep( prefix );\n    }\n\n    //Normalize according\n    if ( prefix ) {\n      if ( plugin && plugin.normalize ) {\n        name = plugin.normalize( name, makeNormalize( relName ) );\n      }\n      else {\n        name = normalize( name, relName );\n      }\n    }\n    else {\n      name = normalize( name, relName );\n      parts = splitPrefix( name );\n      prefix = parts[ 0 ];\n      name = parts[ 1 ];\n      if ( prefix ) {\n        plugin = callDep( prefix );\n      }\n    }\n\n    //Using ridiculous property names for space reasons\n    return {\n      f: prefix ? prefix + '!' + name : name, //fullName\n      n: name,\n      pr: prefix,\n      p: plugin\n    };\n  };\n\n  function makeConfig( name ) {\n    return function() {\n      return (config && config.config && config.config[ name ]) || {};\n    };\n  }\n\n  handlers = {\n    require: function( name ) {\n      return makeRequire( name );\n    },\n    exports: function( name ) {\n      var e = defined[ name ];\n      if ( typeof e !== 'undefined' ) {\n        return e;\n      }\n      else {\n        return (defined[ name ] = {});\n      }\n    },\n    module: function( name ) {\n      return {\n        id: name,\n        uri: '',\n        exports: defined[ name ],\n        config: makeConfig( name )\n      };\n    }\n  };\n\n  main = function( name, deps, callback, relName ) {\n    var cjsModule, depName, ret, map, i,\n      args = [],\n      callbackType = typeof callback,\n      usingExports;\n\n    //Use name if no relName\n    relName = relName || name;\n\n    //Call the callback to define the module, if necessary.\n    if ( callbackType === 'undefined' || callbackType === 'function' ) {\n      //Pull out the defined dependencies and pass the ordered\n      //values to the callback.\n      //Default to [require, exports, module] if no deps\n      deps = !deps.length && callback.length ? [ 'require', 'exports', 'module' ] : deps;\n      for ( i = 0; i < deps.length; i += 1 ) {\n        map = makeMap( deps[ i ], relName );\n        depName = map.f;\n\n        //Fast path CommonJS standard dependencies.\n        if ( depName === \"require\" ) {\n          args[ i ] = handlers.require( name );\n        }\n        else if ( depName === \"exports\" ) {\n          //CommonJS module spec 1.1\n          args[ i ] = handlers.exports( name );\n          usingExports = true;\n        }\n        else if ( depName === \"module\" ) {\n          //CommonJS module spec 1.1\n          cjsModule = args[ i ] = handlers.module( name );\n        }\n        else if ( hasProp( defined, depName ) ||\n                  hasProp( waiting, depName ) ||\n                  hasProp( defining, depName ) ) {\n          args[ i ] = callDep( depName );\n        }\n        else if ( map.p ) {\n          map.p.load( map.n, makeRequire( relName, true ), makeLoad( depName ), {} );\n          args[ i ] = defined[ depName ];\n        }\n        else {\n          throw new Error( name + ' missing ' + depName );\n        }\n      }\n\n      ret = callback ? callback.apply( defined[ name ], args ) : undefined;\n\n      if ( name ) {\n        //If setting exports via \"module\" is in play,\n        //favor that over return value and exports. After that,\n        //favor a non-undefined return value over exports use.\n        if ( cjsModule && cjsModule.exports !== undef &&\n             cjsModule.exports !== defined[ name ] ) {\n          defined[ name ] = cjsModule.exports;\n        }\n        else if ( ret !== undef || !usingExports ) {\n          //Use the return value from the function.\n          defined[ name ] = ret;\n        }\n      }\n    }\n    else if ( name ) {\n      //May just be an object definition for the module. Only\n      //worry about defining if have a module name.\n      defined[ name ] = callback;\n    }\n  };\n\n  requirejs = require = req = function( deps, callback, relName, forceSync, alt ) {\n    if ( typeof deps === \"string\" ) {\n      if ( handlers[ deps ] ) {\n        //callback in this case is really relName\n        return handlers[ deps ]( callback );\n      }\n      //Just return the module wanted. In this scenario, the\n      //deps arg is the module name, and second arg (if passed)\n      //is just the relName.\n      //Normalize module name, if it contains . or ..\n      return callDep( makeMap( deps, callback ).f );\n    }\n    else if ( !deps.splice ) {\n      //deps is a config object, not an array.\n      config = deps;\n      if ( config.deps ) {\n        req( config.deps, config.callback );\n      }\n      if ( !callback ) {\n        return;\n      }\n\n      if ( callback.splice ) {\n        //callback is an array, which means it is a dependency list.\n        //Adjust args if there are dependencies\n        deps = callback;\n        callback = relName;\n        relName = null;\n      }\n      else {\n        deps = undef;\n      }\n    }\n\n    //Support require(['a'])\n    callback = callback || function() {};\n\n    //If relName is a function, it is an errback handler,\n    //so remove it.\n    if ( typeof relName === 'function' ) {\n      relName = forceSync;\n      forceSync = alt;\n    }\n\n    //Simulate async callback;\n    if ( forceSync ) {\n      main( undef, deps, callback, relName );\n    }\n    else {\n      //Using a non-zero value because of concern for what old browsers\n      //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n      //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n      //If want a value immediately, use require('id') instead -- something\n      //that works in almond on the global level, but not guaranteed and\n      //unlikely to work in other AMD implementations.\n      setTimeout( function() {\n        main( undef, deps, callback, relName );\n      }, 4 );\n    }\n\n    return req;\n  };\n\n  /**\n   * Just drops the config on the floor, but returns req in case\n   * the config return value is used.\n   */\n  req.config = function( cfg ) {\n    return req( cfg );\n  };\n\n  /**\n   * Expose module registry for debugging and tooling\n   */\n  requirejs._defined = defined;\n\n  define = function( name, deps, callback ) {\n\n    //This module may not have dependencies\n    if ( !deps.splice ) {\n      //deps is not an array, so probably means\n      //an object literal or factory function for\n      //the value. Adjust args.\n      callback = deps;\n      deps = [];\n    }\n\n    if ( !hasProp( defined, name ) && !hasProp( waiting, name ) ) {\n      waiting[ name ] = [ name, deps, callback ];\n    }\n  };\n\n  define.amd = {\n    jQuery: true\n  };\n}());\n\ndefine(\"almond\", function(){});\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Object instance allocation tracking, so we can cut down on garbage collection.\r\n *\r\n * Sample usage:\r\n * 1. Run the sim and set up the scenario that you wish to profile\r\n * 2. In the JS console, type: window.alloc={}\r\n * 3. Wait until you have taken enough data\r\n * 4. Type x = window.alloc; delete window.alloc;\r\n *\r\n * Now you can inspect the x variable which contains the allocation information.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/phetAllocation',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.phetAllocation = function phetAllocation( name ) {\r\n    if ( window.alloc ) {\r\n      var stack;\r\n      try { throw new Error(); }\r\n      catch( e ) { stack = e.stack; }\r\n\r\n      if ( !window.alloc[ name ] ) {\r\n        window.alloc[ name ] = { count: 0, stacks: {} };\r\n      }\r\n      var log = window.alloc[ name ];\r\n\r\n      log.count++;\r\n      if ( !log.stacks[ stack ] ) {\r\n        log.stacks[ stack ] = 1;\r\n      }\r\n      else {\r\n        log.stacks[ stack ] += 1;\r\n      }\r\n      log.report = function() {\r\n        var stacks = Object.keys( log.stacks );\r\n        stacks = _.sortBy( stacks, function( key ) { return log.stacks[ key ]; } );\r\n        _.each( stacks, function( stack ) {\r\n          console.log( log.stacks[ stack ] + ': ' + stack );\r\n        } );\r\n      };\r\n    }\r\n  };\r\n\r\n  return core.phetAllocation;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\ndefine( 'PHET_CORE/core',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  // no phetAllocation initialized, since we don't need it with just phet-core, and this file is required before that\r\n\r\n  // will be filled in by other modules\r\n  return {};\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally\r\n * since it prevents Require.js issues with circular dependencies.\r\n *\r\n * The returned kite object namespace may be incomplete if not all modules are listed as\r\n * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/kite',['require','PHET_CORE/phetAllocation'],function( require ) {\r\n  'use strict';\r\n\r\n  // object allocation tracking\r\n  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );\r\n\r\n  // workaround for Axon, since it needs window.arch to be defined\r\n  window.arch = window.arch || null;\r\n\r\n  var kite = {\r\n    svgNumber: function( n ) {\r\n      return n.toFixed( 20 );\r\n    }\r\n  };\r\n\r\n  // store a reference on the PhET namespace if it exists\r\n  if ( window.phet ) {\r\n    window.phet.kite = kite;\r\n  }\r\n\r\n  // will be filled in by other modules\r\n  return kite;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\ndefine( 'DOT/dot',['require','PHET_CORE/phetAllocation'],function( require ) {\r\n  'use strict';\r\n\r\n  // object allocation tracking\r\n  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );\r\n\r\n  // workaround for Axon, since it needs window.arch to be defined\r\n  window.arch = window.arch || null;\r\n\r\n  var dot = function dot() {\r\n    switch( arguments.length ) {\r\n      case 2:\r\n        return new dot.Vector2( arguments[ 0 ], arguments[ 1 ] );\r\n      case 3:\r\n        return new dot.Vector3( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n      case 4:\r\n        return new dot.Vector4( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ], arguments[ 3 ] );\r\n      default:\r\n        throw new Error( 'dot takes 2-4 arguments' );\r\n    }\r\n  };\r\n\r\n  // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.\r\n  dot.FastArray = window.Float64Array ? window.Float64Array : window.Array;\r\n\r\n  // store a reference on the PhET namespace if it exists\r\n  if ( window.phet ) {\r\n    window.phet.dot = dot;\r\n  }\r\n\r\n  // will be filled in by other modules\r\n  return dot;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.\r\n *\r\n * See https://github.com/documentcloud/underscore/pull/986.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/extend',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.extend = function extend( obj ) {\r\n    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {\r\n      if ( source ) {\r\n        for ( var prop in source ) {\r\n          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\r\n        }\r\n      }\r\n    } );\r\n    return obj;\r\n  };\r\n\r\n  return core.extend;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Utility function for setting up prototypal inheritance.\r\n * Maintains supertype.prototype.constructor while properly copying ES5 getters and setters.\r\n * Supports adding functions to both the prototype itself and the constructor function.\r\n *\r\n * Usage:\r\n *\r\n * // Call the supertype constructor somewhere in the subtype's constructor.\r\n * function A() { scenery.Node.call( this ); };\r\n *\r\n * // Add prototype functions and/or 'static' functions\r\n * return inherit( scenery.Node, A, {\r\n *   customBehavior: function() { ... },\r\n *   isAnA: true\r\n * }, {\r\n *   someStaticFunction: function() { ...}\r\n * } );\r\n *\r\n * // client calls\r\n * new A().isAnA; // true\r\n * new scenery.Node().isAnA; // undefined\r\n * new A().constructor.name; // 'A'\r\n * A.someStaticFunction();\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\ndefine( 'PHET_CORE/inherit',['require','PHET_CORE/core','PHET_CORE/extend'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n  var extend = require( 'PHET_CORE/extend' );\r\n\r\n  /**\r\n   * @param supertype           Constructor for the supertype.\r\n   * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )\r\n   * @param prototypeProperties [optional] object containing properties that will be set on the prototype.\r\n   * @param staticProperties [optional] object containing properties that will be set on the constructor function itself\r\n   */\r\n  core.inherit = function inherit( supertype, subtype, prototypeProperties, staticProperties ) {\r\n    assert && assert( typeof supertype === 'function' );\r\n\r\n    function F() {}\r\n\r\n    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype\r\n\r\n    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy\r\n      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely\r\n      { constructor: subtype }, // overrides the constructor properly\r\n      prototypeProperties       // [optional] additional properties for the prototype, as an object.\r\n    );\r\n\r\n    //Copy the static properties onto the subtype constructor so they can be accessed 'statically'\r\n    extend( subtype, staticProperties );\r\n\r\n    return subtype; // pass back the subtype so it can be returned immediately as a module export\r\n  };\r\n\r\n  return core.inherit;\r\n} );\n","// Copyright 2002-2014, University of Colorado\r\n\r\n/**\r\n * Experimental object pooling mix-in\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/Poolable',['require','PHET_CORE/core','PHET_CORE/extend'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n  var extend = require( 'PHET_CORE/extend' );\r\n\r\n  /*\r\n   * For option details, please see documentation inside this constructor body for now\r\n   */\r\n  core.Poolable = {\r\n    mixin: function ( type, options ) {\r\n      var proto = type.prototype;\r\n\r\n      // defaults\r\n      options = extend( {\r\n        maxPoolSize: 50, // since we don't want to blow too much memory\r\n        initialSize: 0\r\n      }, options );\r\n\r\n      var pool = type.pool = [];\r\n\r\n      /*\r\n       * For example: defaultFactory: function() { return new Vector2(); }\r\n       */\r\n      if ( options.defaultFactory ) {\r\n        type.dirtyFromPool = function() {\r\n          if ( pool.length ) {\r\n            // return an instance in an arbitrary (dirty) state\r\n            return pool.pop();\r\n          }\r\n          else {\r\n            // else return a new default instance\r\n            return options.defaultFactory();\r\n          }\r\n        };\r\n\r\n        // fills the object pool up to n instances\r\n        type.fillPool = function( n ) {\r\n          // fill up the object pool to the initial size\r\n          while ( pool.length < n ) {\r\n            pool.push( options.defaultFactory() );\r\n          }\r\n        };\r\n\r\n        // fill the pool initially to the initial size\r\n        type.fillPool( options.initialSize );\r\n      }\r\n\r\n      /*\r\n       * For example: constructorDuplicateFactory:\r\n       *                function( pool ) {\r\n       *                  return function( x, y ) {\r\n       *                    if ( pool.length ) {\r\n       *                      return pool.pop().set( x, y );\r\n       *                    } else {\r\n       *                      return new Vector2( x, y );\r\n       *                    }\r\n       *                  }\r\n       *                }\r\n       * It allows arbitrary creation (from the constructor / etc) or mutation (from the pooled instance).\r\n       */\r\n      if ( options.constructorDuplicateFactory ) {\r\n        type.createFromPool = options.constructorDuplicateFactory( pool );\r\n      }\r\n\r\n      /*\r\n       * Frees the object to the pool (instance.freeToPool())\r\n       */\r\n      proto.freeToPool = function() {\r\n        if ( pool.length < options.maxPoolSize ) {\r\n          pool.push( this );\r\n        }\r\n      };\r\n    }\r\n  };\r\n\r\n  return core.Poolable;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Utility functions for Dot, placed into the dot.X namespace.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Util',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n  // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference\r\n\r\n  dot.Util = {\r\n    testAssert: function() {\r\n      return 'assert.dot: ' + ( assert ? 'true' : 'false' );\r\n    },\r\n\r\n    clamp: function( value, min, max ) {\r\n      if ( value < min ) {\r\n        return min;\r\n      }\r\n      else if ( value > max ) {\r\n        return max;\r\n      }\r\n      else {\r\n        return value;\r\n      }\r\n    },\r\n\r\n    // returns a number between [min,max) with the same equivalence class as value mod (max-min)\r\n    moduloBetweenDown: function( value, min, max ) {\r\n      assert && assert( max > min, 'max > min required for moduloBetween' );\r\n\r\n      var divisor = max - min;\r\n\r\n      // get a partial result of value-min between [0,divisor)\r\n      var partial = ( value - min ) % divisor;\r\n      if ( partial < 0 ) {\r\n        // since if value-min < 0, the remainder will give us a negative number\r\n        partial += divisor;\r\n      }\r\n\r\n      return partial + min; // add back in the minimum value\r\n    },\r\n\r\n    // returns a number between (min,max] with the same equivalence class as value mod (max-min)\r\n    moduloBetweenUp: function( value, min, max ) {\r\n      return -Util.moduloBetweenDown( -value, -max, -min );\r\n    },\r\n\r\n    // Returns an array of integers from A to B (including both A to B)\r\n    rangeInclusive: function( a, b ) {\r\n      if ( b < a ) {\r\n        return [];\r\n      }\r\n      var result = new Array( b - a + 1 );\r\n      for ( var i = a; i <= b; i++ ) {\r\n        result[ i - a ] = i;\r\n      }\r\n      return result;\r\n    },\r\n\r\n    // Returns an array of integers between A and B (excluding both A to B)\r\n    rangeExclusive: function( a, b ) {\r\n      return Util.rangeInclusive( a + 1, b - 1 );\r\n    },\r\n\r\n    toRadians: function( degrees ) {\r\n      return Math.PI * degrees / 180;\r\n    },\r\n\r\n    toDegrees: function( radians ) {\r\n      return 180 * radians / Math.PI;\r\n    },\r\n\r\n    // find the greatest common denominator using the classic algorithm\r\n    gcd: function( a, b ) {\r\n      return b === 0 ? a : this.gcd( b, a % b );\r\n    },\r\n\r\n    // intersection between the line from p1-p2 and the line from p3-p4\r\n    lineLineIntersection: function( p1, p2, p3, p4 ) {\r\n      var x12 = p1.x - p2.x;\r\n      var x34 = p3.x - p4.x;\r\n      var y12 = p1.y - p2.y;\r\n      var y34 = p3.y - p4.y;\r\n\r\n      var denom = x12 * y34 - y12 * x34;\r\n\r\n      var a = p1.x * p2.y - p1.y * p2.x;\r\n      var b = p3.x * p4.y - p3.y * p4.x;\r\n\r\n      return new dot.Vector2(\r\n        ( a * x34 - x12 * b ) / denom,\r\n        ( a * y34 - y12 * b ) / denom\r\n      );\r\n    },\r\n\r\n    // assumes a sphere with the specified radius, centered at the origin\r\n    sphereRayIntersection: function( radius, ray, epsilon ) {\r\n      epsilon = epsilon === undefined ? 1e-5 : epsilon;\r\n\r\n      // center is the origin for now, but leaving in computations so that we can change that in the future. optimize away if needed\r\n      var center = new dot.Vector3();\r\n\r\n      var rayDir = ray.dir;\r\n      var pos = ray.pos;\r\n      var centerToRay = pos.minus( center );\r\n\r\n      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)\r\n      var tmp = rayDir.dot( centerToRay );\r\n      var centerToRayDistSq = centerToRay.magnitudeSquared();\r\n      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - radius * radius );\r\n      if ( det < epsilon ) {\r\n        // ray misses sphere entirely\r\n        return null;\r\n      }\r\n\r\n      var base = rayDir.dot( center ) - rayDir.dot( pos );\r\n      var sqt = Math.sqrt( det ) / 2;\r\n\r\n      // the \"first\" entry point distance into the sphere. if we are inside the sphere, it is behind us\r\n      var ta = base - sqt;\r\n\r\n      // the \"second\" entry point distance\r\n      var tb = base + sqt;\r\n\r\n      if ( tb < epsilon ) {\r\n        // sphere is behind ray, so don't return an intersection\r\n        return null;\r\n      }\r\n\r\n      var hitPositionB = ray.pointAtDistance( tb );\r\n      var normalB = hitPositionB.minus( center ).normalized();\r\n\r\n      if ( ta < epsilon ) {\r\n        // we are inside the sphere\r\n        // in => out\r\n        return {\r\n          distance: tb,\r\n          hitPoint: hitPositionB,\r\n          normal: normalB.negated(),\r\n          fromOutside: false\r\n        };\r\n      }\r\n      else {\r\n        // two possible hits\r\n        var hitPositionA = ray.pointAtDistance( ta );\r\n        var normalA = hitPositionA.minus( center ).normalized();\r\n\r\n        // close hit, we have out => in\r\n        return {\r\n          distance: ta,\r\n          hitPoint: hitPositionA,\r\n          normal: normalA,\r\n          fromOutside: true\r\n        };\r\n      }\r\n    },\r\n\r\n    // return an array of real roots of ax^2 + bx + c = 0\r\n    solveQuadraticRootsReal: function( a, b, c ) {\r\n      var epsilon = 1E7;\r\n\r\n      //We need to test whether a is several orders of magnitude less than b or c. If so, return the result as a solution to the linear (easy) equation\r\n      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon ) {\r\n        return [ -c / b ];\r\n      }\r\n\r\n      var discriminant = b * b - 4 * a * c;\r\n      if ( discriminant < 0 ) {\r\n        return [];\r\n      }\r\n      var sqrt = Math.sqrt( discriminant );\r\n      // TODO: how to handle if discriminant is 0? give unique root or double it?\r\n      // TODO: probably just use Complex for the future\r\n      return [\r\n        ( -b - sqrt ) / ( 2 * a ),\r\n        ( -b + sqrt ) / ( 2 * a )\r\n      ];\r\n    },\r\n\r\n    // return an array of real roots of ax^3 + bx^2 + cx + d = 0\r\n    solveCubicRootsReal: function( a, b, c, d ) {\r\n      // TODO: a Complex type!\r\n\r\n      //We need to test whether a is several orders of magnitude less than b, c, d\r\n      var epsilon = 1E7;\r\n\r\n      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {\r\n        return Util.solveQuadraticRootsReal( b, c, d );\r\n      }\r\n      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {\r\n        return Util.solveQuadraticRootsReal( a, b, c );\r\n      }\r\n\r\n      b /= a;\r\n      c /= a;\r\n      d /= a;\r\n\r\n      var q = ( 3.0 * c - ( b * b ) ) / 9;\r\n      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;\r\n      var discriminant = q * q * q + r * r;\r\n      var b3 = b / 3;\r\n\r\n      if ( discriminant > 0 ) {\r\n        // a single real root\r\n        var dsqrt = Math.sqrt( discriminant );\r\n        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];\r\n      }\r\n\r\n      // three real roots\r\n      if ( discriminant === 0 ) {\r\n        // contains a double root\r\n        var rsqrt = Util.cubeRoot( r );\r\n        var doubleRoot = b3 - rsqrt;\r\n        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];\r\n      }\r\n      else {\r\n        // all unique\r\n        var qX = -q * q * q;\r\n        qX = Math.acos( r / Math.sqrt( qX ) );\r\n        var rr = 2 * Math.sqrt( -q );\r\n        return [\r\n          -b3 + rr * Math.cos( qX / 3 ),\r\n          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),\r\n          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )\r\n        ];\r\n      }\r\n    },\r\n\r\n    cubeRoot: function( x ) {\r\n      return x >= 0 ? Math.pow( x, 1 / 3 ) : -Math.pow( -x, 1 / 3 );\r\n    },\r\n\r\n    // Linearly interpolate two points and evaluate the line equation for a third point\r\n    // f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>\r\n    linear: function( a1, a2, b1, b2, a3 ) {\r\n      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;\r\n    },\r\n\r\n    /**\r\n     * A predictable implementation of toFixed.\r\n     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,\r\n     * because the spec doesn't specify whether to round or floor.\r\n     * @param {number} number\r\n     * @param {number} decimalPlaces\r\n     * @returns {string}\r\n     */\r\n    toFixed: function( number, decimalPlaces ) {\r\n      var multiplier = Math.pow( 10, decimalPlaces );\r\n      var value = Math.round( number * multiplier ) / multiplier;\r\n      return value.toFixed( decimalPlaces );\r\n    },\r\n\r\n    // Convenience for returning a number instead of a string.\r\n    toFixedNumber: function( number, decimalPlaces ) {\r\n      return parseFloat( Util.toFixed( number, decimalPlaces ) );\r\n    },\r\n\r\n    isInteger: function( n ) {\r\n      return ( typeof n === 'number' ) && ( n % 1 === 0 );\r\n    },\r\n\r\n    /*\r\n     * Computes the intersection of two line segments. Algorithm taked from Paul Bourke, 1989:\r\n     * http://astronomy.swin.edu.au/~pbourke/geometry/lineline2d/\r\n     * Ported from MathUtil.java on 9/20/2013 by @samreid\r\n     * line a goes from point 1->2 and line b goes from 3->4\r\n     * @returns a Vector2 of the intersection point, or null if no intersection\r\n     */\r\n    lineSegmentIntersection: function( x1, y1, x2, y2, x3, y3, x4, y4 ) {\r\n      var numA = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\r\n      var numB = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\r\n      var denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\r\n\r\n      // If denominator is 0, the lines are parallel or coincident\r\n      if ( denom === 0 ) {\r\n        return null;\r\n      }\r\n      else {\r\n        var ua = numA / denom;\r\n        var ub = numB / denom;\r\n\r\n        // ua and ub must both be in the range 0 to 1 for the segments to have an intersection pt.\r\n        if ( !( ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1 ) ) {\r\n          return null;\r\n        }\r\n        else {\r\n          var x = x1 + ua * ( x2 - x1 );\r\n          var y = y1 + ua * ( y2 - y1 );\r\n          return new dot.Vector2( x, y );\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Squared distance from a point to a line segment squared.\r\n     * See http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n     *\r\n     * @param point the point\r\n     * @param a start point of a line segment\r\n     * @param b end point of a line segment\r\n     * @returns {Number}\r\n     */\r\n    distToSegmentSquared: function( point, a, b ) {\r\n      var segmentLength = a.distanceSquared( b );\r\n      if ( segmentLength === 0 ) { return point.distanceSquared( a ); }\r\n      var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / segmentLength;\r\n      return t < 0 ? point.distanceSquared( a ) :\r\n             t > 1 ? point.distanceSquared( b ) :\r\n             point.distanceSquared( new dot.Vector2( a.x + t * (b.x - a.x), a.y + t * (b.y - a.y) ) );\r\n    },\r\n\r\n    /**\r\n     * Squared distance from a point to a line segment squared.\r\n     * @param point the point\r\n     * @param a start point of a line segment\r\n     * @param b end point of a line segment\r\n     * @returns {Number}\r\n     */\r\n    distToSegment: function( point, a, b ) { return Math.sqrt( this.distToSegmentSquared( point, a, b ) ); },\r\n\r\n    arePointsCollinear: function( a, b, c, epsilon ) {\r\n      if ( epsilon === undefined ) {\r\n        epsilon = 0;\r\n      }\r\n      return Util.triangleArea( a, b, c ) <= epsilon;\r\n    },\r\n\r\n    triangleArea: function( a, b, c ) {\r\n      return Math.abs( Util.triangleAreaSigned( a, b, c ) );\r\n    },\r\n\r\n    // TODO: investigate which way we want the sign (Canvas or WebGL style)\r\n    triangleAreaSigned: function( a, b, c ) {\r\n      return a.x * ( b.y - c.y ) + b.x * ( c.y - a.y ) + c.x * ( a.y - b.y );\r\n    },\r\n\r\n    log10: function( val ) {\r\n      return Math.log( val ) / Math.LN10;\r\n    }\r\n  };\r\n  var Util = dot.Util;\r\n\r\n  // make these available in the main namespace directly (for now)\r\n  dot.testAssert = Util.testAssert;\r\n  dot.clamp = Util.clamp;\r\n  dot.moduloBetweenDown = Util.moduloBetweenDown;\r\n  dot.moduloBetweenUp = Util.moduloBetweenUp;\r\n  dot.rangeInclusive = Util.rangeInclusive;\r\n  dot.rangeExclusive = Util.rangeExclusive;\r\n  dot.toRadians = Util.toRadians;\r\n  dot.toDegrees = Util.toDegrees;\r\n  dot.lineLineIntersection = Util.lineLineIntersection;\r\n  dot.sphereRayIntersection = Util.sphereRayIntersection;\r\n  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;\r\n  dot.solveCubicRootsReal = Util.solveCubicRootsReal;\r\n  dot.cubeRoot = Util.cubeRoot;\r\n  dot.linear = Util.linear;\r\n\r\n  return Util;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 2-dimensional vector\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Vector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n  require( 'DOT/Util' );\r\n  // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency\r\n\r\n  dot.Vector2 = function Vector2( x, y ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n\r\n    assert && assert( typeof this.x === 'number', 'x needs to be a number' );\r\n    assert && assert( typeof this.y === 'number', 'y needs to be a number' );\r\n\r\n    phetAllocation && phetAllocation( 'Vector2' );\r\n  };\r\n  var Vector2 = dot.Vector2;\r\n\r\n  Vector2.createPolar = function( magnitude, angle ) {\r\n    return new Vector2().setPolar( magnitude, angle );\r\n  };\r\n\r\n  Vector2.prototype = {\r\n    constructor: Vector2,\r\n    isVector2: true,\r\n    dimension: 2,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      return this.x * this.x + this.y * this.y;\r\n    },\r\n\r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return Math.sqrt( this.distanceSquared( point ) );\r\n    },\r\n\r\n    // the distance between this vector (treated as a point) and another point specified as x:Number, y:Number\r\n    distanceXY: function( x, y ) {\r\n      var dx = this.x - x;\r\n      var dy = this.y - y;\r\n      return Math.sqrt( dx * dx + dy * dy );\r\n    },\r\n\r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      var dx = this.x - point.x;\r\n      var dy = this.y - point.y;\r\n      return dx * dx + dy * dy;\r\n    },\r\n\r\n    // the squared distance between this vector (treated as a point) and another point as (x,y)\r\n    distanceSquaredXY: function( x, y ) {\r\n      var dx = this.x - x;\r\n      var dy = this.y - y;\r\n      return dx * dx + dy * dy;\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y;\r\n    },\r\n\r\n    dotXY: function( vx, vy ) {\r\n      return this.x * vx + this.y * vy;\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y;\r\n    },\r\n\r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;\r\n    },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // create a copy, or if a vector is passed in, set that vector to our value\r\n    copy: function( vector ) {\r\n      if ( vector ) {\r\n        return vector.set( this );\r\n      }\r\n      else {\r\n        return new Vector2( this.x, this.y );\r\n      }\r\n    },\r\n\r\n    // z component of the equivalent 3-dimensional cross product (this.x, this.y,0) x (v.x, v.y, 0)\r\n    crossScalar: function( v ) {\r\n      return this.x * v.y - this.y * v.x;\r\n    },\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector2( this.x / mag, this.y / mag );\r\n      }\r\n    },\r\n\r\n    withMagnitude: function( magnitude ) {\r\n      return this.copy().setMagnitude( magnitude );\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector2( this.x * scalar, this.y * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector2( this.x * v.x, this.y * v.y );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector2( this.x + v.x, this.y + v.y );\r\n    },\r\n\r\n    plusXY: function( x, y ) {\r\n      return new Vector2( this.x + x, this.y + y );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector2( this.x + scalar, this.y + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector2( this.x - v.x, this.y - v.y );\r\n    },\r\n\r\n    minusXY: function( x, y ) {\r\n      return new Vector2( this.x - x, this.y - y );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector2( this.x - scalar, this.y - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector2( this.x / scalar, this.y / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector2( -this.x, -this.y );\r\n    },\r\n\r\n    angle: function() {\r\n      return Math.atan2( this.y, this.x );\r\n    },\r\n\r\n    // equivalent to a -PI/2 rotation (right hand rotation)\r\n    perpendicular: function() {\r\n      return new Vector2( this.y, -this.x );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      var thisMagnitude = this.magnitude();\r\n      var vMagnitude = v.magnitude();\r\n      return Math.acos( dot.clamp( ( this.x * v.x + this.y * v.y ) / ( thisMagnitude * vMagnitude ), -1, 1 ) );\r\n    },\r\n\r\n    rotated: function( angle ) {\r\n      var newAngle = this.angle() + angle;\r\n      var mag = this.magnitude();\r\n      return new Vector2( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );\r\n    },\r\n\r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );\r\n    },\r\n\r\n    // average position between this and the provided vector\r\n    average: function( vector ) {\r\n      return this.blend( vector, 0.5 );\r\n    },\r\n\r\n    toString: function() {\r\n      return 'Vector2(' + this.x + ', ' + this.y + ')';\r\n    },\r\n\r\n    toVector3: function() {\r\n      return new dot.Vector3( this.x, this.y );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // our core three functions which all mutation should go through\r\n    setXY: function( x, y ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    setX: function( x ) {\r\n      this.x = x;\r\n      return this;\r\n    },\r\n    setY: function( y ) {\r\n      this.y = y;\r\n      return this;\r\n    },\r\n\r\n    set: function( v ) {\r\n      return this.setXY( v.x, v.y );\r\n    },\r\n\r\n    //Sets the magnitude of the vector, keeping the same direction (though a negative magnitude will flip the vector direction)\r\n    setMagnitude: function( m ) {\r\n      var scale = m / this.magnitude();\r\n      return this.multiplyScalar( scale );\r\n    },\r\n\r\n    add: function( v ) {\r\n      return this.setXY( this.x + v.x, this.y + v.y );\r\n    },\r\n\r\n    addXY: function( x, y ) {\r\n      return this.setXY( this.x + x, this.y + y );\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      return this.setXY( this.x + scalar, this.y + scalar );\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      return this.setXY( this.x - v.x, this.y - v.y );\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      return this.setXY( this.x - scalar, this.y - scalar );\r\n    },\r\n\r\n    multiplyScalar: function( scalar ) {\r\n      return this.setXY( this.x * scalar, this.y * scalar );\r\n    },\r\n\r\n    multiply: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.multiplyScalar( scalar );\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      return this.setXY( this.x * v.x, this.y * v.y );\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      return this.setXY( this.x / scalar, this.y / scalar );\r\n    },\r\n\r\n    negate: function() {\r\n      return this.setXY( -this.x, -this.y );\r\n    },\r\n\r\n    normalize: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return this.divideScalar( mag );\r\n      }\r\n    },\r\n\r\n    rotate: function( angle ) {\r\n      var newAngle = this.angle() + angle;\r\n      var mag = this.magnitude();\r\n      return this.setXY( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );\r\n    },\r\n\r\n    setPolar: function( magnitude, angle ) {\r\n      return this.setXY( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );\r\n    }\r\n\r\n  };\r\n\r\n  Poolable.mixin( Vector2, {\r\n    defaultFactory: function() { return new Vector2(); },\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( x, y ) {\r\n        if ( pool.length ) {\r\n          return pool.pop().setXY( x, y );\r\n        }\r\n        else {\r\n          return new Vector2( x, y );\r\n        }\r\n      };\r\n    }\r\n  } );\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector2.Immutable = function ImmutableVector2( x, y ) {\r\n    Vector2.call( this, x, y );\r\n  };\r\n  var Immutable = Vector2.Immutable;\r\n\r\n  inherit( Vector2, Immutable );\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[ mutableFunctionName ] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector2\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'setXY' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n\r\n  // helpful immutable constants\r\n  Vector2.ZERO = new Immutable( 0, 0 );\r\n  Vector2.X_UNIT = new Immutable( 1, 0 );\r\n  Vector2.Y_UNIT = new Immutable( 0, 1 );\r\n\r\n  return Vector2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A 2D rectangle-shaped bounded area (bounding box)\r\n *\r\n * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not\r\n * store these with the Bounds2 instance, since we want to lower the memory footprint.\r\n *\r\n * minX, minY, maxX, and maxY are actually stored. We don't do x,y,width,height because this can't properly express\r\n * semi-infinite bounds (like a half-plane), or easily handle what Bounds2.NOTHING and Bounds2.EVERYTHING do with\r\n * the constructive solid areas.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Bounds2',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n\r\n  require( 'DOT/Vector2' );\r\n\r\n  //Temporary instances to be used in the transform method.\r\n  var scratchVector2 = new dot.Vector2();\r\n\r\n  // not using x,y,width,height so that it can handle infinity-based cases in a better way\r\n  dot.Bounds2 = function Bounds2( minX, minY, maxX, maxY ) {\r\n    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );\r\n    this.minX = minX;\r\n    this.minY = minY;\r\n    this.maxX = maxX;\r\n    this.maxY = maxY;\r\n\r\n    phetAllocation && phetAllocation( 'Bounds2' );\r\n  };\r\n  var Bounds2 = dot.Bounds2;\r\n\r\n  Bounds2.prototype = {\r\n    constructor: Bounds2,\r\n\r\n    isBounds: true,\r\n    dimension: 2,\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Properties\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    getWidth: function() { return this.maxX - this.minX; },\r\n    get width() { return this.getWidth(); },\r\n\r\n    getHeight: function() { return this.maxY - this.minY; },\r\n    get height() { return this.getHeight(); },\r\n\r\n    /*\r\n     * Convenience locations\r\n     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the \"upper\", and minY is the \"lower\"\r\n     *\r\n     *             minX (x)     centerX        maxX\r\n     *          ---------------------------------------\r\n     * minY (y) | leftTop     centerTop     rightTop\r\n     * centerY  | leftCenter  center        rightCenter\r\n     * maxY     | leftBottom  centerBottom  rightBottom\r\n     */\r\n    getX: function() { return this.minX; },\r\n    get x() { return this.getX(); },\r\n    getY: function() { return this.minY; },\r\n    get y() { return this.getY(); },\r\n\r\n    getMinX: function() { return this.minX; },\r\n    get left() { return this.minX; },\r\n    getMinY: function() { return this.minY; },\r\n    get top() { return this.minY; },\r\n    getMaxX: function() { return this.maxX; },\r\n    get right() { return this.maxX; },\r\n    getMaxY: function() { return this.maxY; },\r\n    get bottom() { return this.maxY; },\r\n\r\n    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },\r\n    get centerX() { return this.getCenterX(); },\r\n    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },\r\n    get centerY() { return this.getCenterY(); },\r\n\r\n    getLeftTop: function() { return new dot.Vector2( this.minX, this.minY ); },\r\n    get leftTop() { return this.getLeftTop(); },\r\n    getCenterTop: function() { return new dot.Vector2( this.getCenterX(), this.minY ); },\r\n    get centerTop() { return this.getCenterTop(); },\r\n    getRightTop: function() { return new dot.Vector2( this.maxX, this.minY ); },\r\n    get rightTop() { return this.getRightTop(); },\r\n    getLeftCenter: function() { return new dot.Vector2( this.minX, this.getCenterY() ); },\r\n    get leftCenter() { return this.getLeftCenter(); },\r\n    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },\r\n    get center() { return this.getCenter(); },\r\n    getRightCenter: function() { return new dot.Vector2( this.maxX, this.getCenterY() ); },\r\n    get rightCenter() { return this.getRightCenter(); },\r\n    getLeftBottom: function() { return new dot.Vector2( this.minX, this.maxY ); },\r\n    get leftBottom() { return this.getLeftBottom(); },\r\n    getCenterBottom: function() { return new dot.Vector2( this.getCenterX(), this.maxY ); },\r\n    get centerBottom() { return this.getCenterBottom(); },\r\n    getRightBottom: function() { return new dot.Vector2( this.maxX, this.maxY ); },\r\n    get rightBottom() { return this.getRightBottom(); },\r\n\r\n    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );\r\n    },\r\n\r\n    hasNonzeroArea: function() {\r\n      return this.getWidth() > 0 && this.getHeight() > 0;\r\n    },\r\n\r\n    isValid: function() {\r\n      return !this.isEmpty() && this.isFinite();\r\n    },\r\n\r\n    // whether the coordinates are inside the bounding box (or on the boundary)\r\n    containsCoordinates: function( x, y ) {\r\n      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\r\n    },\r\n\r\n    // whether the point is inside the bounding box (or on the boundary)\r\n    containsPoint: function( point ) {\r\n      return this.containsCoordinates( point.x, point.y );\r\n    },\r\n\r\n    // whether this bounding box completely contains the argument bounding box\r\n    containsBounds: function( bounds ) {\r\n      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;\r\n    },\r\n\r\n    // whether the intersection is non-empty (if they share any part of a boundary, this will be true)\r\n    intersectsBounds: function( bounds ) {\r\n      // TODO: more efficient way of doing this?\r\n      return !this.intersection( bounds ).isEmpty();\r\n    },\r\n\r\n    // distance to the closest point inside the Bounds2\r\n    minimumDistanceToPointSquared: function( point ) {\r\n      var closeX = point.x < this.minX ? this.minX : ( point.x > this.maxX ? this.maxX : null );\r\n      var closeY = point.y < this.minY ? this.minY : ( point.y > this.maxY ? this.maxY : null );\r\n      var d;\r\n      if ( closeX === null && closeY === null ) {\r\n        // inside, or on the boundary\r\n        return 0;\r\n      }\r\n      else if ( closeX === null ) {\r\n        // vertically directly above/below\r\n        d = closeY - point.y;\r\n        return d * d;\r\n      }\r\n      else if ( closeY === null ) {\r\n        // horizontally directly to the left/right\r\n        d = closeX - point.x;\r\n        return d * d;\r\n      }\r\n      else {\r\n        // corner case\r\n        var dx = closeX - point.x;\r\n        var dy = closeY - point.y;\r\n        return dx * dx + dy * dy;\r\n      }\r\n    },\r\n\r\n    // distance to the farthest point inside the Bounds2\r\n    maximumDistanceToPointSquared: function( point ) {\r\n      var x = point.x > this.getCenterX() ? this.minX : this.maxX;\r\n      var y = point.y > this.getCenterY() ? this.minY : this.maxY;\r\n      x -= point.x;\r\n      y -= point.y;\r\n      return x * x + y * y;\r\n    },\r\n\r\n    toString: function() {\r\n      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;\r\n    },\r\n\r\n    equalsEpsilon: function( other, epsilon ) {\r\n      epsilon = epsilon || 0;\r\n      var thisFinite = this.isFinite();\r\n      var otherFinite = other.isFinite();\r\n      if ( thisFinite && otherFinite ) {\r\n        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity\r\n        return Math.abs( this.minX - other.minX ) < epsilon &&\r\n               Math.abs( this.minY - other.minY ) < epsilon &&\r\n               Math.abs( this.maxX - other.maxX ) < epsilon &&\r\n               Math.abs( this.maxY - other.maxY ) < epsilon;\r\n      }\r\n      else if ( thisFinite !== otherFinite ) {\r\n        return false; // one is finite, the other is not. definitely not equal\r\n      }\r\n      else if ( this === other ) {\r\n        return true; // exact same instance, must be equal\r\n      }\r\n      else {\r\n        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both\r\n        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&\r\n               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&\r\n               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&\r\n               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );\r\n      }\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutable operations\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // create a copy, or if bounds is passed in, set that bounds to our value\r\n    copy: function( bounds ) {\r\n      if ( bounds ) {\r\n        return bounds.set( this );\r\n      }\r\n      else {\r\n        return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );\r\n      }\r\n    },\r\n\r\n    // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)\r\n    union: function( bounds ) {\r\n      return new Bounds2(\r\n        Math.min( this.minX, bounds.minX ),\r\n        Math.min( this.minY, bounds.minY ),\r\n        Math.max( this.maxX, bounds.maxX ),\r\n        Math.max( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n    intersection: function( bounds ) {\r\n      return new Bounds2(\r\n        Math.max( this.minX, bounds.minX ),\r\n        Math.max( this.minY, bounds.minY ),\r\n        Math.min( this.maxX, bounds.maxX ),\r\n        Math.min( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n    // TODO: difference should be well-defined, but more logic is needed to compute\r\n\r\n    withCoordinates: function( x, y ) {\r\n      return new Bounds2(\r\n        Math.min( this.minX, x ),\r\n        Math.min( this.minY, y ),\r\n        Math.max( this.maxX, x ),\r\n        Math.max( this.maxY, y )\r\n      );\r\n    },\r\n\r\n    // like a union with a point-sized bounding box\r\n    withPoint: function( point ) {\r\n      return this.withCoordinates( point.x, point.y );\r\n    },\r\n\r\n    withMinX: function( minX ) { return new Bounds2( minX, this.minY, this.maxX, this.maxY ); },\r\n    withMinY: function( minY ) { return new Bounds2( this.minX, minY, this.maxX, this.maxY ); },\r\n    withMaxX: function( maxX ) { return new Bounds2( this.minX, this.minY, maxX, this.maxY ); },\r\n    withMaxY: function( maxY ) { return new Bounds2( this.minX, this.minY, this.maxX, maxY ); },\r\n\r\n    // copy rounded to integral values, expanding where necessary\r\n    roundedOut: function() {\r\n      return new Bounds2(\r\n        Math.floor( this.minX ),\r\n        Math.floor( this.minY ),\r\n        Math.ceil( this.maxX ),\r\n        Math.ceil( this.maxY )\r\n      );\r\n    },\r\n\r\n    // copy rounded to integral values, contracting where necessary\r\n    roundedIn: function() {\r\n      return new Bounds2(\r\n        Math.ceil( this.minX ),\r\n        Math.ceil( this.minY ),\r\n        Math.floor( this.maxX ),\r\n        Math.floor( this.maxY )\r\n      );\r\n    },\r\n\r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transformed: function( matrix ) {\r\n      return this.copy().transform( matrix );\r\n    },\r\n\r\n    // returns copy expanded on all sides by length d\r\n    dilated: function( d ) {\r\n      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );\r\n    },\r\n\r\n    // dilates only in the x direction\r\n    dilatedX: function( x ) {\r\n      return new Bounds2( this.minX - x, this.minY, this.maxX + x, this.maxY );\r\n    },\r\n\r\n    // dilates only in the y direction\r\n    dilatedY: function( y ) {\r\n      return new Bounds2( this.minX, this.minY - y, this.maxX, this.maxY + y );\r\n    },\r\n\r\n    // dilate with different amounts in the x and y directions\r\n    dilatedXY: function( x, y ) {\r\n      return new Bounds2( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );\r\n    },\r\n\r\n    // returns copy contracted on all sides by length d, or for x/y independently\r\n    eroded: function( d ) { return this.dilated( -d ); },\r\n    erodedX: function( x ) { return this.dilatedX( -x ); },\r\n    erodedY: function( y ) { return this.dilatedY( -y ); },\r\n    erodedXY: function( x, y ) { return this.dilatedXY( -x, -y ); },\r\n\r\n    shiftedX: function( x ) {\r\n      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );\r\n    },\r\n\r\n    shiftedY: function( y ) {\r\n      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );\r\n    },\r\n\r\n    shifted: function( x, y ) {\r\n      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutable operations\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // mutable core operations (all other mutations should be called through these)\r\n    setMinMax: function( minX, minY, maxX, maxY ) {\r\n      this.minX = minX;\r\n      this.minY = minY;\r\n      this.maxX = maxX;\r\n      this.maxY = maxY;\r\n      return this;\r\n    },\r\n    setMinX: function( minX ) {\r\n      this.minX = minX;\r\n      return this;\r\n    },\r\n    setMinY: function( minY ) {\r\n      this.minY = minY;\r\n      return this;\r\n    },\r\n    setMaxX: function( maxX ) {\r\n      this.maxX = maxX;\r\n      return this;\r\n    },\r\n    setMaxY: function( maxY ) {\r\n      this.maxY = maxY;\r\n      return this;\r\n    },\r\n\r\n    set: function( bounds ) {\r\n      return this.setMinMax( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );\r\n    },\r\n\r\n    // mutable union\r\n    includeBounds: function( bounds ) {\r\n      return this.setMinMax(\r\n        Math.min( this.minX, bounds.minX ),\r\n        Math.min( this.minY, bounds.minY ),\r\n        Math.max( this.maxX, bounds.maxX ),\r\n        Math.max( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n\r\n    // mutable intersection\r\n    constrainBounds: function( bounds ) {\r\n      return this.setMinMax(\r\n        Math.max( this.minX, bounds.minX ),\r\n        Math.max( this.minY, bounds.minY ),\r\n        Math.min( this.maxX, bounds.maxX ),\r\n        Math.min( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n\r\n    addCoordinates: function( x, y ) {\r\n      return this.setMinMax(\r\n        Math.min( this.minX, x ),\r\n        Math.min( this.minY, y ),\r\n        Math.max( this.maxX, x ),\r\n        Math.max( this.maxY, y )\r\n      );\r\n    },\r\n\r\n    addPoint: function( point ) {\r\n      return this.addCoordinates( point.x, point.y );\r\n    },\r\n\r\n    // round to integral values, expanding where necessary\r\n    roundOut: function() {\r\n      return this.setMinMax(\r\n        Math.floor( this.minX ),\r\n        Math.floor( this.minY ),\r\n        Math.ceil( this.maxX ),\r\n        Math.ceil( this.maxY )\r\n      );\r\n    },\r\n\r\n    // round to integral values, contracting where necessary\r\n    roundIn: function() {\r\n      return this.setMinMax(\r\n        Math.ceil( this.minX ),\r\n        Math.ceil( this.minY ),\r\n        Math.floor( this.maxX ),\r\n        Math.floor( this.maxY )\r\n      );\r\n    },\r\n\r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transform: function( matrix ) {\r\n      // if we contain no area, no change is needed\r\n      if ( this.isEmpty() ) {\r\n        return this;\r\n      }\r\n\r\n      // optimization to bail for identity matrices\r\n      if ( matrix.isIdentity() ) {\r\n        return this;\r\n      }\r\n\r\n      var minX = this.minX;\r\n      var minY = this.minY;\r\n      var maxX = this.maxX;\r\n      var maxY = this.maxY;\r\n      this.set( dot.Bounds2.NOTHING );\r\n\r\n      // using mutable vector so we don't create excessive instances of Vector2 during this\r\n      // make sure all 4 corners are inside this transformed bounding box\r\n\r\n      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, minY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, maxY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, minY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, maxY ) ) );\r\n      return this;\r\n    },\r\n\r\n    // expands on all sides by length d\r\n    dilate: function( d ) {\r\n      return this.setMinMax( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );\r\n    },\r\n\r\n    // dilates only in the x direction\r\n    dilateX: function( x ) {\r\n      return this.setMinMax( this.minX - x, this.minY, this.maxX + x, this.maxY );\r\n    },\r\n\r\n    // dilates only in the y direction\r\n    dilateY: function( y ) {\r\n      return this.setMinMax( this.minX, this.minY - y, this.maxX, this.maxY + y );\r\n    },\r\n\r\n    // dilate with different amounts in the x and y directions\r\n    dilateXY: function( x, y ) {\r\n      return this.setMinMax( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );\r\n    },\r\n\r\n    // contracts on all sides by length d, or for x/y independently\r\n    erode: function( d ) { return this.dilate( -d ); },\r\n    erodeX: function( x ) { return this.dilateX( -x ); },\r\n    erodeY: function( y ) { return this.dilateY( -y ); },\r\n    erodeXY: function( x, y ) { return this.dilateXY( -x, -y ); },\r\n\r\n    shiftX: function( x ) {\r\n      return this.setMinMax( this.minX + x, this.minY, this.maxX + x, this.maxY );\r\n    },\r\n\r\n    shiftY: function( y ) {\r\n      return this.setMinMax( this.minX, this.minY + y, this.maxX, this.maxY + y );\r\n    },\r\n\r\n    shift: function( x, y ) {\r\n      return this.setMinMax( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );\r\n    },\r\n\r\n    /**\r\n     * Find a point in the Bounds2 closest to the specified point.  Used for making sure a dragged object doesn't get outside the visible play area.\r\n     * @param x x point to test\r\n     * @param y y point to test\r\n     * @param {Vector2} result optional Vector2 that can store the return value to avoid allocations\r\n     * @returns {Vector2}\r\n     */\r\n    getClosestPoint: function( x, y, result ) {\r\n      if ( result ) {\r\n        result.setXY( x, y );\r\n      }\r\n      else {\r\n        result = new dot.Vector2( x, y );\r\n      }\r\n      if ( result.x < this.minX ) { result.x = this.minX; }\r\n      if ( result.x > this.maxX ) { result.x = this.maxX; }\r\n      if ( result.y < this.minY ) { result.y = this.minY; }\r\n      if ( result.y > this.maxY ) { result.y = this.maxY; }\r\n      return result;\r\n    }\r\n  };\r\n\r\n  Bounds2.rect = function( x, y, width, height ) {\r\n    return new Bounds2( x, y, x + width, y + height );\r\n  };\r\n\r\n  // a volume-less point bounds, which can be dilated to form a centered bounds\r\n  Bounds2.point = function( x, y ) {\r\n    if ( x instanceof dot.Vector2 ) {\r\n      var p = x;\r\n      return new Bounds2( p.x, p.y, p.x, p.y );\r\n    }\r\n    else {\r\n      return new Bounds2( x, y, x, y );\r\n    }\r\n  };\r\n\r\n  Poolable.mixin( Bounds2, {\r\n    defaultFactory: function() { return Bounds2.NOTHING.copy(); },\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( minX, minY, maxX, maxY ) {\r\n        if ( pool.length ) {\r\n          return pool.pop().setMinMax( minX, minY, maxX, maxY );\r\n        }\r\n        else {\r\n          return new Bounds2( minX, minY, maxX, maxY );\r\n        }\r\n      };\r\n    }\r\n  } );\r\n\r\n  // specific bounds useful for operations\r\n  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );\r\n  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );\r\n\r\n  return Bounds2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A segment represents a specific curve with a start and end.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/segments/Segment',['require','KITE/kite','DOT/Util','DOT/Bounds2'],function( require ) {\r\n  'use strict';\r\n\r\n  var kite = require( 'KITE/kite' );\r\n\r\n  var DotUtil = require( 'DOT/Util' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n\r\n  /*\r\n   * Will contain (for segments):\r\n   * properties (backed by ES5 getters, created usually lazily):\r\n   * start        - start point of this segment\r\n   * end          - end point of this segment\r\n   * startTangent - the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)\r\n   * endTangent   - the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)\r\n   * bounds       - the bounding box for the segment\r\n   *\r\n   * methods:\r\n   * positionAt( t )          - returns the position parametrically, with 0 <= t <= 1. this does NOT guarantee a constant magnitude tangent... don't feel like adding elliptical functions yet!\r\n   * tangentAt( t )           - returns the non-normalized tangent (dx/dt, dy/dt) parametrically, with 0 <= t <= 1.\r\n   * curvatureAt( t )         - returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)\r\n   * subdivided( t )          - returns an array with 2 sub-segments, split at the parametric t value.\r\n   * getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first\r\n   * strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side\r\n   * strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side\r\n   * intersectsBounds         - whether this segment intersects the specified bounding box (not just the segment's bounding box, but the actual segment)\r\n   * windingIntersection      - returns the winding number for intersection with a ray\r\n   * getInteriorExtremaTs     - returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments\r\n   *\r\n   * writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point\r\n   * transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix\r\n   */\r\n  kite.Segment = function Segment() {}; // no common construction for now\r\n  var Segment = kite.Segment;\r\n\r\n  var identityFunction = function identityFunction( x ) { return x; };\r\n\r\n  Segment.prototype = {\r\n    constructor: Segment,\r\n\r\n    // TODO: override everywhere so this isn't necessary (it's not particularly efficient!)\r\n    getBoundsWithTransform: function( matrix ) {\r\n      var transformedSegment = this.transformed( matrix );\r\n      return transformedSegment.getBounds();\r\n    },\r\n\r\n    // tList should be a list of sorted t values from 0 <= t <= 1\r\n    subdivisions: function( tList ) {\r\n      // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization\r\n      var right = this;\r\n      var result = [];\r\n      for ( var i = 0; i < tList.length; i++ ) {\r\n        // assume binary subdivision\r\n        var t = tList[ i ];\r\n        var arr = right.subdivided( t );\r\n        assert && assert( arr.length === 2 );\r\n        result.push( arr[ 0 ] );\r\n        right = arr[ 1 ];\r\n\r\n        // scale up the remaining t values\r\n        for ( var j = i + 1; j < tList.length; j++ ) {\r\n          tList[ j ] = DotUtil.linear( t, 1, 0, 1, tList[ j ] );\r\n        }\r\n      }\r\n      result.push( right );\r\n      return result;\r\n    },\r\n\r\n    // return an array of segments from breaking this segment into monotone pieces\r\n    subdividedIntoMonotone: function() {\r\n      return this.subdivisions( this.getInteriorExtremaTs() );\r\n    },\r\n\r\n    /*\r\n     * toPiecewiseLinearSegments( options ), with the following options provided:\r\n     * - minLevels:                       how many levels to force subdivisions\r\n     * - maxLevels:                       prevent subdivision past this level\r\n     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve\r\n     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments\r\n     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied\r\n     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]\r\n     *                                    instead of using our brute-force logic\r\n     */\r\n    toPiecewiseLinearSegments: function( options, minLevels, maxLevels, segments, start, end ) {\r\n      // for the first call, initialize min/max levels from our options\r\n      minLevels = minLevels === undefined ? options.minLevels : minLevels;\r\n      maxLevels = maxLevels === undefined ? options.maxLevels : maxLevels;\r\n      segments = segments || [];\r\n      var pointMap = options.pointMap || identityFunction;\r\n\r\n      // points mapped by the (possibly-nonlinear) pointMap.\r\n      start = start || pointMap( this.start );\r\n      end = end || pointMap( this.end );\r\n      var middle = pointMap( this.positionAt( 0.5 ) );\r\n\r\n      assert && assert( minLevels <= maxLevels );\r\n      assert && assert( options.distanceEpsilon === null || typeof options.distanceEpsilon === 'number' );\r\n      assert && assert( options.curveEpsilon === null || typeof options.curveEpsilon === 'number' );\r\n      assert && assert( !pointMap || typeof pointMap === 'function' );\r\n\r\n      // i.e. we will have finished = maxLevels === 0 || ( minLevels <= 0 && epsilonConstraints ), just didn't want to one-line it\r\n      var finished = maxLevels === 0; // bail out once we reach our maximum number of subdivision levels\r\n      if ( !finished && minLevels <= 0 ) { // force subdivision if minLevels hasn't been reached\r\n        // flatness criterion: A=start, B=end, C=midpoint, d0=distance from AB, d1=||B-A||, subdivide if d0/d1 > sqrt(epsilon)\r\n        finished = ( options.curveEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) / start.distanceSquared( end ) < options.curveEpsilon ) ) &&\r\n                   // deviation criterion\r\n                   ( options.distanceEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) < options.distanceEpsilon ) );\r\n      }\r\n\r\n      if ( finished ) {\r\n        segments.push( new Segment.Line( start, end ) );\r\n      }\r\n      else {\r\n        var subdividedSegments = this.subdivided( 0.5 );\r\n        subdividedSegments[ 0 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, start, middle );\r\n        subdividedSegments[ 1 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, middle, end );\r\n      }\r\n      return segments;\r\n    }\r\n  };\r\n\r\n  // list of { segment: ..., t: ..., closestPoint: ..., distanceSquared: ... } (since there can be duplicates), threshold is used for subdivision,\r\n  // where it will exit if all of the segments are shorter than the threshold\r\n  // TODO: solve segments to determine this analytically!\r\n  Segment.closestToPoint = function( segments, point, threshold ) {\r\n    var thresholdSquared = threshold * threshold;\r\n    var items = [];\r\n    var bestList = [];\r\n    var bestDistanceSquared = Number.POSITIVE_INFINITY;\r\n    var thresholdOk = false;\r\n\r\n    _.each( segments, function( segment ) {\r\n      // if we have an explicit computation for this segment, use it\r\n      if ( segment.explicitClosestToPoint ) {\r\n        var infos = segment.explicitClosestToPoint( point );\r\n        _.each( infos, function( info ) {\r\n          if ( info.distanceSquared < bestDistanceSquared ) {\r\n            bestList = [ info ];\r\n            bestDistanceSquared = info.distanceSquared;\r\n          }\r\n          else if ( info.distanceSquared === bestDistanceSquared ) {\r\n            bestList.push( info );\r\n          }\r\n        } );\r\n      }\r\n      else {\r\n        // otherwise, we will split based on monotonicity, so we can subdivide\r\n        // separate, so we can map the subdivided segments\r\n        var ts = [ 0 ].concat( segment.getInteriorExtremaTs() ).concat( [ 1 ] );\r\n        for ( var i = 0; i < ts.length - 1; i++ ) {\r\n          var ta = ts[ i ];\r\n          var tb = ts[ i + 1 ];\r\n          var pa = segment.positionAt( ta );\r\n          var pb = segment.positionAt( tb );\r\n          var bounds = Bounds2.point( pa ).addPoint( pb );\r\n          var minDistanceSquared = bounds.minimumDistanceToPointSquared( point );\r\n          if ( minDistanceSquared <= bestDistanceSquared ) {\r\n            var maxDistanceSquared = bounds.maximumDistanceToPointSquared( point );\r\n            if ( maxDistanceSquared < bestDistanceSquared ) {\r\n              bestDistanceSquared = maxDistanceSquared;\r\n              bestList = []; // clear it\r\n            }\r\n            items.push( {\r\n              ta: ta,\r\n              tb: tb,\r\n              pa: pa,\r\n              pb: pb,\r\n              segment: segment,\r\n              bounds: bounds,\r\n              min: minDistanceSquared,\r\n              max: maxDistanceSquared\r\n            } );\r\n          }\r\n        }\r\n      }\r\n    } );\r\n\r\n    while ( items.length && !thresholdOk ) {\r\n      var curItems = items;\r\n      items = [];\r\n\r\n      // whether all of the segments processed are shorter than the threshold\r\n      thresholdOk = true;\r\n\r\n      _.each( curItems, function( item ) {\r\n        if ( item.minDistanceSquared > bestDistanceSquared ) {\r\n          return; // drop this item\r\n        }\r\n        if ( thresholdOk && item.pa.distanceSquared( item.pb ) > thresholdSquared ) {\r\n          thresholdOk = false;\r\n        }\r\n        var tmid = ( item.ta + item.tb ) / 2;\r\n        var pmid = item.segment.positionAt( tmid );\r\n        var boundsA = Bounds2.point( item.pa ).addPoint( pmid );\r\n        var boundsB = Bounds2.point( item.pb ).addPoint( pmid );\r\n        var minA = boundsA.minimumDistanceToPointSquared( point );\r\n        var minB = boundsB.minimumDistanceToPointSquared( point );\r\n        if ( minA <= bestDistanceSquared ) {\r\n          var maxA = boundsA.maximumDistanceToPointSquared( point );\r\n          if ( maxA < bestDistanceSquared ) {\r\n            bestDistanceSquared = maxA;\r\n            bestList = []; // clear it\r\n          }\r\n          items.push( {\r\n            ta: item.ta,\r\n            tb: tmid,\r\n            pa: item.pa,\r\n            pb: pmid,\r\n            segment: item.segment,\r\n            bounds: boundsA,\r\n            min: minA,\r\n            max: maxA\r\n          } );\r\n        }\r\n        if ( minB <= bestDistanceSquared ) {\r\n          var maxB = boundsB.maximumDistanceToPointSquared( point );\r\n          if ( maxB < bestDistanceSquared ) {\r\n            bestDistanceSquared = maxB;\r\n            bestList = []; // clear it\r\n          }\r\n          items.push( {\r\n            ta: tmid,\r\n            tb: item.tb,\r\n            pa: pmid,\r\n            pb: item.pb,\r\n            segment: item.segment,\r\n            bounds: boundsB,\r\n            min: minB,\r\n            max: maxB\r\n          } );\r\n        }\r\n      } );\r\n    }\r\n\r\n    // if there are any closest regions, they are within the threshold, so we will add them all\r\n    _.each( items, function( item ) {\r\n      var t = ( item.ta + item.tb ) / 2;\r\n      var closestPoint = item.segment.positionAt( t );\r\n      bestList.push( {\r\n        segment: item.segment,\r\n        t: t,\r\n        closestPoint: closestPoint,\r\n        distanceSquared: point.distanceSquared( closestPoint )\r\n      } );\r\n    } );\r\n\r\n    return bestList;\r\n  };\r\n\r\n  return Segment;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * 2-dimensional ray\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Ray2',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  dot.Ray2 = function Ray2( pos, dir ) {\r\n    this.pos = pos;\r\n    this.dir = dir;\r\n\r\n    assert && assert( Math.abs( dir.magnitude() - 1 ) < 0.01 );\r\n\r\n    phetAllocation && phetAllocation( 'Ray2' );\r\n  };\r\n  var Ray2 = dot.Ray2;\r\n\r\n  Ray2.prototype = {\r\n    constructor: Ray2,\r\n\r\n    shifted: function( distance ) {\r\n      return new Ray2( this.pointAtDistance( distance ), this.dir );\r\n    },\r\n\r\n    pointAtDistance: function( distance ) {\r\n      return this.pos.plus( this.dir.timesScalar( distance ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return this.pos.toString() + \" => \" + this.dir.toString();\r\n    }\r\n  };\r\n\r\n  return Ray2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Linear segment\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/segments/Line',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Util = require( 'DOT/Util' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  var scratchVector2 = new Vector2();\r\n\r\n  Segment.Line = function Line( start, end ) {\r\n    this._start = start;\r\n    this._end = end;\r\n\r\n    // TODO: performance test removal of these undefined declarations\r\n    this._tangent = undefined;\r\n    this._bounds = undefined;\r\n  };\r\n  inherit( Segment, Segment.Line, {\r\n\r\n    getStart: function() {\r\n      return this._start;\r\n    },\r\n    get start() { return this._start; },\r\n\r\n    getEnd: function() {\r\n      return this._end;\r\n    },\r\n    get end() { return this._end; },\r\n\r\n    getStartTangent: function() {\r\n      if ( this._tangent === undefined ) {\r\n        // TODO: allocation reduction\r\n        this._tangent = this._end.minus( this._start ).normalized();\r\n      }\r\n      return this._tangent;\r\n    },\r\n    get startTangent() { return this.getStartTangent(); },\r\n\r\n    getEndTangent: function() {\r\n      return this.getStartTangent();\r\n    },\r\n    get endTangent() { return this.getEndTangent(); },\r\n\r\n    getBounds: function() {\r\n      // TODO: allocation reduction\r\n      if ( this._bounds === undefined ) {\r\n        this._bounds = Bounds2.NOTHING.copy().addPoint( this._start ).addPoint( this._end );\r\n      }\r\n      return this._bounds;\r\n    },\r\n    get bounds() { return this.getBounds(); },\r\n\r\n    getBoundsWithTransform: function( matrix ) {\r\n      // uses mutable calls\r\n      var bounds = Bounds2.NOTHING.copy();\r\n      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._start ) ) );\r\n      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._end ) ) );\r\n      return bounds;\r\n    },\r\n\r\n    getNondegenerateSegments: function() {\r\n      // if it is degenerate (0-length), just ignore it\r\n      if ( this._start.equals( this._end ) ) {\r\n        return [];\r\n      }\r\n      else {\r\n        return [ this ];\r\n      }\r\n    },\r\n\r\n    positionAt: function( t ) {\r\n      return this._start.plus( this._end.minus( this._start ).times( t ) );\r\n    },\r\n\r\n    tangentAt: function( t ) {\r\n      // tangent always the same, just use the start tanget\r\n      return this.getStartTangent();\r\n    },\r\n\r\n    curvatureAt: function( t ) {\r\n      return 0; // no curvature on a straight line segment\r\n    },\r\n\r\n    getSVGPathFragment: function() {\r\n      return 'L ' + kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );\r\n    },\r\n\r\n    strokeLeft: function( lineWidth ) {\r\n      var offset = this.getEndTangent().perpendicular().negated().times( lineWidth / 2 );\r\n      return [ new Segment.Line( this._start.plus( offset ), this._end.plus( offset ) ) ];\r\n    },\r\n\r\n    strokeRight: function( lineWidth ) {\r\n      var offset = this.getStartTangent().perpendicular().times( lineWidth / 2 );\r\n      return [ new Segment.Line( this._end.plus( offset ), this._start.plus( offset ) ) ];\r\n    },\r\n\r\n    // lines are already monotone\r\n    getInteriorExtremaTs: function() { return []; },\r\n\r\n    subdivided: function( t ) {\r\n      var pt = this.positionAt( t );\r\n      return [\r\n        new Segment.Line( this._start, pt ),\r\n        new Segment.Line( pt, this._end )\r\n      ];\r\n    },\r\n\r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Line.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n\r\n    intersection: function( ray ) {\r\n      // We solve for the parametric line-line intersection, and then ensure the parameters are within both\r\n      // the line segment and forwards from the ray.\r\n\r\n      var result = [];\r\n\r\n      var start = this._start;\r\n      var end = this._end;\r\n\r\n      var diff = end.minus( start );\r\n\r\n      if ( diff.magnitudeSquared() === 0 ) {\r\n        return result;\r\n      }\r\n\r\n      var denom = ray.dir.y * diff.x - ray.dir.x * diff.y;\r\n\r\n      // If denominator is 0, the lines are parallel or coincident\r\n      if ( denom === 0 ) {\r\n        return result;\r\n      }\r\n\r\n      // linear parameter where start (0) to end (1)\r\n      var t = ( ray.dir.x * ( start.y - ray.pos.y ) - ray.dir.y * ( start.x - ray.pos.x ) ) / denom;\r\n\r\n      // check that the intersection point is between the line segment's endpoints\r\n      if ( t < 0 || t >= 1 ) {\r\n        return result;\r\n      }\r\n\r\n      // linear parameter where ray.pos (0) to ray.pos+ray.dir (1)\r\n      var s = ( diff.x * ( start.y - ray.pos.y ) - diff.y * ( start.x - ray.pos.x ) ) / denom;\r\n\r\n      // bail if it is behind our ray\r\n      if ( s < 0.000001 ) {\r\n        return result;\r\n      }\r\n\r\n      // return the proper winding direction depending on what way our line intersection is \"pointed\"\r\n      var perp = diff.perpendicular();\r\n      result.push( {\r\n        distance: s,\r\n        point: start.plus( diff.times( t ) ),\r\n        normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n        wind: ray.dir.perpendicular().dot( diff ) < 0 ? 1 : -1,\r\n        segment: this\r\n      } );\r\n      return result;\r\n    },\r\n\r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      var hits = this.intersection( ray );\r\n      if ( hits.length ) {\r\n        return hits[ 0 ].wind;\r\n      }\r\n      else {\r\n        return 0;\r\n      }\r\n    },\r\n\r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.lineTo( this._end.x, this._end.y );\r\n    },\r\n\r\n    transformed: function( matrix ) {\r\n      return new Segment.Line( matrix.timesVector2( this._start ), matrix.timesVector2( this._end ) );\r\n    },\r\n\r\n    explicitClosestToPoint: function( point ) {\r\n      var diff = this._end.minus( this._start );\r\n      var t = point.minus( this._start ).dot( diff ) / diff.magnitudeSquared();\r\n      t = Util.clamp( t, 0, 1 );\r\n      var closestPoint = this.positionAt( t );\r\n      return [\r\n        {\r\n          segment: this,\r\n          t: t,\r\n          closestPoint: closestPoint,\r\n          distanceSquared: point.distanceSquared( closestPoint )\r\n        }\r\n      ];\r\n    },\r\n\r\n    // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b\r\n    reparameterized: function( a, b ) {\r\n      return new Segment.Line( this.positionAt( b ), this.positionAt( a + b ) );\r\n    },\r\n\r\n    polarToCartesian: function( options ) {\r\n      if ( this._start.x === this._end.x ) {\r\n        // angle is the same, we are still a line segment!\r\n        return [ new Segment.Line( Vector2.createPolar( this._start.y, this._start.x ), Vector2.createPolar( this._end.y, this._end.x ) ) ];\r\n      }\r\n      else if ( this._start.y === this._end.y ) {\r\n        // we have a constant radius, so we are a circular arc\r\n        return [ new Segment.Arc( Vector2.ZERO, this._start.y, this._start.x, this._end.x, this._start.x > this._end.x ) ];\r\n      }\r\n      else {\r\n        return this.toPiecewiseLinearSegments( options );\r\n      }\r\n    }\r\n  } );\r\n\r\n  return Segment.Line;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Arc segment\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/segments/Arc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var DotUtil = require( 'DOT/Util' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Arc = function Arc( center, radius, startAngle, endAngle, anticlockwise ) {\r\n    if ( radius < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radius = -radius;\r\n      startAngle += Math.PI;\r\n      endAngle += Math.PI;\r\n    }\r\n\r\n    this._center = center;\r\n    this._radius = radius;\r\n    this._startAngle = startAngle;\r\n    this._endAngle = endAngle;\r\n    this._anticlockwise = anticlockwise;\r\n\r\n    // TODO: performance test removal of these undefined declarations\r\n    this._start = undefined;\r\n    this._end = undefined;\r\n    this._startTangent = undefined;\r\n    this._endTangent = undefined;\r\n    this._actualEndAngle = undefined;\r\n    this._isFullPerimeter = undefined;\r\n    this._angleDifference = undefined;\r\n\r\n    // constraints\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );\r\n  };\r\n  inherit( Segment, Segment.Arc, {\r\n\r\n    getCenter: function() {\r\n      return this._center;\r\n    },\r\n    get center() { return this.getCenter(); },\r\n\r\n    getRadius: function() {\r\n      return this._radius;\r\n    },\r\n    get radius() { return this.getRadius(); },\r\n\r\n    getStartAngle: function() {\r\n      return this._startAngle;\r\n    },\r\n    get startAngle() { return this.getStartAngle(); },\r\n\r\n    getEndAngle: function() {\r\n      return this._endAngle;\r\n    },\r\n    get endAngle() { return this.getEndAngle(); },\r\n\r\n    getAnticlockwise: function() {\r\n      return this._anticlockwise;\r\n    },\r\n    get anticlockwise() { return this.getAnticlockwise(); },\r\n\r\n    getStart: function() {\r\n      if ( this._start === undefined ) {\r\n        this._start = this.positionAtAngle( this._startAngle );\r\n      }\r\n      return this._start;\r\n    },\r\n    get start() { return this.getStart(); },\r\n\r\n    getEnd: function() {\r\n      if ( this._end === undefined ) {\r\n        this._end = this.positionAtAngle( this._endAngle );\r\n      }\r\n      return this._end;\r\n    },\r\n    get end() { return this.getEnd(); },\r\n\r\n    getStartTangent: function() {\r\n      if ( this._startTangent === undefined ) {\r\n        this._startTangent = this.tangentAtAngle( this._startAngle );\r\n      }\r\n      return this._startTangent;\r\n    },\r\n    get startTangent() { return this.getStartTangent(); },\r\n\r\n    getEndTangent: function() {\r\n      if ( this._endTangent === undefined ) {\r\n        this._endTangent = this.tangentAtAngle( this._endAngle );\r\n      }\r\n      return this._endTangent;\r\n    },\r\n    get endTangent() { return this.getEndTangent(); },\r\n\r\n    getActualEndAngle: function() {\r\n      if ( this._actualEndAngle === undefined ) {\r\n        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle\r\n        if ( this._anticlockwise ) {\r\n          // angle is 'decreasing'\r\n          // -2pi <= end - start < 2pi\r\n          if ( this._startAngle > this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle;\r\n          }\r\n          else if ( this._startAngle < this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle - 2 * Math.PI;\r\n          }\r\n          else {\r\n            // equal\r\n            this._actualEndAngle = this._startAngle;\r\n          }\r\n        }\r\n        else {\r\n          // angle is 'increasing'\r\n          // -2pi < end - start <= 2pi\r\n          if ( this._startAngle < this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle;\r\n          }\r\n          else if ( this._startAngle > this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle + Math.PI * 2;\r\n          }\r\n          else {\r\n            // equal\r\n            this._actualEndAngle = this._startAngle;\r\n          }\r\n        }\r\n      }\r\n      return this._actualEndAngle;\r\n    },\r\n    get actualEndAngle() { return this.getActualEndAngle(); },\r\n\r\n    getIsFullPerimeter: function() {\r\n      if ( this._isFullPerimeter === undefined ) {\r\n        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );\r\n      }\r\n      return this._isFullPerimeter;\r\n    },\r\n    get isFullPerimeter() { return this.getIsFullPerimeter(); },\r\n\r\n    getAngleDifference: function() {\r\n      if ( this._angleDifference === undefined ) {\r\n        // compute an angle difference that represents how \"much\" of the circle our arc covers\r\n        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;\r\n        if ( this._angleDifference < 0 ) {\r\n          this._angleDifference += Math.PI * 2;\r\n        }\r\n        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive\r\n      }\r\n      return this._angleDifference;\r\n    },\r\n    get angleDifference() { return this.getAngleDifference(); },\r\n\r\n    getBounds: function() {\r\n      if ( this._bounds === undefined ) {\r\n        // acceleration for intersection\r\n        this._bounds = Bounds2.NOTHING.copy().withPoint( this.getStart() )\r\n          .withPoint( this.getEnd() );\r\n\r\n        // if the angles are different, check extrema points\r\n        if ( this._startAngle !== this._endAngle ) {\r\n          // check all of the extrema points\r\n          this.includeBoundsAtAngle( 0 );\r\n          this.includeBoundsAtAngle( Math.PI / 2 );\r\n          this.includeBoundsAtAngle( Math.PI );\r\n          this.includeBoundsAtAngle( 3 * Math.PI / 2 );\r\n        }\r\n      }\r\n      return this._bounds;\r\n    },\r\n    get bounds() { return this.getBounds(); },\r\n\r\n    getNondegenerateSegments: function() {\r\n      if ( this._radius <= 0 || this._startAngle === this._endAngle ) {\r\n        return [];\r\n      }\r\n      else {\r\n        return [ this ]; // basically, Arcs aren't really degenerate that easily\r\n      }\r\n    },\r\n\r\n    includeBoundsAtAngle: function( angle ) {\r\n      if ( this.containsAngle( angle ) ) {\r\n        // the boundary point is in the arc\r\n        this._bounds = this._bounds.withPoint( this._center.plus( Vector2.createPolar( this._radius, angle ) ) );\r\n      }\r\n    },\r\n\r\n    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.\r\n    mapAngle: function( angle ) {\r\n      // consider an assert that we contain that angle?\r\n      return ( this._startAngle > this.getActualEndAngle() ) ?\r\n             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :\r\n             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );\r\n    },\r\n\r\n    tAtAngle: function( angle ) {\r\n      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );\r\n    },\r\n\r\n    angleAt: function( t ) {\r\n      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;\r\n    },\r\n\r\n    positionAt: function( t ) {\r\n      return this.positionAtAngle( this.angleAt( t ) );\r\n    },\r\n\r\n    tangentAt: function( t ) {\r\n      return this.tangentAtAngle( this.angleAt( t ) );\r\n    },\r\n\r\n    curvatureAt: function( t ) {\r\n      return ( this._anticlockwise ? -1 : 1 ) / this._radius;\r\n    },\r\n\r\n    positionAtAngle: function( angle ) {\r\n      return this._center.plus( Vector2.createPolar( this._radius, angle ) );\r\n    },\r\n\r\n    tangentAtAngle: function( angle ) {\r\n      var normal = Vector2.createPolar( 1, angle );\r\n\r\n      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();\r\n    },\r\n\r\n    // TODO: refactor? shared with Segment.EllipticalArc (use this improved version)\r\n    containsAngle: function( angle ) {\r\n      // transform the angle into the appropriate coordinate form\r\n      // TODO: check anticlockwise version!\r\n      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;\r\n\r\n      // get the angle between 0 and 2pi\r\n      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );\r\n\r\n      return positiveMinAngle <= this.angleDifference;\r\n    },\r\n\r\n    getSVGPathFragment: function() {\r\n      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info\r\n      // rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n\r\n      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'\r\n      var sweepFlag = this._anticlockwise ? '0' : '1';\r\n      var largeArcFlag;\r\n      if ( this.angleDifference < Math.PI * 2 - epsilon ) {\r\n        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';\r\n        return 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' + largeArcFlag +\r\n               ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );\r\n      }\r\n      else {\r\n        // circle (or almost-circle) case needs to be handled differently\r\n        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs\r\n\r\n        // get the angle that is between and opposite of both of the points\r\n        var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?\r\n        var splitPoint = this._center.plus( Vector2.createPolar( this._radius, splitOppositeAngle ) );\r\n\r\n        largeArcFlag = '0'; // since we split it in 2, it's always the small arc\r\n\r\n        var firstArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +\r\n                       largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );\r\n        var secondArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +\r\n                        largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );\r\n\r\n        return firstArc + ' ' + secondArc;\r\n      }\r\n    },\r\n\r\n    strokeLeft: function( lineWidth ) {\r\n      return [ new Segment.Arc( this._center, this._radius + ( this._anticlockwise ? 1 : -1 ) * lineWidth / 2, this._startAngle, this._endAngle, this._anticlockwise ) ];\r\n    },\r\n\r\n    strokeRight: function( lineWidth ) {\r\n      return [ new Segment.Arc( this._center, this._radius + ( this._anticlockwise ? -1 : 1 ) * lineWidth / 2, this._endAngle, this._startAngle, !this._anticlockwise ) ];\r\n    },\r\n\r\n    // not including 0 and 1\r\n    getInteriorExtremaTs: function() {\r\n      var that = this;\r\n      var result = [];\r\n      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {\r\n        if ( that.containsAngle( angle ) ) {\r\n          var t = that.tAtAngle( angle );\r\n          var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n          if ( t > epsilon && t < 1 - epsilon ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort(); // modifies original, which is OK\r\n    },\r\n\r\n    subdivided: function( t ) {\r\n      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles\r\n      var angle0 = this.angleAt( 0 );\r\n      var angleT = this.angleAt( t );\r\n      var angle1 = this.angleAt( 1 );\r\n      return [\r\n        new Segment.Arc( this._center, this._radius, angle0, angleT, this._anticlockwise ),\r\n        new Segment.Arc( this._center, this._radius, angleT, angle1, this._anticlockwise )\r\n      ];\r\n    },\r\n\r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.intersectsBounds unimplemented!' );\r\n    },\r\n\r\n    intersection: function( ray ) {\r\n      var result = []; // hits in order\r\n\r\n      // left here, if in the future we want to better-handle boundary points\r\n      var epsilon = 0;\r\n\r\n      // Run a general circle-intersection routine, then we can test the angles later.\r\n      // Solves for the two solutions t such that ray.pos + ray.dir * t is on the circle.\r\n      // Then we check whether the angle at each possible hit point is in our arc.\r\n      var centerToRay = ray.pos.minus( this._center );\r\n      var tmp = ray.dir.dot( centerToRay );\r\n      var centerToRayDistSq = centerToRay.magnitudeSquared();\r\n      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this._radius * this._radius );\r\n      if ( discriminant < epsilon ) {\r\n        // ray misses circle entirely\r\n        return result;\r\n      }\r\n      var base = ray.dir.dot( this._center ) - ray.dir.dot( ray.pos );\r\n      var sqt = Math.sqrt( discriminant ) / 2;\r\n      var ta = base - sqt;\r\n      var tb = base + sqt;\r\n\r\n      if ( tb < epsilon ) {\r\n        // circle is behind ray\r\n        return result;\r\n      }\r\n\r\n      var pointB = ray.pointAtDistance( tb );\r\n      var normalB = pointB.minus( this._center ).normalized();\r\n\r\n      if ( ta < epsilon ) {\r\n        // we are inside the circle, so only one intersection is possible\r\n        if ( this.containsAngle( normalB.angle() ) ) {\r\n          result.push( {\r\n            distance: tb,\r\n            point: pointB,\r\n            normal: normalB.negated(), // normal is towards the ray\r\n            wind: this._anticlockwise ? -1 : 1 // since we are inside, wind this way\r\n          } );\r\n        }\r\n      }\r\n      else {\r\n        // two possible hits (outside circle)\r\n        var pointA = ray.pointAtDistance( ta );\r\n        var normalA = pointA.minus( this._center ).normalized();\r\n\r\n        if ( this.containsAngle( normalA.angle() ) ) {\r\n          result.push( {\r\n            distance: ta,\r\n            point: pointA,\r\n            normal: normalA,\r\n            wind: this._anticlockwise ? 1 : -1 // hit from outside\r\n          } );\r\n        }\r\n        if ( this.containsAngle( normalB.angle() ) ) {\r\n          result.push( {\r\n            distance: tb,\r\n            point: pointB,\r\n            normal: normalB.negated(),\r\n            wind: this._anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way\r\n          } );\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n\r\n    writeToContext: function( context ) {\r\n      context.arc( this._center.x, this._center.y, this._radius, this._startAngle, this._endAngle, this._anticlockwise );\r\n    },\r\n\r\n    // TODO: test various transform types, especially rotations, scaling, shears, etc.\r\n    transformed: function( matrix ) {\r\n      // so we can handle reflections in the transform, we do the general case handling for start/end angles\r\n      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this._startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();\r\n      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this._endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();\r\n\r\n      // reverse the 'clockwiseness' if our transform includes a reflection\r\n      var anticlockwise = matrix.getDeterminant() >= 0 ? this._anticlockwise : !this._anticlockwise;\r\n\r\n      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {\r\n        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;\r\n      }\r\n\r\n      var scaleVector = matrix.getScaleVector();\r\n      if ( scaleVector.x !== scaleVector.y ) {\r\n        var radiusX = scaleVector.x * this._radius;\r\n        var radiusY = scaleVector.y * this._radius;\r\n        return new Segment.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );\r\n      }\r\n      else {\r\n        var radius = scaleVector.x * this._radius;\r\n        return new Segment.Arc( matrix.timesVector2( this._center ), radius, startAngle, endAngle, anticlockwise );\r\n      }\r\n    }\r\n  } );\r\n\r\n  return Segment.Arc;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.\r\n *\r\n * See http://www.w3.org/TR/2dcontext/#concept-path\r\n * for the path / subpath Canvas concept.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/util/Subpath',['require','DOT/Bounds2','KITE/kite','KITE/segments/Line','KITE/segments/Arc'],function( require ) {\r\n  'use strict';\r\n\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n\r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Arc' );\r\n\r\n  // all arguments optional (they are for the copy() method)\r\n  kite.Subpath = function Subpath( segments, points, closed ) {\r\n    this.segments = segments || [];\r\n\r\n    // recombine points if necessary, based off of start points of segments + the end point of the last segment\r\n    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[ segments.length - 1 ].end ) : [] );\r\n    this.closed = !!closed;\r\n\r\n    // cached stroked shape (so hit testing can be done quickly on stroked shapes)\r\n    this._strokedSubpaths = null;\r\n    this._strokedSubpathsComputed = false;\r\n    this._strokedStyles = null;\r\n\r\n    var bounds = this.bounds = Bounds2.NOTHING.copy();\r\n    _.each( this.segments, function( segment ) {\r\n      bounds.includeBounds( segment.bounds );\r\n    } );\r\n  };\r\n  var Subpath = kite.Subpath;\r\n  Subpath.prototype = {\r\n    copy: function() {\r\n      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );\r\n    },\r\n\r\n    invalidate: function() {\r\n      this._strokedSubpathsComputed = false;\r\n    },\r\n\r\n    addPoint: function( point ) {\r\n      this.points.push( point );\r\n\r\n      return this; // allow chaining\r\n    },\r\n\r\n    addSegmentDirectly: function( segment ) {\r\n      assert && assert( segment.start.isFinite(), 'Segment start is infinite' );\r\n      assert && assert( segment.end.isFinite(), 'Segment end is infinite' );\r\n      assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );\r\n      assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );\r\n      assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );\r\n      this.segments.push( segment );\r\n      this.invalidate();\r\n\r\n      this.bounds.includeBounds( segment.getBounds() );\r\n\r\n      return this; // allow chaining\r\n    },\r\n\r\n    addSegment: function( segment ) {\r\n      var subpath = this;\r\n      _.each( segment.getNondegenerateSegments(), function( segment ) {\r\n        subpath.addSegmentDirectly( segment );\r\n      } );\r\n\r\n      return this; // allow chaining\r\n    },\r\n\r\n    // Adds a line segment from the start to end (if non-zero length) and marks the subpath as closed.\r\n    // NOTE: normally you just want to mark the subpath as closed, and not generate the closing segment this way?\r\n    addClosingSegment: function() {\r\n      if ( this.hasClosingSegment() ) {\r\n        var closingSegment = this.getClosingSegment();\r\n        this.addSegmentDirectly( closingSegment );\r\n        this.addPoint( this.getFirstPoint() );\r\n        this.closed = true;\r\n      }\r\n    },\r\n\r\n    // TODO: consider always adding a closing segment into our segments list for easier processing!! see addClosingSegment()\r\n    close: function() {\r\n      this.closed = true;\r\n    },\r\n\r\n    getLength: function() {\r\n      return this.points.length;\r\n    },\r\n\r\n    getFirstPoint: function() {\r\n      return _.first( this.points );\r\n    },\r\n\r\n    getLastPoint: function() {\r\n      return _.last( this.points );\r\n    },\r\n\r\n    getFirstSegment: function() {\r\n      return _.first( this.segments );\r\n    },\r\n\r\n    getLastSegment: function() {\r\n      return _.last( this.segments );\r\n    },\r\n\r\n    isDrawable: function() {\r\n      return this.segments.length > 0;\r\n    },\r\n\r\n    isClosed: function() {\r\n      return this.closed;\r\n    },\r\n\r\n    hasClosingSegment: function() {\r\n      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );\r\n    },\r\n\r\n    getClosingSegment: function() {\r\n      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );\r\n      return new kite.Segment.Line( this.getLastPoint(), this.getFirstPoint() );\r\n    },\r\n\r\n    writeToContext: function( context ) {\r\n      if ( this.isDrawable() ) {\r\n        var startPoint = this.getFirstSegment().start;\r\n        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start\r\n\r\n        var len = this.segments.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n          this.segments[ i ].writeToContext( context );\r\n        }\r\n\r\n        if ( this.closed ) {\r\n          context.closePath();\r\n        }\r\n      }\r\n    },\r\n\r\n    // see Segment.toPiecewiseLinearSegments for documentation\r\n    toPiecewiseLinear: function( options ) {\r\n      assert && assert( !options.pointMap, 'For use with pointMap, please use nonlinearTransformed' );\r\n      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {\r\n        return segment.toPiecewiseLinearSegments( options );\r\n      } ) ), null, this.closed );\r\n    },\r\n\r\n    transformed: function( matrix ) {\r\n      return new Subpath(\r\n        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),\r\n        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),\r\n        this.closed\r\n      );\r\n    },\r\n\r\n    // see Segment.toPiecewiseLinearSegments for documentation\r\n    nonlinearTransformed: function( options ) {\r\n      // specify an actual closing segment, so it can be mapped properly by any non-linear transforms\r\n      // TODO: always create and add the closing segments when the subpath is closed!!!\r\n      if ( this.closed && this.hasClosingSegment() ) {\r\n        this.addClosingSegment();\r\n      }\r\n\r\n      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {\r\n        // check for this segment's support for the specific transform or discretization being applied\r\n        if ( options.methodName && segment[ options.methodName ] ) {\r\n          return segment[ options.methodName ]( options );\r\n        }\r\n        else {\r\n          return segment.toPiecewiseLinearSegments( options );\r\n        }\r\n      } ) ), null, this.closed );\r\n    },\r\n\r\n    getBoundsWithTransform: function( matrix ) {\r\n      var bounds = Bounds2.NOTHING.copy();\r\n      var numSegments = this.segments.length;\r\n      for ( var i = 0; i < numSegments; i++ ) {\r\n        bounds.includeBounds( this.segments[ i ].getBoundsWithTransform( matrix ) );\r\n      }\r\n      return bounds;\r\n    },\r\n\r\n    // {experimental} returns a subpath\r\n    offset: function( distance ) {\r\n      if ( !this.isDrawable() ) {\r\n        return new Subpath( [], null, this.closed );\r\n      }\r\n      if ( distance === 0 ) {\r\n        return new Subpath( this.segments.slice(), null, this.closed );\r\n      }\r\n\r\n      var i;\r\n\r\n      var regularSegments = this.segments.slice();\r\n      if ( this.closed && this.hasClosingSegment() ) {\r\n        regularSegments.push( this.getClosingSegment() );\r\n      }\r\n      var offsets = [];\r\n\r\n      for ( i = 0; i < regularSegments.length; i++ ) {\r\n        offsets.push( regularSegments[ i ].strokeLeft( 2 * distance ) );\r\n      }\r\n\r\n      var segments = [];\r\n      for ( i = 0; i < regularSegments.length; i++ ) {\r\n        if ( this.closed || i > 0 ) {\r\n          var previousI = ( i > 0 ? i : regularSegments.length ) - 1;\r\n          var center = regularSegments[ i ].start;\r\n          var fromTangent = regularSegments[ previousI ].endTangent;\r\n          var toTangent = regularSegments[ i ].startTangent;\r\n\r\n          var startAngle = fromTangent.perpendicular().negated().times( distance ).angle();\r\n          var endAngle = toTangent.perpendicular().negated().times( distance ).angle();\r\n          var anticlockwise = fromTangent.perpendicular().dot( toTangent ) > 0;\r\n          segments.push( new kite.Segment.Arc( center, Math.abs( distance ), startAngle, endAngle, anticlockwise ) );\r\n        }\r\n        segments = segments.concat( offsets[ i ] );\r\n      }\r\n\r\n      return new Subpath( segments, null, this.closed );\r\n    },\r\n\r\n    // returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.\r\n    stroked: function( lineStyles ) {\r\n      // non-drawable subpaths convert to empty subpaths\r\n      if ( !this.isDrawable() ) {\r\n        return [];\r\n      }\r\n\r\n      if ( lineStyles === undefined ) {\r\n        lineStyles = new kite.LineStyles();\r\n      }\r\n\r\n      // return a cached version if possible\r\n      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {\r\n        return this._strokedSubpaths;\r\n      }\r\n\r\n      var lineWidth = lineStyles.lineWidth;\r\n\r\n      var i;\r\n      var leftSegments = [];\r\n      var rightSegments = [];\r\n      var firstSegment = this.getFirstSegment();\r\n      var lastSegment = this.getLastSegment();\r\n\r\n      function appendLeftSegments( segments ) {\r\n        leftSegments = leftSegments.concat( segments );\r\n      }\r\n\r\n      function appendRightSegments( segments ) {\r\n        rightSegments = rightSegments.concat( segments );\r\n      }\r\n\r\n      // we don't need to insert an implicit closing segment if the start and end points are the same\r\n      var alreadyClosed = lastSegment.end.equals( firstSegment.start );\r\n      // if there is an implicit closing segment\r\n      var closingSegment = alreadyClosed ? null : new kite.Segment.Line( this.segments[ this.segments.length - 1 ].end, this.segments[ 0 ].start );\r\n\r\n      // stroke the logical \"left\" side of our path\r\n      for ( i = 0; i < this.segments.length; i++ ) {\r\n        if ( i > 0 ) {\r\n          appendLeftSegments( lineStyles.leftJoin( this.segments[ i ].start, this.segments[ i - 1 ].endTangent, this.segments[ i ].startTangent ) );\r\n        }\r\n        appendLeftSegments( this.segments[ i ].strokeLeft( lineWidth ) );\r\n      }\r\n\r\n      // stroke the logical \"right\" side of our path\r\n      for ( i = this.segments.length - 1; i >= 0; i-- ) {\r\n        if ( i < this.segments.length - 1 ) {\r\n          appendRightSegments( lineStyles.rightJoin( this.segments[ i ].end, this.segments[ i ].endTangent, this.segments[ i + 1 ].startTangent ) );\r\n        }\r\n        appendRightSegments( this.segments[ i ].strokeRight( lineWidth ) );\r\n      }\r\n\r\n      var subpaths;\r\n      if ( this.closed ) {\r\n        if ( alreadyClosed ) {\r\n          // add the joins between the start and end\r\n          appendLeftSegments( lineStyles.leftJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );\r\n          appendRightSegments( lineStyles.rightJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );\r\n        }\r\n        else {\r\n          // logical \"left\" stroke on the implicit closing segment\r\n          appendLeftSegments( lineStyles.leftJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );\r\n          appendLeftSegments( closingSegment.strokeLeft( lineWidth ) );\r\n          appendLeftSegments( lineStyles.leftJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );\r\n\r\n          // logical \"right\" stroke on the implicit closing segment\r\n          appendRightSegments( lineStyles.rightJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );\r\n          appendRightSegments( closingSegment.strokeRight( lineWidth ) );\r\n          appendRightSegments( lineStyles.rightJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );\r\n        }\r\n        subpaths = [\r\n          new Subpath( leftSegments, null, true ),\r\n          new Subpath( rightSegments, null, true )\r\n        ];\r\n      }\r\n      else {\r\n        subpaths = [\r\n          new Subpath( leftSegments.concat( lineStyles.cap( lastSegment.end, lastSegment.endTangent ) )\r\n              .concat( rightSegments )\r\n              .concat( lineStyles.cap( firstSegment.start, firstSegment.startTangent.negated() ) ),\r\n            null, true )\r\n        ];\r\n      }\r\n\r\n      this._strokedSubpaths = subpaths;\r\n      this._strokedSubpathsComputed = true;\r\n      this._strokedStyles = new kite.LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable\r\n\r\n      return subpaths;\r\n    }\r\n  };\r\n\r\n  return kite.Subpath;\r\n} );\r\n\n","// generated from svgPath.pegjs, with added kite namespace and require.js compatibility\r\n\r\ndefine( 'KITE/parser/svgPath',['require','KITE/kite'],function( require ) {\r\n\r\n  var kite = require( 'KITE/kite' );\r\n\r\n  /*\r\n   * Generated by PEG.js 0.7.0.\r\n   *\r\n   * http://pegjs.majda.cz/\r\n   */\r\n\r\n  function quote( s ) {\r\n    /*\r\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\r\n     * string literal except for the closing quote character, backslash,\r\n     * carriage return, line separator, paragraph separator, and line feed.\r\n     * Any character may appear in the form of an escape sequence.\r\n     *\r\n     * For portability, we also escape escape all control and non-ASCII\r\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\r\n     * because JSHint does not like the first and IE the second.\r\n     */\r\n    return '\"' + s\r\n        .replace( /\\\\/g, '\\\\\\\\' )  // backslash\r\n        .replace( /\"/g, '\\\\\"' )    // closing quote character\r\n        .replace( /\\x08/g, '\\\\b' ) // backspace\r\n        .replace( /\\t/g, '\\\\t' )   // horizontal tab\r\n        .replace( /\\n/g, '\\\\n' )   // line feed\r\n        .replace( /\\f/g, '\\\\f' )   // form feed\r\n        .replace( /\\r/g, '\\\\r' )   // carriage return\r\n        .replace( /[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape )\r\n           + '\"';\r\n  }\r\n\r\n  kite.svgPath = {\r\n    /*\r\n     * Parses the input with a generated parser. If the parsing is successfull,\r\n     * returns a value explicitly or implicitly specified by the grammar from\r\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\r\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\r\n     */\r\n    parse: function( input, startRule ) {\r\n      var parseFunctions = {\r\n        \"svgPath\": parse_svgPath,\r\n        \"movetoDrawtoCommandGroups\": parse_movetoDrawtoCommandGroups,\r\n        \"movetoDrawtoCommandGroup\": parse_movetoDrawtoCommandGroup,\r\n        \"drawtoCommands\": parse_drawtoCommands,\r\n        \"drawtoCommand\": parse_drawtoCommand,\r\n        \"moveto\": parse_moveto,\r\n        \"movetoArgumentSequence\": parse_movetoArgumentSequence,\r\n        \"closepath\": parse_closepath,\r\n        \"lineto\": parse_lineto,\r\n        \"linetoArgumentSequence\": parse_linetoArgumentSequence,\r\n        \"horizontalLineto\": parse_horizontalLineto,\r\n        \"horizontalLinetoArgumentSequence\": parse_horizontalLinetoArgumentSequence,\r\n        \"verticalLineto\": parse_verticalLineto,\r\n        \"verticalLinetoArgumentSequence\": parse_verticalLinetoArgumentSequence,\r\n        \"curveto\": parse_curveto,\r\n        \"curvetoArgumentSequence\": parse_curvetoArgumentSequence,\r\n        \"curvetoArgument\": parse_curvetoArgument,\r\n        \"smoothCurveto\": parse_smoothCurveto,\r\n        \"smoothCurvetoArgumentSequence\": parse_smoothCurvetoArgumentSequence,\r\n        \"smoothCurvetoArgument\": parse_smoothCurvetoArgument,\r\n        \"quadraticBezierCurveto\": parse_quadraticBezierCurveto,\r\n        \"quadraticBezierCurvetoArgumentSequence\": parse_quadraticBezierCurvetoArgumentSequence,\r\n        \"quadraticBezierCurvetoArgument\": parse_quadraticBezierCurvetoArgument,\r\n        \"smoothQuadraticBezierCurveto\": parse_smoothQuadraticBezierCurveto,\r\n        \"smoothQuadraticBezierCurvetoArgumentSequence\": parse_smoothQuadraticBezierCurvetoArgumentSequence,\r\n        \"ellipticalArc\": parse_ellipticalArc,\r\n        \"ellipticalArcArgumentSequence\": parse_ellipticalArcArgumentSequence,\r\n        \"ellipticalArcArgument\": parse_ellipticalArcArgument,\r\n        \"coordinatePair\": parse_coordinatePair,\r\n        \"nonnegativeNumber\": parse_nonnegativeNumber,\r\n        \"number\": parse_number,\r\n        \"flag\": parse_flag,\r\n        \"commaWsp\": parse_commaWsp,\r\n        \"comma\": parse_comma,\r\n        \"floatingPointConstant\": parse_floatingPointConstant,\r\n        \"fractionalConstant\": parse_fractionalConstant,\r\n        \"exponent\": parse_exponent,\r\n        \"sign\": parse_sign,\r\n        \"digitSequence\": parse_digitSequence,\r\n        \"digit\": parse_digit,\r\n        \"wsp\": parse_wsp\r\n      };\r\n\r\n      if ( startRule !== undefined ) {\r\n        if ( parseFunctions[ startRule ] === undefined ) {\r\n          throw new Error( \"Invalid rule name: \" + quote( startRule ) + \".\" );\r\n        }\r\n      }\r\n      else {\r\n        startRule = \"svgPath\";\r\n      }\r\n\r\n      var pos = 0;\r\n      var reportFailures = 0;\r\n      var rightmostFailuresPos = 0;\r\n      var rightmostFailuresExpected = [];\r\n\r\n      function padLeft( input, padding, length ) {\r\n        var result = input;\r\n\r\n        var padLength = length - input.length;\r\n        for ( var i = 0; i < padLength; i++ ) {\r\n          result = padding + result;\r\n        }\r\n\r\n        return result;\r\n      }\r\n\r\n      function escape( ch ) {\r\n        var charCode = ch.charCodeAt( 0 );\r\n        var escapeChar;\r\n        var length;\r\n\r\n        if ( charCode <= 0xFF ) {\r\n          escapeChar = 'x';\r\n          length = 2;\r\n        }\r\n        else {\r\n          escapeChar = 'u';\r\n          length = 4;\r\n        }\r\n\r\n        return '\\\\' + escapeChar + padLeft( charCode.toString( 16 ).toUpperCase(), '0', length );\r\n      }\r\n\r\n      function matchFailed( failure ) {\r\n        if ( pos < rightmostFailuresPos ) {\r\n          return;\r\n        }\r\n\r\n        if ( pos > rightmostFailuresPos ) {\r\n          rightmostFailuresPos = pos;\r\n          rightmostFailuresExpected = [];\r\n        }\r\n\r\n        rightmostFailuresExpected.push( failure );\r\n      }\r\n\r\n      function parse_svgPath() {\r\n        var result0, result1, result2, result3;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = [];\r\n        result1 = parse_wsp();\r\n        while ( result1 !== null ) {\r\n          result0.push( result1 );\r\n          result1 = parse_wsp();\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = parse_movetoDrawtoCommandGroups();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = [];\r\n            result3 = parse_wsp();\r\n            while ( result3 !== null ) {\r\n              result2.push( result3 );\r\n              result3 = parse_wsp();\r\n            }\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, path ) { return path ? path : []; })( pos0, result0[ 1 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_movetoDrawtoCommandGroups() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_movetoDrawtoCommandGroup();\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_movetoDrawtoCommandGroups();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return a.concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_movetoDrawtoCommandGroup();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return a; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_movetoDrawtoCommandGroup() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_moveto();\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_drawtoCommands();\r\n            result2 = result2 !== null ? result2 : \"\";\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, m, c ) { return c.length ? m.concat( c ) : m; })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_drawtoCommands() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_drawtoCommand();\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_drawtoCommands();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, cmd, cmds ) { return cmd.concat( cmds ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_drawtoCommand();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, cmd ) { return cmd; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_drawtoCommand() {\r\n        var result0;\r\n\r\n        result0 = parse_closepath();\r\n        if ( result0 === null ) {\r\n          result0 = parse_lineto();\r\n          if ( result0 === null ) {\r\n            result0 = parse_horizontalLineto();\r\n            if ( result0 === null ) {\r\n              result0 = parse_verticalLineto();\r\n              if ( result0 === null ) {\r\n                result0 = parse_curveto();\r\n                if ( result0 === null ) {\r\n                  result0 = parse_smoothCurveto();\r\n                  if ( result0 === null ) {\r\n                    result0 = parse_quadraticBezierCurveto();\r\n                    if ( result0 === null ) {\r\n                      result0 = parse_smoothQuadraticBezierCurveto();\r\n                      if ( result0 === null ) {\r\n                        result0 = parse_ellipticalArc();\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_moveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 77 ) {\r\n          result0 = \"M\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"M\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_movetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) { return createMoveTo( args, false ); })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 109 ) {\r\n            result0 = \"m\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"m\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_movetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) { return createMoveTo( args, true ); })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_movetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, pair, list ) { return [ pair ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, pair ) { return [ pair ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_closepath() {\r\n        var result0;\r\n        var pos0;\r\n\r\n        pos0 = pos;\r\n        if ( input.charCodeAt( pos ) === 90 ) {\r\n          result0 = \"Z\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"Z\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 === null ) {\r\n          if ( input.charCodeAt( pos ) === 122 ) {\r\n            result0 = \"z\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"z\\\"\" );\r\n            }\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, command ) { return { cmd: 'close' }; })( pos0, result0 );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_lineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 76 ) {\r\n          result0 = \"L\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"L\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'lineTo',\r\n                args: [ arg.x, arg.y ]\r\n              };\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 108 ) {\r\n            result0 = \"l\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"l\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_linetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'lineToRelative',\r\n                  args: [ arg.x, arg.y ]\r\n                };\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_linetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_horizontalLineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 72 ) {\r\n          result0 = \"H\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"H\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_horizontalLinetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'horizontalLineTo',\r\n                args: [ arg ]\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 104 ) {\r\n            result0 = \"h\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"h\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_horizontalLinetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'horizontalLineToRelative',\r\n                  args: [ arg ]\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_horizontalLinetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_horizontalLinetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_number();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_verticalLineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 86 ) {\r\n          result0 = \"V\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"V\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_verticalLinetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'verticalLineTo',\r\n                args: [ arg ]\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 118 ) {\r\n            result0 = \"v\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"v\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_verticalLinetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'verticalLineToRelative',\r\n                  args: [ arg ]\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_verticalLinetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_verticalLinetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_number();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_curveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 67 ) {\r\n          result0 = \"C\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"C\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_curvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'cubicCurveTo',\r\n                args: arg\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 99 ) {\r\n            result0 = \"c\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"c\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_curvetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'cubicCurveToRelative',\r\n                  args: arg\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_curvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_curvetoArgument();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_curvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_curvetoArgument();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_curvetoArgument() {\r\n        var result0, result1, result2, result3, result4;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_coordinatePair();\r\n            if ( result2 !== null ) {\r\n              result3 = parse_commaWsp();\r\n              result3 = result3 !== null ? result3 : \"\";\r\n              if ( result3 !== null ) {\r\n                result4 = parse_coordinatePair();\r\n                if ( result4 !== null ) {\r\n                  result0 = [ result0, result1, result2, result3, result4 ];\r\n                }\r\n                else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b, c ) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_smoothCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 83 ) {\r\n          result0 = \"S\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"S\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_smoothCurvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'smoothCubicCurveTo',\r\n                args: arg\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 115 ) {\r\n            result0 = \"s\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"s\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_smoothCurvetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'smoothCubicCurveToRelative',\r\n                  args: arg\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_smoothCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_smoothCurvetoArgument();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_smoothCurvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_smoothCurvetoArgument();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_smoothCurvetoArgument() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_coordinatePair();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_quadraticBezierCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 81 ) {\r\n          result0 = \"Q\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"Q\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'quadraticCurveTo',\r\n                args: arg\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 113 ) {\r\n            result0 = \"q\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"q\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'quadraticCurveToRelative',\r\n                  args: arg\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_quadraticBezierCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_quadraticBezierCurvetoArgument();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_quadraticBezierCurvetoArgument();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_quadraticBezierCurvetoArgument() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_coordinatePair();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_smoothQuadraticBezierCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 84 ) {\r\n          result0 = \"T\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"T\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'smoothQuadraticCurveTo',\r\n                args: [ arg.x, arg.y ]\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 116 ) {\r\n            result0 = \"t\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"t\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'smoothQuadraticCurveToRelative',\r\n                  args: [ arg.x, arg.y ]\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_ellipticalArc() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 65 ) {\r\n          result0 = \"A\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"A\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while ( result2 !== null ) {\r\n            result1.push( result2 );\r\n            result2 = parse_wsp();\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_ellipticalArcArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, args ) {\r\n            return args.map( function( arg ) {\r\n              return {\r\n                cmd: 'ellipticalArcTo',\r\n                args: arg\r\n              }\r\n            } );\r\n          })( pos0, result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if ( input.charCodeAt( pos ) === 97 ) {\r\n            result0 = \"a\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"a\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result2 = parse_ellipticalArcArgumentSequence();\r\n              if ( result2 !== null ) {\r\n                result0 = [ result0, result1, result2 ];\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, args ) {\r\n              return args.map( function( arg ) {\r\n                return {\r\n                  cmd: 'ellipticalArcToRelative',\r\n                  args: arg\r\n                }\r\n              } );\r\n            })( pos0, result0[ 2 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_ellipticalArcArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_ellipticalArcArgument();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_ellipticalArcArgumentSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_ellipticalArcArgument();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_ellipticalArcArgument() {\r\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_nonnegativeNumber();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_nonnegativeNumber();\r\n            if ( result2 !== null ) {\r\n              result3 = parse_commaWsp();\r\n              result3 = result3 !== null ? result3 : \"\";\r\n              if ( result3 !== null ) {\r\n                result4 = parse_number();\r\n                if ( result4 !== null ) {\r\n                  result5 = parse_commaWsp();\r\n                  if ( result5 !== null ) {\r\n                    result6 = parse_flag();\r\n                    if ( result6 !== null ) {\r\n                      result7 = parse_commaWsp();\r\n                      result7 = result7 !== null ? result7 : \"\";\r\n                      if ( result7 !== null ) {\r\n                        result8 = parse_flag();\r\n                        if ( result8 !== null ) {\r\n                          result9 = parse_commaWsp();\r\n                          result9 = result9 !== null ? result9 : \"\";\r\n                          if ( result9 !== null ) {\r\n                            result10 = parse_coordinatePair();\r\n                            if ( result10 !== null ) {\r\n                              result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10 ];\r\n                            }\r\n                            else {\r\n                              result0 = null;\r\n                              pos = pos1;\r\n                            }\r\n                          }\r\n                          else {\r\n                            result0 = null;\r\n                            pos = pos1;\r\n                          }\r\n                        }\r\n                        else {\r\n                          result0 = null;\r\n                          pos = pos1;\r\n                        }\r\n                      }\r\n                      else {\r\n                        result0 = null;\r\n                        pos = pos1;\r\n                      }\r\n                    }\r\n                    else {\r\n                      result0 = null;\r\n                      pos = pos1;\r\n                    }\r\n                  }\r\n                  else {\r\n                    result0 = null;\r\n                    pos = pos1;\r\n                  }\r\n                }\r\n                else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              }\r\n              else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, rx, ry, rot, largeArc, sweep, to ) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ], result0[ 6 ], result0[ 8 ], result0[ 10 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_coordinatePair() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_number();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return { x: a, y: b }; })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_nonnegativeNumber() {\r\n        var result0;\r\n        var pos0;\r\n\r\n        pos0 = pos;\r\n        result0 = parse_floatingPointConstant();\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, number ) { return parseFloat( number, 10 ); })( pos0, result0 );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_digitSequence();\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, number ) { return parseInt( number, 10 ); })( pos0, result0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_number() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_sign();\r\n        result0 = result0 !== null ? result0 : \"\";\r\n        if ( result0 !== null ) {\r\n          result1 = parse_floatingPointConstant();\r\n          if ( result1 !== null ) {\r\n            result0 = [ result0, result1 ];\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, sign, number ) { return parseFloat( sign + number, 10 ); })( pos0, result0[ 0 ], result0[ 1 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_sign();\r\n          result0 = result0 !== null ? result0 : \"\";\r\n          if ( result0 !== null ) {\r\n            result1 = parse_digitSequence();\r\n            if ( result1 !== null ) {\r\n              result0 = [ result0, result1 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, sign, number ) { return parseInt( sign + number, 10 ); })( pos0, result0[ 0 ], result0[ 1 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_flag() {\r\n        var result0;\r\n        var pos0;\r\n\r\n        pos0 = pos;\r\n        if ( input.charCodeAt( pos ) === 48 ) {\r\n          result0 = \"0\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"0\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset ) { return false; })( pos0 );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          if ( input.charCodeAt( pos ) === 49 ) {\r\n            result0 = \"1\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"1\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset ) { return true; })( pos0 );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_commaWsp() {\r\n        var result0, result1, result2, result3;\r\n        var pos0;\r\n\r\n        pos0 = pos;\r\n        result1 = parse_wsp();\r\n        if ( result1 !== null ) {\r\n          result0 = [];\r\n          while ( result1 !== null ) {\r\n            result0.push( result1 );\r\n            result1 = parse_wsp();\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = parse_comma();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = [];\r\n            result3 = parse_wsp();\r\n            while ( result3 !== null ) {\r\n              result2.push( result3 );\r\n              result3 = parse_wsp();\r\n            }\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos0;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos0;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          result0 = parse_comma();\r\n          if ( result0 !== null ) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while ( result2 !== null ) {\r\n              result1.push( result2 );\r\n              result2 = parse_wsp();\r\n            }\r\n            if ( result1 !== null ) {\r\n              result0 = [ result0, result1 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos0;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_comma() {\r\n        var result0;\r\n\r\n        if ( input.charCodeAt( pos ) === 44 ) {\r\n          result0 = \",\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\",\\\"\" );\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_floatingPointConstant() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_fractionalConstant();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_exponent();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result0 = [ result0, result1 ];\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_digitSequence();\r\n          if ( result0 !== null ) {\r\n            result1 = parse_exponent();\r\n            if ( result1 !== null ) {\r\n              result0 = [ result0, result1 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_fractionalConstant() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_digitSequence();\r\n        result0 = result0 !== null ? result0 : \"\";\r\n        if ( result0 !== null ) {\r\n          if ( input.charCodeAt( pos ) === 46 ) {\r\n            result1 = \".\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result1 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\".\\\"\" );\r\n            }\r\n          }\r\n          if ( result1 !== null ) {\r\n            result2 = parse_digitSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return a + '.' + b; })( pos0, result0[ 0 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_digitSequence();\r\n          if ( result0 !== null ) {\r\n            if ( input.charCodeAt( pos ) === 46 ) {\r\n              result1 = \".\";\r\n              pos++;\r\n            }\r\n            else {\r\n              result1 = null;\r\n              if ( reportFailures === 0 ) {\r\n                matchFailed( \"\\\".\\\"\" );\r\n              }\r\n            }\r\n            if ( result1 !== null ) {\r\n              result0 = [ result0, result1 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if ( result0 !== null ) {\r\n            result0 = (function( offset, a ) { return a })( pos0, result0[ 0 ] );\r\n          }\r\n          if ( result0 === null ) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_exponent() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if ( input.charCodeAt( pos ) === 101 ) {\r\n          result0 = \"e\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"e\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 === null ) {\r\n          if ( input.charCodeAt( pos ) === 69 ) {\r\n            result0 = \"E\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"E\\\"\" );\r\n            }\r\n          }\r\n        }\r\n        if ( result0 !== null ) {\r\n          result1 = parse_sign();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if ( result1 !== null ) {\r\n            result2 = parse_digitSequence();\r\n            if ( result2 !== null ) {\r\n              result0 = [ result0, result1, result2 ];\r\n            }\r\n            else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b, c ) { return a + b + c; })( pos0, result0[ 0 ], result0[ 1 ], result0[ 2 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_sign() {\r\n        var result0;\r\n\r\n        if ( input.charCodeAt( pos ) === 43 ) {\r\n          result0 = \"+\";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\"+\\\"\" );\r\n          }\r\n        }\r\n        if ( result0 === null ) {\r\n          if ( input.charCodeAt( pos ) === 45 ) {\r\n            result0 = \"-\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"-\\\"\" );\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_digitSequence() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n\r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_digit();\r\n        if ( result0 !== null ) {\r\n          result1 = parse_digitSequence();\r\n          if ( result1 !== null ) {\r\n            result0 = [ result0, result1 ];\r\n          }\r\n          else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        }\r\n        else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if ( result0 !== null ) {\r\n          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );\r\n        }\r\n        if ( result0 === null ) {\r\n          pos = pos0;\r\n        }\r\n        if ( result0 === null ) {\r\n          result0 = parse_digit();\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_digit() {\r\n        var result0;\r\n\r\n        if ( /^[0-9]/.test( input.charAt( pos ) ) ) {\r\n          result0 = input.charAt( pos );\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"[0-9]\" );\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n      function parse_wsp() {\r\n        var result0;\r\n\r\n        if ( input.charCodeAt( pos ) === 32 ) {\r\n          result0 = \" \";\r\n          pos++;\r\n        }\r\n        else {\r\n          result0 = null;\r\n          if ( reportFailures === 0 ) {\r\n            matchFailed( \"\\\" \\\"\" );\r\n          }\r\n        }\r\n        if ( result0 === null ) {\r\n          if ( input.charCodeAt( pos ) === 9 ) {\r\n            result0 = \"\\t\";\r\n            pos++;\r\n          }\r\n          else {\r\n            result0 = null;\r\n            if ( reportFailures === 0 ) {\r\n              matchFailed( \"\\\"\\\\t\\\"\" );\r\n            }\r\n          }\r\n          if ( result0 === null ) {\r\n            if ( input.charCodeAt( pos ) === 13 ) {\r\n              result0 = \"\\r\";\r\n              pos++;\r\n            }\r\n            else {\r\n              result0 = null;\r\n              if ( reportFailures === 0 ) {\r\n                matchFailed( \"\\\"\\\\r\\\"\" );\r\n              }\r\n            }\r\n            if ( result0 === null ) {\r\n              if ( input.charCodeAt( pos ) === 10 ) {\r\n                result0 = \"\\n\";\r\n                pos++;\r\n              }\r\n              else {\r\n                result0 = null;\r\n                if ( reportFailures === 0 ) {\r\n                  matchFailed( \"\\\"\\\\n\\\"\" );\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n\r\n\r\n      function cleanupExpected( expected ) {\r\n        expected.sort();\r\n\r\n        var lastExpected = null;\r\n        var cleanExpected = [];\r\n        for ( var i = 0; i < expected.length; i++ ) {\r\n          if ( expected[ i ] !== lastExpected ) {\r\n            cleanExpected.push( expected[ i ] );\r\n            lastExpected = expected[ i ];\r\n          }\r\n        }\r\n        return cleanExpected;\r\n      }\r\n\r\n      function computeErrorPosition() {\r\n        /*\r\n         * The first idea was to use |String.split| to break the input up to the\r\n         * error position along newlines and derive the line and column from\r\n         * there. However IE's |split| implementation is so broken that it was\r\n         * enough to prevent it.\r\n         */\r\n\r\n        var line = 1;\r\n        var column = 1;\r\n        var seenCR = false;\r\n\r\n        for ( var i = 0; i < Math.max( pos, rightmostFailuresPos ); i++ ) {\r\n          var ch = input.charAt( i );\r\n          if ( ch === \"\\n\" ) {\r\n            if ( !seenCR ) { line++; }\r\n            column = 1;\r\n            seenCR = false;\r\n          }\r\n          else if ( ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\" ) {\r\n            line++;\r\n            column = 1;\r\n            seenCR = true;\r\n          }\r\n          else {\r\n            column++;\r\n            seenCR = false;\r\n          }\r\n        }\r\n\r\n        return { line: line, column: column };\r\n      }\r\n\r\n\r\n      function createMoveTo( args, isRelative ) {\r\n        var result = [\r\n          {\r\n            cmd: isRelative ? 'moveToRelative' : 'moveTo',\r\n            args: [ args[ 0 ].x, args[ 0 ].y ]\r\n          }\r\n        ];\r\n\r\n        // any other coordinate pairs are implicit lineTos\r\n        if ( args.length > 1 ) {\r\n          for ( var i = 1; i < args.length; i++ ) {\r\n            result.push( {\r\n              cmd: isRelative ? 'lineToRelative' : 'lineTo',\r\n              args: [ args[ i ].x, args[ i ].y ]\r\n            } );\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n\r\n\r\n      var result = parseFunctions[ startRule ]();\r\n\r\n      /*\r\n       * The parser is now in one of the following three states:\r\n       *\r\n       * 1. The parser successfully parsed the whole input.\r\n       *\r\n       *    - |result !== null|\r\n       *    - |pos === input.length|\r\n       *    - |rightmostFailuresExpected| may or may not contain something\r\n       *\r\n       * 2. The parser successfully parsed only a part of the input.\r\n       *\r\n       *    - |result !== null|\r\n       *    - |pos < input.length|\r\n       *    - |rightmostFailuresExpected| may or may not contain something\r\n       *\r\n       * 3. The parser did not successfully parse any part of the input.\r\n       *\r\n       *   - |result === null|\r\n       *   - |pos === 0|\r\n       *   - |rightmostFailuresExpected| contains at least one failure\r\n       *\r\n       * All code following this comment (including called functions) must\r\n       * handle these states.\r\n       */\r\n      if ( result === null || pos !== input.length ) {\r\n        var offset = Math.max( pos, rightmostFailuresPos );\r\n        var found = offset < input.length ? input.charAt( offset ) : null;\r\n        var errorPosition = computeErrorPosition();\r\n\r\n        throw new this.SyntaxError(\r\n          cleanupExpected( rightmostFailuresExpected ),\r\n          found,\r\n          offset,\r\n          errorPosition.line,\r\n          errorPosition.column\r\n        );\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /* Returns the parser source code. */\r\n    toSource: function() { return this._source; }\r\n  };\r\n  var result = kite.svgPath;\r\n\r\n  /* Thrown when a parser encounters a syntax error. */\r\n\r\n  result.SyntaxError = function( expected, found, offset, line, column ) {\r\n    function buildMessage( expected, found ) {\r\n      var expectedHumanized, foundHumanized;\r\n\r\n      switch( expected.length ) {\r\n        case 0:\r\n          expectedHumanized = \"end of input\";\r\n          break;\r\n        case 1:\r\n          expectedHumanized = expected[ 0 ];\r\n          break;\r\n        default:\r\n          expectedHumanized = expected.slice( 0, expected.length - 1 ).join( \", \" )\r\n                              + \" or \"\r\n                              + expected[ expected.length - 1 ];\r\n      }\r\n\r\n      foundHumanized = found ? quote( found ) : \"end of input\";\r\n\r\n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\r\n    }\r\n\r\n    this.name = \"SyntaxError\";\r\n    this.expected = expected;\r\n    this.found = found;\r\n    this.message = buildMessage( expected, found );\r\n    this.offset = offset;\r\n    this.line = line;\r\n    this.column = column;\r\n  };\r\n\r\n  result.SyntaxError.prototype = Error.prototype;\r\n\r\n  return result;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Styles needed to determine a stroked line shape.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/util/LineStyles',['require','KITE/kite','DOT/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n\r\n  kite.LineStyles = function( args ) {\r\n    if ( args === undefined ) {\r\n      args = {};\r\n    }\r\n    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;\r\n    this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square\r\n    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel\r\n    this.lineDash = args.lineDash ? args.lineDash : []; // [] is default, otherwise an array of numbers\r\n    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number\r\n    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations\r\n\r\n    assert && assert( Array.isArray( this.lineDash ) );\r\n  };\r\n  var LineStyles = kite.LineStyles;\r\n  LineStyles.prototype = {\r\n    constructor: LineStyles,\r\n\r\n    equals: function( other ) {\r\n      var typical = this.lineWidth === other.lineWidth &&\r\n                    this.lineCap === other.lineCap &&\r\n                    this.lineJoin === other.lineJoin &&\r\n                    this.miterLimit === other.miterLimit &&\r\n                    this.lineDashOffset === other.lineDashOffset;\r\n      if ( !typical ) {\r\n        return false;\r\n      }\r\n\r\n      if ( this.lineDash.length === other.lineDash.length ) {\r\n        for ( var i = 0; i < this.lineDash.length; i++ ) {\r\n          if ( this.lineDash[ i ] !== other.lineDash[ i ] ) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        // line dashes must be different\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    /*\r\n     * Creates an array of Segments that make up a line join, to the left side.\r\n     *\r\n     * Joins two segments together on the logical \"left\" side, at 'center' (where they meet), and normalized tangent\r\n     * vectors in the direction of the stroking. To join on the \"right\" side, switch the tangent order and negate them.\r\n     */\r\n    leftJoin: function( center, fromTangent, toTangent ) {\r\n      // where our join path starts and ends\r\n      var fromPoint = center.plus( fromTangent.perpendicular().negated().times( this.lineWidth / 2 ) );\r\n      var toPoint = center.plus( toTangent.perpendicular().negated().times( this.lineWidth / 2 ) );\r\n\r\n      var bevel = ( fromPoint.equals( toPoint ) ? [] : [ new kite.Segment.Line( fromPoint, toPoint ) ] );\r\n\r\n      // only insert a join on the non-acute-angle side\r\n      if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {\r\n        switch( this.lineJoin ) {\r\n          case 'round':\r\n            var fromAngle = fromTangent.angle() + Math.PI / 2;\r\n            var toAngle = toTangent.angle() + Math.PI / 2;\r\n            return [ new kite.Segment.Arc( center, this.lineWidth / 2, fromAngle, toAngle, true ) ];\r\n          case 'miter':\r\n            var theta = fromTangent.angleBetween( toTangent.negated() );\r\n            if ( 1 / Math.sin( theta / 2 ) <= this.miterLimit && theta < Math.PI - 0.00001 ) {\r\n              // draw the miter\r\n              var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );\r\n              return [\r\n                new kite.Segment.Line( fromPoint, miterPoint ),\r\n                new kite.Segment.Line( miterPoint, toPoint )\r\n              ];\r\n            }\r\n            else {\r\n              // angle too steep, use bevel instead. same as below, but copied for linter\r\n              return bevel;\r\n            }\r\n            break;\r\n          case 'bevel':\r\n            return bevel;\r\n        }\r\n      }\r\n      else {\r\n        // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place\r\n        // TODO: can we prevent self-intersection here?\r\n        return bevel;\r\n      }\r\n    },\r\n\r\n    /*\r\n     * Creates an array of Segments that make up a line join, to the right side.\r\n     *\r\n     * Joins two segments together on the logical \"right\" side, at 'center' (where they meet), and normalized tangent\r\n     * vectors in the direction of the stroking. To join on the \"left\" side, switch the tangent order and negate them.\r\n     */\r\n    rightJoin: function( center, fromTangent, toTangent ) {\r\n      return this.leftJoin( center, toTangent.negated(), fromTangent.negated() );\r\n    },\r\n\r\n    /*\r\n     * Creates an array of Segments that make up a line cap from the endpoint 'center' in the direction of the tangent\r\n     */\r\n    cap: function( center, tangent ) {\r\n      var fromPoint = center.plus( tangent.perpendicular().times( -this.lineWidth / 2 ) );\r\n      var toPoint = center.plus( tangent.perpendicular().times( this.lineWidth / 2 ) );\r\n\r\n      switch( this.lineCap ) {\r\n        case 'butt':\r\n          return [ new kite.Segment.Line( fromPoint, toPoint ) ];\r\n        case 'round':\r\n          var tangentAngle = tangent.angle();\r\n          return [ new kite.Segment.Arc( center, this.lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true ) ];\r\n        case 'square':\r\n          var toLeft = tangent.perpendicular().negated().times( this.lineWidth / 2 );\r\n          var toRight = tangent.perpendicular().times( this.lineWidth / 2 );\r\n          var toFront = tangent.times( this.lineWidth / 2 );\r\n\r\n          var left = center.plus( toLeft ).plus( toFront );\r\n          var right = center.plus( toRight ).plus( toFront );\r\n          return [\r\n            new kite.Segment.Line( fromPoint, left ),\r\n            new kite.Segment.Line( left, right ),\r\n            new kite.Segment.Line( right, toPoint )\r\n          ];\r\n      }\r\n    }\r\n  };\r\n\r\n  return kite.LineStyles;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 4-dimensional vector\r\n *\r\n * TODO: sync with Vector2 changes\r\n * TODO: add quaternion extension\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Vector4',['require','DOT/dot','DOT/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  require( 'DOT/Util' );\r\n  // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.Vector4 = function Vector4( x, y, z, w ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = w !== undefined ? w : 1; // since w could be zero!\r\n  };\r\n  var Vector4 = dot.Vector4;\r\n\r\n  Vector4.prototype = {\r\n    constructor: Vector4,\r\n    isVector4: true,\r\n    dimension: 4,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      this.dot( this );\r\n    },\r\n\r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n\r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;\r\n    },\r\n\r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // create a copy, or if a vector is passed in, set that vector to our value\r\n    copy: function( vector ) {\r\n      if ( vector ) {\r\n        return vector.set( this );\r\n      }\r\n      else {\r\n        return new Vector4( this.x, this.y, this.z, this.w );\r\n      }\r\n    },\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector4( this.x / mag, this.y / mag, this.z / mag, this.w / mag );\r\n      }\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector4( -this.x, -this.y, -this.z, -this.w );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n\r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n\r\n    // average position between this and the provided vector\r\n    average: function( vector ) {\r\n      return this.blend( vector, 0.5 );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Vector4(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\r\n    },\r\n\r\n    toVector3: function() {\r\n      return new dot.Vector3( this.x, this.y, this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // our core mutables (all mutation should go through these)\r\n    setXYZW: function( x, y, z, w ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n      this.w = w;\r\n      return this;\r\n    },\r\n    setX: function( x ) {\r\n      this.x = x;\r\n      return this;\r\n    },\r\n    setY: function( y ) {\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    setZ: function( z ) {\r\n      this.z = z;\r\n      return this;\r\n    },\r\n    setW: function( w ) {\r\n      this.w = w;\r\n      return this;\r\n    },\r\n\r\n    set: function( v ) {\r\n      return this.setXYZW( v.x, v.y, v.z, v.w );\r\n    },\r\n\r\n    add: function( v ) {\r\n      return this.setXYZW( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      return this.setXYZW( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      return this.setXYZW( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      return this.setXYZW( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );\r\n    },\r\n\r\n    multiplyScalar: function( scalar ) {\r\n      return this.setXYZW( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );\r\n    },\r\n\r\n    multiply: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.multiplyScalar( scalar );\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      return this.setXYZW( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      return this.setXYZW( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );\r\n    },\r\n\r\n    negate: function() {\r\n      return this.setXYZW( -this.x, -this.y, -this.z, -this.w );\r\n    },\r\n\r\n    normalize: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return this.divideScalar( mag );\r\n      }\r\n      return this;\r\n    }\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector4.Immutable = function( x, y, z, w ) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = w !== undefined ? w : 1;\r\n  };\r\n  var Immutable = Vector4.Immutable;\r\n\r\n  Immutable.prototype = new Vector4();\r\n  Immutable.prototype.constructor = Immutable;\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[ mutableFunctionName ] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector4\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'setXYZW' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'setZ' );\r\n  Immutable.mutableOverrideHelper( 'setW' );\r\n\r\n  // helpful immutable constants\r\n  Vector4.ZERO = new Immutable( 0, 0, 0, 0 );\r\n  Vector4.X_UNIT = new Immutable( 1, 0, 0, 0 );\r\n  Vector4.Y_UNIT = new Immutable( 0, 1, 0, 0 );\r\n  Vector4.Z_UNIT = new Immutable( 0, 0, 1, 0 );\r\n  Vector4.W_UNIT = new Immutable( 0, 0, 0, 1 );\r\n\r\n  return Vector4;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 3-dimensional vector\r\n *\r\n * TODO: sync with Vector2 changes\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Vector3',['require','DOT/dot','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  require( 'DOT/Util' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector4' );\r\n\r\n  dot.Vector3 = function Vector3( x, y, z ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n  };\r\n  var Vector3 = dot.Vector3;\r\n\r\n  Vector3.prototype = {\r\n    constructor: Vector3,\r\n    isVector3: true,\r\n    dimension: 3,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      return this.dot( this );\r\n    },\r\n\r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return Math.sqrt( this.distanceSquared( point ) );\r\n    },\r\n\r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      var dx = this.x - point.x;\r\n      var dy = this.y - point.y;\r\n      var dz = this.z - point.z;\r\n      return dx * dx + dy * dy + dz * dz;\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y && this.z === other.z;\r\n    },\r\n\r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // create a copy, or if a vector is passed in, set that vector to our value\r\n    copy: function( vector ) {\r\n      if ( vector ) {\r\n        return vector.set( this );\r\n      }\r\n      else {\r\n        return new Vector3( this.x, this.y, this.z );\r\n      }\r\n    },\r\n\r\n    cross: function( v ) {\r\n      return new Vector3(\r\n        this.y * v.z - this.z * v.y,\r\n        this.z * v.x - this.x * v.z,\r\n        this.x * v.y - this.y * v.x\r\n      );\r\n    },\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector3( this.x / mag, this.y / mag, this.z / mag );\r\n      }\r\n    },\r\n\r\n    withMagnitude: function( magnitude ) {\r\n      return this.copy().setMagnitude( magnitude );\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector3( -this.x, -this.y, -this.z );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n\r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n\r\n    // average position between this and the provided vector\r\n    average: function( vector ) {\r\n      return this.blend( vector, 0.5 );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Vector3(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\r\n    },\r\n\r\n    toVector2: function() {\r\n      return new dot.Vector2( this.x, this.y );\r\n    },\r\n\r\n    toVector4: function() {\r\n      return new dot.Vector4( this.x, this.y, this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // our core mutables, all mutation should go through these\r\n    setXYZ: function( x, y, z ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n      return this;\r\n    },\r\n    setX: function( x ) {\r\n      this.x = x;\r\n      return this;\r\n    },\r\n    setY: function( y ) {\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    setZ: function( z ) {\r\n      this.z = z;\r\n      return this;\r\n    },\r\n\r\n    set: function( v ) {\r\n      return this.setXYZ( v.x, v.y, v.z );\r\n    },\r\n\r\n    // sets the magnitude of the vector, keeping the same direction (though a negative magnitude will flip the vector direction)\r\n    setMagnitude: function( m ) {\r\n      var scale = m / this.magnitude();\r\n      return this.multiplyScalar( scale );\r\n    },\r\n\r\n    add: function( v ) {\r\n      return this.setXYZ( this.x + v.x, this.y + v.y, this.z + v.z );\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      return this.setXYZ( this.x + scalar, this.y + scalar, this.z + scalar );\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      return this.setXYZ( this.x - v.x, this.y - v.y, this.z - v.z );\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      return this.setXYZ( this.x - scalar, this.y - scalar, this.z - scalar );\r\n    },\r\n\r\n    multiplyScalar: function( scalar ) {\r\n      return this.setXYZ( this.x * scalar, this.y * scalar, this.z * scalar );\r\n    },\r\n\r\n    multiply: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.multiplyScalar( scalar );\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      return this.setXYZ( this.x * v.x, this.y * v.y, this.z * v.z );\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      return this.setXYZ( this.x / scalar, this.y / scalar, this.z / scalar );\r\n    },\r\n\r\n    negate: function() {\r\n      return this.setXYZ( -this.x, -this.y, -this.z );\r\n    },\r\n\r\n    normalize: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return this.divideScalar( mag );\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Spherical linear interpolation between two unit vectors.\r\n   *\r\n   * @param {Vector3} start - Start unit vector\r\n   * @param {Vector3} end - End unit vector\r\n   * @param {number} ratio  - Between 0 (at start vector) and 1 (at end vector)\r\n   * @return Spherical linear interpolation between the start and end\r\n   */\r\n  Vector3.slerp = function( start, end, ratio ) {\r\n    // NOTE: we can't create a require() loop here\r\n    return dot.Quaternion.slerp( new dot.Quaternion(), dot.Quaternion.getRotationQuaternion( start, end ), ratio ).timesVector3( start );\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector3.Immutable = function( x, y, z ) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n  };\r\n  var Immutable = Vector3.Immutable;\r\n\r\n  Immutable.prototype = new Vector3();\r\n  Immutable.prototype.constructor = Immutable;\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[ mutableFunctionName ] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector3\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'setXYZ' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'setZ' );\r\n\r\n  // helpful immutable constants\r\n  Vector3.ZERO = new Immutable( 0, 0, 0 );\r\n  Vector3.X_UNIT = new Immutable( 1, 0, 0 );\r\n  Vector3.Y_UNIT = new Immutable( 0, 1, 0 );\r\n  Vector3.Z_UNIT = new Immutable( 0, 0, 1 );\r\n\r\n  return Vector3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * 4-dimensional Matrix\r\n *\r\n * TODO: consider adding affine flag if it will help performance (a la Matrix3)\r\n * TODO: get rotation angles\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Vector4' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  dot.Matrix4 = function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {\r\n\r\n    // entries stored in column-major format\r\n    this.entries = new Float32Array( 16 );\r\n\r\n    this.rowMajor(\r\n      v00 === undefined ? 1 : v00, v01 || 0, v02 || 0, v03 || 0,\r\n      v10 || 0, v11 === undefined ? 1 : v11, v12 || 0, v13 || 0,\r\n      v20 || 0, v21 || 0, v22 === undefined ? 1 : v22, v23 || 0,\r\n      v30 || 0, v31 || 0, v32 || 0, v33 === undefined ? 1 : v33,\r\n      type );\r\n  };\r\n  var Matrix4 = dot.Matrix4;\r\n\r\n  Matrix4.Types = {\r\n    OTHER: 0, // default\r\n    IDENTITY: 1,\r\n    TRANSLATION_3D: 2,\r\n    SCALING: 3,\r\n    AFFINE: 4\r\n\r\n    // TODO: possibly add rotations\r\n  };\r\n\r\n  var Types = Matrix4.Types;\r\n\r\n  Matrix4.identity = function() {\r\n    return new Matrix4(\r\n      1, 0, 0, 0,\r\n      0, 1, 0, 0,\r\n      0, 0, 1, 0,\r\n      0, 0, 0, 1,\r\n      Types.IDENTITY );\r\n  };\r\n\r\n  Matrix4.translation = function( x, y, z ) {\r\n    return new Matrix4(\r\n      1, 0, 0, x,\r\n      0, 1, 0, y,\r\n      0, 0, 1, z,\r\n      0, 0, 0, 1,\r\n      Types.TRANSLATION_3D );\r\n  };\r\n\r\n  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };\r\n\r\n  Matrix4.scaling = function( x, y, z ) {\r\n    // allow using one parameter to scale everything\r\n    y = y === undefined ? x : y;\r\n    z = z === undefined ? x : z;\r\n\r\n    return new Matrix4(\r\n      x, 0, 0, 0,\r\n      0, y, 0, 0,\r\n      0, 0, z, 0,\r\n      0, 0, 0, 1,\r\n      Types.SCALING );\r\n  };\r\n\r\n  // axis is a normalized Vector3, angle in radians.\r\n  Matrix4.rotationAxisAngle = function( axis, angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n    var C = 1 - c;\r\n\r\n    return new Matrix4(\r\n      axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,\r\n      axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,\r\n      axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,\r\n      0, 0, 0, 1,\r\n      Types.AFFINE );\r\n  };\r\n\r\n  // TODO: add in rotation from quaternion, and from quat + translation\r\n\r\n  Matrix4.rotationX = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4(\r\n      1, 0, 0, 0,\r\n      0, c, -s, 0,\r\n      0, s, c, 0,\r\n      0, 0, 0, 1,\r\n      Types.AFFINE );\r\n  };\r\n\r\n  Matrix4.rotationY = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4(\r\n      c, 0, s, 0,\r\n      0, 1, 0, 0,\r\n      -s, 0, c, 0,\r\n      0, 0, 0, 1,\r\n      Types.AFFINE );\r\n  };\r\n\r\n  Matrix4.rotationZ = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4(\r\n      c, -s, 0, 0,\r\n      s, c, 0, 0,\r\n      0, 0, 1, 0,\r\n      0, 0, 0, 1,\r\n      Types.AFFINE );\r\n  };\r\n\r\n  // aspect === width / height\r\n  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {\r\n    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );\r\n\r\n    return new Matrix4(\r\n      cotangent / aspect, 0, 0, 0,\r\n      0, cotangent, 0, 0,\r\n      0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),\r\n      0, 0, -1, 0 );\r\n  };\r\n\r\n  Matrix4.prototype = {\r\n    constructor: Matrix4,\r\n\r\n    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {\r\n      this.entries[ 0 ] = v00;\r\n      this.entries[ 1 ] = v10;\r\n      this.entries[ 2 ] = v20;\r\n      this.entries[ 3 ] = v30;\r\n      this.entries[ 4 ] = v01;\r\n      this.entries[ 5 ] = v11;\r\n      this.entries[ 6 ] = v21;\r\n      this.entries[ 7 ] = v31;\r\n      this.entries[ 8 ] = v02;\r\n      this.entries[ 9 ] = v12;\r\n      this.entries[ 10 ] = v22;\r\n      this.entries[ 11 ] = v32;\r\n      this.entries[ 12 ] = v03;\r\n      this.entries[ 13 ] = v13;\r\n      this.entries[ 14 ] = v23;\r\n      this.entries[ 15 ] = v33;\r\n\r\n      // TODO: consider performance of the affine check here\r\n      this.type = type === undefined ? ( ( v30 === 0 && v31 === 0 && v32 === 0 && v33 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;\r\n      return this;\r\n    },\r\n\r\n    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {\r\n      return this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );\r\n    },\r\n\r\n    set: function( matrix ) {\r\n      return this.rowMajor(\r\n        matrix.m00(), matrix.m01(), matrix.m02(), matrix.m03(),\r\n        matrix.m10(), matrix.m11(), matrix.m12(), matrix.m13(),\r\n        matrix.m20(), matrix.m21(), matrix.m22(), matrix.m23(),\r\n        matrix.m30(), matrix.m31(), matrix.m32(), matrix.m33(),\r\n        matrix.type );\r\n    },\r\n\r\n    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler\r\n    m00: function() { return this.entries[ 0 ]; },\r\n    m01: function() { return this.entries[ 4 ]; },\r\n    m02: function() { return this.entries[ 8 ]; },\r\n    m03: function() { return this.entries[ 12 ]; },\r\n    m10: function() { return this.entries[ 1 ]; },\r\n    m11: function() { return this.entries[ 5 ]; },\r\n    m12: function() { return this.entries[ 9 ]; },\r\n    m13: function() { return this.entries[ 13 ]; },\r\n    m20: function() { return this.entries[ 2 ]; },\r\n    m21: function() { return this.entries[ 6 ]; },\r\n    m22: function() { return this.entries[ 10 ]; },\r\n    m23: function() { return this.entries[ 14 ]; },\r\n    m30: function() { return this.entries[ 3 ]; },\r\n    m31: function() { return this.entries[ 7 ]; },\r\n    m32: function() { return this.entries[ 11 ]; },\r\n    m33: function() { return this.entries[ 15 ]; },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.m00() ) &&\r\n             isFinite( this.m01() ) &&\r\n             isFinite( this.m02() ) &&\r\n             isFinite( this.m03() ) &&\r\n             isFinite( this.m10() ) &&\r\n             isFinite( this.m11() ) &&\r\n             isFinite( this.m12() ) &&\r\n             isFinite( this.m13() ) &&\r\n             isFinite( this.m20() ) &&\r\n             isFinite( this.m21() ) &&\r\n             isFinite( this.m22() ) &&\r\n             isFinite( this.m23() ) &&\r\n             isFinite( this.m30() ) &&\r\n             isFinite( this.m31() ) &&\r\n             isFinite( this.m32() ) &&\r\n             isFinite( this.m33() );\r\n    },\r\n\r\n    // the 3D translation, assuming multiplication with a homogeneous vector\r\n    getTranslation: function() {\r\n      return new dot.Vector3( this.m03(), this.m13(), this.m23() );\r\n    },\r\n    get translation() { return this.getTranslation(); },\r\n\r\n    // returns a vector that is equivalent to ( T(1,0,0).magnitude(), T(0,1,0).magnitude(), T(0,0,1).magnitude() )\r\n    // where T is a relative transform\r\n    getScaleVector: function() {\r\n      var m0003 = this.m00() + this.m03();\r\n      var m1013 = this.m10() + this.m13();\r\n      var m2023 = this.m20() + this.m23();\r\n      var m3033 = this.m30() + this.m33();\r\n      var m0103 = this.m01() + this.m03();\r\n      var m1113 = this.m11() + this.m13();\r\n      var m2123 = this.m21() + this.m23();\r\n      var m3133 = this.m31() + this.m33();\r\n      var m0203 = this.m02() + this.m03();\r\n      var m1213 = this.m12() + this.m13();\r\n      var m2223 = this.m22() + this.m23();\r\n      var m3233 = this.m32() + this.m33();\r\n      return new dot.Vector3(\r\n        Math.sqrt( m0003 * m0003 + m1013 * m1013 + m2023 * m2023 + m3033 * m3033 ),\r\n        Math.sqrt( m0103 * m0103 + m1113 * m1113 + m2123 * m2123 + m3133 * m3133 ),\r\n        Math.sqrt( m0203 * m0203 + m1213 * m1213 + m2223 * m2223 + m3233 * m3233 ) );\r\n    },\r\n    get scaleVector() { return this.getScaleVector(); },\r\n\r\n    getCSSTransform: function() {\r\n      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility\r\n\r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n\r\n      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!\r\n      // NOTE: the toFixed calls are inlined for performance reasons\r\n      return 'matrix3d(' +\r\n             this.entries[ 0 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 1 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 2 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 3 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 4 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 5 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 6 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 7 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 8 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 9 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 10 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 11 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 12 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 13 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 14 ].toFixed( 20 ) + ',' +\r\n             this.entries[ 15 ].toFixed( 20 ) + ')';\r\n    },\r\n    get cssTransform() { return this.getCSSTransform(); },\r\n\r\n    // exact equality\r\n    equals: function( m ) {\r\n      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() && this.m03() === m.m03() &&\r\n             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() && this.m13() === m.m13() &&\r\n             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22() && this.m23() === m.m23() &&\r\n             this.m30() === m.m30() && this.m31() === m.m31() && this.m32() === m.m32() && this.m33() === m.m33();\r\n    },\r\n\r\n    // equality within a margin of error\r\n    equalsEpsilon: function( m, epsilon ) {\r\n      return Math.abs( this.m00() - m.m00() ) < epsilon &&\r\n             Math.abs( this.m01() - m.m01() ) < epsilon &&\r\n             Math.abs( this.m02() - m.m02() ) < epsilon &&\r\n             Math.abs( this.m03() - m.m03() ) < epsilon &&\r\n             Math.abs( this.m10() - m.m10() ) < epsilon &&\r\n             Math.abs( this.m11() - m.m11() ) < epsilon &&\r\n             Math.abs( this.m12() - m.m12() ) < epsilon &&\r\n             Math.abs( this.m13() - m.m13() ) < epsilon &&\r\n             Math.abs( this.m20() - m.m20() ) < epsilon &&\r\n             Math.abs( this.m21() - m.m21() ) < epsilon &&\r\n             Math.abs( this.m22() - m.m22() ) < epsilon &&\r\n             Math.abs( this.m23() - m.m23() ) < epsilon &&\r\n             Math.abs( this.m30() - m.m30() ) < epsilon &&\r\n             Math.abs( this.m31() - m.m31() ) < epsilon &&\r\n             Math.abs( this.m32() - m.m32() ) < epsilon &&\r\n             Math.abs( this.m33() - m.m33() ) < epsilon;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutable operations (returning a new matrix)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    copy: function() {\r\n      return new Matrix4(\r\n        this.m00(), this.m01(), this.m02(), this.m03(),\r\n        this.m10(), this.m11(), this.m12(), this.m13(),\r\n        this.m20(), this.m21(), this.m22(), this.m23(),\r\n        this.m30(), this.m31(), this.m32(), this.m33(),\r\n        this.type\r\n      );\r\n    },\r\n\r\n    plus: function( m ) {\r\n      return new Matrix4(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),\r\n        this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()\r\n      );\r\n    },\r\n\r\n    minus: function( m ) {\r\n      return new Matrix4(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),\r\n        this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()\r\n      );\r\n    },\r\n\r\n    transposed: function() {\r\n      return new Matrix4(\r\n        this.m00(), this.m10(), this.m20(), this.m30(),\r\n        this.m01(), this.m11(), this.m21(), this.m31(),\r\n        this.m02(), this.m12(), this.m22(), this.m32(),\r\n        this.m03(), this.m13(), this.m23(), this.m33() );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Matrix4(\r\n        -this.m00(), -this.m01(), -this.m02(), -this.m03(),\r\n        -this.m10(), -this.m11(), -this.m12(), -this.m13(),\r\n        -this.m20(), -this.m21(), -this.m22(), -this.m23(),\r\n        -this.m30(), -this.m31(), -this.m32(), -this.m33() );\r\n    },\r\n\r\n    inverted: function() {\r\n      switch( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_3D:\r\n          return new Matrix4(\r\n            1, 0, 0, -this.m03(),\r\n            0, 1, 0, -this.m13(),\r\n            0, 0, 1, -this.m23(),\r\n            0, 0, 0, 1, Types.TRANSLATION_3D );\r\n        case Types.SCALING:\r\n          return new Matrix4(\r\n            1 / this.m00(), 0, 0, 0,\r\n            0, 1 / this.m11(), 0, 0,\r\n            0, 0, 1 / this.m22(), 0,\r\n            0, 0, 0, 1 / this.m33(), Types.SCALING );\r\n        case Types.AFFINE:\r\n        case Types.OTHER:\r\n          var det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return new Matrix4(\r\n              ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,\r\n              ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,\r\n              ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,\r\n              ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,\r\n              ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,\r\n              ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,\r\n              ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,\r\n              ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,\r\n              ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,\r\n              ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,\r\n              ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,\r\n              ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,\r\n              ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,\r\n              ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,\r\n              ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,\r\n              ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det\r\n            );\r\n          }\r\n          else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n\r\n    timesMatrix: function( m ) {\r\n      // I * M === M * I === I (the identity)\r\n      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {\r\n        return this.type === Types.IDENTITY ? m : this;\r\n      }\r\n\r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_3D ) {\r\n          // faster combination of translations\r\n          return new Matrix4(\r\n            1, 0, 0, this.m03() + m.m02(),\r\n            0, 1, 0, this.m13() + m.m12(),\r\n            0, 0, 1, this.m23() + m.m23(),\r\n            0, 0, 0, 1, Types.TRANSLATION_3D );\r\n        }\r\n        else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return new Matrix4(\r\n            this.m00() * m.m00(), 0, 0, 0,\r\n            0, this.m11() * m.m11(), 0, 0,\r\n            0, 0, this.m22() * m.m22(), 0,\r\n            0, 0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n\r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n\r\n        // affine case\r\n        return new Matrix4(\r\n          this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n          this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03(),\r\n          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n          this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13(),\r\n          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22(),\r\n          this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23(),\r\n          0, 0, 0, 1, Types.AFFINE );\r\n      }\r\n\r\n      // general case\r\n      return new Matrix4(\r\n        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),\r\n        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),\r\n        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),\r\n        this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),\r\n        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),\r\n        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),\r\n        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),\r\n        this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),\r\n        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),\r\n        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),\r\n        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),\r\n        this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),\r\n        this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),\r\n        this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),\r\n        this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),\r\n        this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33() );\r\n    },\r\n\r\n    timesVector4: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;\r\n      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;\r\n      return new dot.Vector4( x, y, z, w );\r\n    },\r\n\r\n    timesVector3: function( v ) {\r\n      return this.timesVector4( v.toVector4() ).toVector3();\r\n    },\r\n\r\n    timesTransposeVector4: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;\r\n      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;\r\n      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;\r\n      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;\r\n      return new dot.Vector4( x, y, z, w );\r\n    },\r\n\r\n    timesTransposeVector3: function( v ) {\r\n      return this.timesTransposeVector4( v.toVector4() ).toVector3();\r\n    },\r\n\r\n    timesRelativeVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;\r\n      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;\r\n      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;\r\n      return new dot.Vector3( x, y, z );\r\n    },\r\n\r\n    getDeterminant: function() {\r\n      return this.m03() * this.m12() * this.m21() * this.m30() -\r\n             this.m02() * this.m13() * this.m21() * this.m30() -\r\n             this.m03() * this.m11() * this.m22() * this.m30() +\r\n             this.m01() * this.m13() * this.m22() * this.m30() +\r\n             this.m02() * this.m11() * this.m23() * this.m30() -\r\n             this.m01() * this.m12() * this.m23() * this.m30() -\r\n             this.m03() * this.m12() * this.m20() * this.m31() +\r\n             this.m02() * this.m13() * this.m20() * this.m31() +\r\n             this.m03() * this.m10() * this.m22() * this.m31() -\r\n             this.m00() * this.m13() * this.m22() * this.m31() -\r\n             this.m02() * this.m10() * this.m23() * this.m31() +\r\n             this.m00() * this.m12() * this.m23() * this.m31() +\r\n             this.m03() * this.m11() * this.m20() * this.m32() -\r\n             this.m01() * this.m13() * this.m20() * this.m32() -\r\n             this.m03() * this.m10() * this.m21() * this.m32() +\r\n             this.m00() * this.m13() * this.m21() * this.m32() +\r\n             this.m01() * this.m10() * this.m23() * this.m32() -\r\n             this.m00() * this.m11() * this.m23() * this.m32() -\r\n             this.m02() * this.m11() * this.m20() * this.m33() +\r\n             this.m01() * this.m12() * this.m20() * this.m33() +\r\n             this.m02() * this.m10() * this.m21() * this.m33() -\r\n             this.m00() * this.m12() * this.m21() * this.m33() -\r\n             this.m01() * this.m10() * this.m22() * this.m33() +\r\n             this.m00() * this.m11() * this.m22() * this.m33();\r\n    },\r\n    get determinant() { return this.getDeterminant(); },\r\n\r\n    toString: function() {\r\n      return this.m00() + \" \" + this.m01() + \" \" + this.m02() + \" \" + this.m03() + \"\\n\" +\r\n             this.m10() + \" \" + this.m11() + \" \" + this.m12() + \" \" + this.m13() + \"\\n\" +\r\n             this.m20() + \" \" + this.m21() + \" \" + this.m22() + \" \" + this.m23() + \"\\n\" +\r\n             this.m30() + \" \" + this.m31() + \" \" + this.m32() + \" \" + this.m33();\r\n    },\r\n\r\n    makeImmutable: function() {\r\n      this.rowMajor = function() {\r\n        throw new Error( \"Cannot modify immutable matrix\" );\r\n      };\r\n    }\r\n  };\r\n\r\n  // create an immutable\r\n  Matrix4.IDENTITY = new Matrix4();\r\n  Matrix4.IDENTITY.makeImmutable();\r\n\r\n  return Matrix4;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * 3-dimensional Matrix\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Matrix3',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n\r\n  var FastArray = dot.FastArray;\r\n\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Matrix4' );\r\n\r\n  var identityFastArray = new FastArray( 9 );\r\n  identityFastArray[ 0 ] = 1;\r\n  identityFastArray[ 4 ] = 1;\r\n  identityFastArray[ 8 ] = 1;\r\n\r\n  var createIdentityArray = FastArray === Array ?\r\n                            function() {\r\n                              return [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\r\n                            } :\r\n                            function() {\r\n                              return new FastArray( identityFastArray );\r\n                            };\r\n\r\n  //Create an identity matrix\r\n  dot.Matrix3 = function Matrix3( argumentsShouldNotExist ) {\r\n\r\n    //Make sure no clients are expecting to create a matrix with non-identity values\r\n    assert && assert( !argumentsShouldNotExist, 'Matrix3 constructor should not be called with any arguments.  Use Matrix3.createFromPool()/Matrix3.identity()/etc.' );\r\n\r\n    // entries stored in column-major format\r\n    this.entries = createIdentityArray();\r\n\r\n//    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0,\r\n//        v10 || 0, v11 === undefined ? 1 : v11, v12 || 0,\r\n//        v20 || 0, v21 || 0, v22 === undefined ? 1 : v22,\r\n//      type );\r\n\r\n    phetAllocation && phetAllocation( 'Matrix3' );\r\n    this.type = Types.IDENTITY;\r\n  };\r\n  var Matrix3 = dot.Matrix3;\r\n\r\n  Matrix3.Types = {\r\n    // NOTE: if an inverted matrix of a type is not that type, change inverted()!\r\n    // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!\r\n    // NOTE: on adding a type, exaustively check all type usage\r\n    OTHER: 0, // default\r\n    IDENTITY: 1,\r\n    TRANSLATION_2D: 2,\r\n    SCALING: 3,\r\n    AFFINE: 4\r\n\r\n    // TODO: possibly add rotations\r\n  };\r\n\r\n  var Types = Matrix3.Types;\r\n\r\n  Matrix3.identity = function() { return Matrix3.dirtyFromPool().setToIdentity(); };\r\n  Matrix3.translation = function( x, y ) { return Matrix3.dirtyFromPool().setToTranslation( x, y ); };\r\n  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };\r\n  Matrix3.scaling = function( x, y ) { return Matrix3.dirtyFromPool().setToScale( x, y ); };\r\n  Matrix3.scale = Matrix3.scaling;\r\n  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) { return Matrix3.dirtyFromPool().setToAffine( m00, m01, m02, m10, m11, m12 ); };\r\n  Matrix3.rowMajor = function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) { return Matrix3.dirtyFromPool().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ); };\r\n\r\n  // axis is a normalized Vector3, angle in radians.\r\n  Matrix3.rotationAxisAngle = function( axis, angle ) { return Matrix3.dirtyFromPool().setToRotationAxisAngle( axis, angle ); };\r\n\r\n  Matrix3.rotationX = function( angle ) { return Matrix3.dirtyFromPool().setToRotationX( angle ); };\r\n  Matrix3.rotationY = function( angle ) { return Matrix3.dirtyFromPool().setToRotationY( angle ); };\r\n  Matrix3.rotationZ = function( angle ) { return Matrix3.dirtyFromPool().setToRotationZ( angle ); };\r\n\r\n  // standard 2d rotation\r\n  Matrix3.rotation2 = Matrix3.rotationZ;\r\n\r\n  Matrix3.rotationAround = function( angle, x, y ) {\r\n    return Matrix3.translation( x, y ).timesMatrix( Matrix3.rotation2( angle ) ).timesMatrix( Matrix3.translation( -x, -y ) );\r\n  };\r\n\r\n  Matrix3.rotationAroundPoint = function( angle, point ) {\r\n    return Matrix3.rotationAround( angle, point.x, point.y );\r\n  };\r\n\r\n  Matrix3.fromSVGMatrix = function( svgMatrix ) { return Matrix3.dirtyFromPool().setToSVGMatrix( svgMatrix ); };\r\n\r\n  // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors\r\n  Matrix3.rotateAToB = function( a, b ) { return Matrix3.dirtyFromPool().setRotationAToB( a, b ); };\r\n\r\n  Matrix3.prototype = {\r\n    constructor: Matrix3,\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * \"Properties\"\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler\r\n    m00: function() { return this.entries[ 0 ]; },\r\n    m01: function() { return this.entries[ 3 ]; },\r\n    m02: function() { return this.entries[ 6 ]; },\r\n    m10: function() { return this.entries[ 1 ]; },\r\n    m11: function() { return this.entries[ 4 ]; },\r\n    m12: function() { return this.entries[ 7 ]; },\r\n    m20: function() { return this.entries[ 2 ]; },\r\n    m21: function() { return this.entries[ 5 ]; },\r\n    m22: function() { return this.entries[ 8 ]; },\r\n\r\n    isIdentity: function() {\r\n      return this.type === Types.IDENTITY || this.equals( Matrix3.IDENTITY );\r\n    },\r\n\r\n    isAffine: function() {\r\n      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );\r\n    },\r\n\r\n    // if it's an affine matrix where the components of transforms are independent\r\n    // i.e. constructed from arbitrary component scaling and translation.\r\n    isAligned: function() {\r\n      // non-diagonal non-translation entries should all be zero.\r\n      return this.isAffine() && this.m01() === 0 && this.m10() === 0;\r\n    },\r\n\r\n    // if it's an affine matrix where the components of transforms are independent, but may be switched (unlike isAligned)\r\n    // i.e. the 2x2 rotational sub-matrix is of one of the two forms:\r\n    // A 0  or  0  A\r\n    // 0 B      B  0\r\n    // This means that moving a transformed point by (x,0) or (0,y) will result in a motion along one of the axes.\r\n    isAxisAligned: function() {\r\n      return this.isAffine() && ( ( this.m01() === 0 && this.m10() === 0 ) || ( this.m00() === 0 && this.m11() === 0 ) );\r\n    },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.m00() ) &&\r\n             isFinite( this.m01() ) &&\r\n             isFinite( this.m02() ) &&\r\n             isFinite( this.m10() ) &&\r\n             isFinite( this.m11() ) &&\r\n             isFinite( this.m12() ) &&\r\n             isFinite( this.m20() ) &&\r\n             isFinite( this.m21() ) &&\r\n             isFinite( this.m22() );\r\n    },\r\n\r\n    getDeterminant: function() {\r\n      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();\r\n    },\r\n    get determinant() { return this.getDeterminant(); },\r\n\r\n    // the 2D translation, assuming multiplication with a homogeneous vector\r\n    getTranslation: function() {\r\n      return new dot.Vector2( this.m02(), this.m12() );\r\n    },\r\n    get translation() { return this.getTranslation(); },\r\n\r\n    // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform\r\n    getScaleVector: function() {\r\n      return new dot.Vector2(\r\n        Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),\r\n        Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );\r\n    },\r\n    get scaleVector() { return this.getScaleVector(); },\r\n\r\n    // angle in radians for the 2d rotation from this matrix, between pi, -pi\r\n    getRotation: function() {\r\n      return Math.atan2( this.m10(), this.m00() );\r\n    },\r\n    get rotation() { return this.getRotation(); },\r\n\r\n    toMatrix4: function() {\r\n      return new dot.Matrix4(\r\n        this.m00(), this.m01(), this.m02(), 0,\r\n        this.m10(), this.m11(), this.m12(), 0,\r\n        this.m20(), this.m21(), this.m22(), 0,\r\n        0, 0, 0, 1 );\r\n    },\r\n\r\n    toAffineMatrix4: function() {\r\n      return new dot.Matrix4(\r\n        this.m00(), this.m01(), 0, this.m02(),\r\n        this.m10(), this.m11(), 0, this.m12(),\r\n        0, 0, 1, 0,\r\n        0, 0, 0, 1 );\r\n    },\r\n\r\n    toString: function() {\r\n      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\\n' +\r\n             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\\n' +\r\n             this.m20() + ' ' + this.m21() + ' ' + this.m22();\r\n    },\r\n\r\n    toSVGMatrix: function() {\r\n      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();\r\n\r\n      // top two rows\r\n      result.a = this.m00();\r\n      result.b = this.m10();\r\n      result.c = this.m01();\r\n      result.d = this.m11();\r\n      result.e = this.m02();\r\n      result.f = this.m12();\r\n\r\n      return result;\r\n    },\r\n\r\n    getCSSTransform: function() {\r\n      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility\r\n\r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n\r\n      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!\r\n      // NOTE: the toFixed calls are inlined for performance reasons\r\n      return 'matrix(' + this.entries[ 0 ].toFixed( 20 ) + ',' + this.entries[ 1 ].toFixed( 20 ) + ',' + this.entries[ 3 ].toFixed( 20 ) + ',' + this.entries[ 4 ].toFixed( 20 ) + ',' + this.entries[ 6 ].toFixed( 20 ) + ',' + this.entries[ 7 ].toFixed( 20 ) + ')';\r\n    },\r\n    get cssTransform() { return this.getCSSTransform(); },\r\n\r\n    getSVGTransform: function() {\r\n      // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute\r\n\r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      function svgNumber( number ) {\r\n        // largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n        return number.toFixed( 20 );\r\n      }\r\n\r\n      switch( this.type ) {\r\n        case Types.IDENTITY:\r\n          return '';\r\n        case Types.TRANSLATION_2D:\r\n          return 'translate(' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';\r\n        case Types.SCALING:\r\n          return 'scale(' + svgNumber( this.entries[ 0 ] ) + ( this.entries[ 0 ] === this.entries[ 4 ] ? '' : ',' + svgNumber( this.entries[ 4 ] ) ) + ')';\r\n        default:\r\n          return 'matrix(' + svgNumber( this.entries[ 0 ] ) + ',' + svgNumber( this.entries[ 1 ] ) + ',' + svgNumber( this.entries[ 3 ] ) + ',' + svgNumber( this.entries[ 4 ] ) + ',' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';\r\n      }\r\n    },\r\n    get svgTransform() { return this.getSVGTransform(); },\r\n\r\n    // returns a parameter object suitable for use with jQuery's .css()\r\n    getCSSTransformStyles: function() {\r\n      var transformCSS = this.getCSSTransform();\r\n\r\n      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/\r\n      return {\r\n        // force iOS hardware acceleration\r\n        '-webkit-perspective': 1000,\r\n        '-webkit-backface-visibility': 'hidden',\r\n\r\n        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible\r\n        '-moz-transform':    transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible\r\n        '-ms-transform': transformCSS,\r\n        '-o-transform': transformCSS,\r\n        'transform': transformCSS,\r\n        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin\r\n        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?\r\n      };\r\n    },\r\n    get cssTransformStyles() { return this.getCSSTransformStyles(); },\r\n\r\n    // exact equality\r\n    equals: function( m ) {\r\n      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&\r\n             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&\r\n             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();\r\n    },\r\n\r\n    // equality within a margin of error\r\n    equalsEpsilon: function( m, epsilon ) {\r\n      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&\r\n             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&\r\n             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutable operations (returns a new matrix)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    copy: function() {\r\n      return Matrix3.createFromPool(\r\n        this.m00(), this.m01(), this.m02(),\r\n        this.m10(), this.m11(), this.m12(),\r\n        this.m20(), this.m21(), this.m22(),\r\n        this.type\r\n      );\r\n    },\r\n\r\n    plus: function( m ) {\r\n      return Matrix3.createFromPool(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()\r\n      );\r\n    },\r\n\r\n    minus: function( m ) {\r\n      return Matrix3.createFromPool(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()\r\n      );\r\n    },\r\n\r\n    transposed: function() {\r\n      return Matrix3.createFromPool(\r\n        this.m00(), this.m10(), this.m20(),\r\n        this.m01(), this.m11(), this.m21(),\r\n        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined\r\n      );\r\n    },\r\n\r\n    negated: function() {\r\n      return Matrix3.createFromPool(\r\n        -this.m00(), -this.m01(), -this.m02(),\r\n        -this.m10(), -this.m11(), -this.m12(),\r\n        -this.m20(), -this.m21(), -this.m22()\r\n      );\r\n    },\r\n\r\n    inverted: function() {\r\n      var det;\r\n\r\n      switch( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_2D:\r\n          return Matrix3.createFromPool(\r\n            1, 0, -this.m02(),\r\n            0, 1, -this.m12(),\r\n            0, 0, 1, Types.TRANSLATION_2D );\r\n        case Types.SCALING:\r\n          return Matrix3.createFromPool(\r\n            1 / this.m00(), 0, 0,\r\n            0, 1 / this.m11(), 0,\r\n            0, 0, 1 / this.m22(), Types.SCALING );\r\n        case Types.AFFINE:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return Matrix3.createFromPool(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              0, 0, 1, Types.AFFINE\r\n            );\r\n          }\r\n          else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        case Types.OTHER:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return Matrix3.createFromPool(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,\r\n              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,\r\n              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,\r\n              Types.OTHER\r\n            );\r\n          }\r\n          else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n\r\n    timesMatrix: function( m ) {\r\n      // I * M === M * I === M (the identity)\r\n      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {\r\n        return this.type === Types.IDENTITY ? m : this;\r\n      }\r\n\r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_2D ) {\r\n          // faster combination of translations\r\n          return Matrix3.createFromPool(\r\n            1, 0, this.m02() + m.m02(),\r\n            0, 1, this.m12() + m.m12(),\r\n            0, 0, 1, Types.TRANSLATION_2D );\r\n        }\r\n        else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return Matrix3.createFromPool(\r\n            this.m00() * m.m00(), 0, 0,\r\n            0, this.m11() * m.m11(), 0,\r\n            0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n\r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n\r\n        // affine case\r\n        return Matrix3.createFromPool(\r\n          this.m00() * m.m00() + this.m01() * m.m10(),\r\n          this.m00() * m.m01() + this.m01() * m.m11(),\r\n          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),\r\n          this.m10() * m.m00() + this.m11() * m.m10(),\r\n          this.m10() * m.m01() + this.m11() * m.m11(),\r\n          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),\r\n          0, 0, 1, Types.AFFINE );\r\n      }\r\n\r\n      // general case\r\n      return Matrix3.createFromPool(\r\n        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutable operations (returns new form of a parameter)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    timesVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02();\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12();\r\n      return new dot.Vector2( x, y );\r\n    },\r\n\r\n    timesVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;\r\n      return new dot.Vector3( x, y, z );\r\n    },\r\n\r\n    timesTransposeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y;\r\n      var y = this.m01() * v.x + this.m11() * v.y;\r\n      return new dot.Vector2( x, y );\r\n    },\r\n\r\n    // TODO: this operation seems to not work for transformDelta2, should be vetted\r\n    timesRelativeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y;\r\n      var y = this.m10() * v.y + this.m11() * v.y;\r\n      return new dot.Vector2( x, y );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutable operations (changes this matrix)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // every mutable method goes through rowMajor\r\n    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n      this.entries[ 0 ] = v00;\r\n      this.entries[ 1 ] = v10;\r\n      this.entries[ 2 ] = v20;\r\n      this.entries[ 3 ] = v01;\r\n      this.entries[ 4 ] = v11;\r\n      this.entries[ 5 ] = v21;\r\n      this.entries[ 6 ] = v02;\r\n      this.entries[ 7 ] = v12;\r\n      this.entries[ 8 ] = v22;\r\n\r\n      // TODO: consider performance of the affine check here\r\n      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;\r\n      return this;\r\n    },\r\n\r\n    set: function( matrix ) {\r\n      return this.rowMajor(\r\n        matrix.m00(), matrix.m01(), matrix.m02(),\r\n        matrix.m10(), matrix.m11(), matrix.m12(),\r\n        matrix.m20(), matrix.m21(), matrix.m22(),\r\n        matrix.type );\r\n    },\r\n\r\n    makeImmutable: function() {\r\n      this.rowMajor = function() {\r\n        throw new Error( 'Cannot modify immutable matrix' );\r\n      };\r\n      return this;\r\n    },\r\n\r\n    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {\r\n      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n    },\r\n\r\n    add: function( m ) {\r\n      return this.rowMajor(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()\r\n      );\r\n    },\r\n\r\n    subtract: function( m ) {\r\n      return this.rowMajor(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()\r\n      );\r\n    },\r\n\r\n    transpose: function() {\r\n      return this.rowMajor(\r\n        this.m00(), this.m10(), this.m20(),\r\n        this.m01(), this.m11(), this.m21(),\r\n        this.m02(), this.m12(), this.m22(),\r\n        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined\r\n      );\r\n    },\r\n\r\n    negate: function() {\r\n      return this.rowMajor(\r\n        -this.m00(), -this.m01(), -this.m02(),\r\n        -this.m10(), -this.m11(), -this.m12(),\r\n        -this.m20(), -this.m21(), -this.m22()\r\n      );\r\n    },\r\n\r\n    invert: function() {\r\n      var det;\r\n\r\n      switch( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_2D:\r\n          return this.rowMajor(\r\n            1, 0, -this.m02(),\r\n            0, 1, -this.m12(),\r\n            0, 0, 1, Types.TRANSLATION_2D );\r\n        case Types.SCALING:\r\n          return this.rowMajor(\r\n            1 / this.m00(), 0, 0,\r\n            0, 1 / this.m11(), 0,\r\n            0, 0, 1 / this.m22(), Types.SCALING );\r\n        case Types.AFFINE:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return this.rowMajor(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              0, 0, 1, Types.AFFINE\r\n            );\r\n          }\r\n          else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        case Types.OTHER:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return this.rowMajor(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,\r\n              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,\r\n              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,\r\n              Types.OTHER\r\n            );\r\n          }\r\n          else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n\r\n    multiplyMatrix: function( m ) {\r\n      // M * I === M (the identity)\r\n      if ( m.type === Types.IDENTITY ) {\r\n        // no change needed\r\n        return this;\r\n      }\r\n\r\n      // I * M === M (the identity)\r\n      if ( this.type === Types.IDENTITY ) {\r\n        // copy the other matrix to us\r\n        return this.set( m );\r\n      }\r\n\r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_2D ) {\r\n          // faster combination of translations\r\n          return this.rowMajor(\r\n            1, 0, this.m02() + m.m02(),\r\n            0, 1, this.m12() + m.m12(),\r\n            0, 0, 1, Types.TRANSLATION_2D );\r\n        }\r\n        else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return this.rowMajor(\r\n            this.m00() * m.m00(), 0, 0,\r\n            0, this.m11() * m.m11(), 0,\r\n            0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n\r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n\r\n        // affine case\r\n        return this.rowMajor(\r\n          this.m00() * m.m00() + this.m01() * m.m10(),\r\n          this.m00() * m.m01() + this.m01() * m.m11(),\r\n          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),\r\n          this.m10() * m.m00() + this.m11() * m.m10(),\r\n          this.m10() * m.m01() + this.m11() * m.m11(),\r\n          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),\r\n          0, 0, 1, Types.AFFINE );\r\n      }\r\n\r\n      // general case\r\n      return this.rowMajor(\r\n        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );\r\n    },\r\n\r\n    setToIdentity: function() {\r\n      return this.rowMajor(\r\n        1, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 1,\r\n        Types.IDENTITY );\r\n    },\r\n\r\n    setToTranslation: function( x, y ) {\r\n      return this.rowMajor(\r\n        1, 0, x,\r\n        0, 1, y,\r\n        0, 0, 1,\r\n        Types.TRANSLATION_2D );\r\n    },\r\n\r\n    setToScale: function( x, y ) {\r\n      // allow using one parameter to scale everything\r\n      y = y === undefined ? x : y;\r\n\r\n      return this.rowMajor(\r\n        x, 0, 0,\r\n        0, y, 0,\r\n        0, 0, 1,\r\n        Types.SCALING );\r\n    },\r\n\r\n    // row major\r\n    setToAffine: function( m00, m01, m02, m10, m11, m12 ) {\r\n      return this.rowMajor( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );\r\n    },\r\n\r\n    // axis is a normalized Vector3, angle in radians.\r\n    setToRotationAxisAngle: function( axis, angle ) {\r\n      var c = Math.cos( angle );\r\n      var s = Math.sin( angle );\r\n      var C = 1 - c;\r\n\r\n      return this.rowMajor(\r\n        axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,\r\n        axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,\r\n        axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,\r\n        Types.OTHER );\r\n    },\r\n\r\n    setToRotationX: function( angle ) {\r\n      var c = Math.cos( angle );\r\n      var s = Math.sin( angle );\r\n\r\n      return this.rowMajor(\r\n        1, 0, 0,\r\n        0, c, -s,\r\n        0, s, c,\r\n        Types.OTHER );\r\n    },\r\n\r\n    setToRotationY: function( angle ) {\r\n      var c = Math.cos( angle );\r\n      var s = Math.sin( angle );\r\n\r\n      return this.rowMajor(\r\n        c, 0, s,\r\n        0, 1, 0,\r\n        -s, 0, c,\r\n        Types.OTHER );\r\n    },\r\n\r\n    setToRotationZ: function( angle ) {\r\n      var c = Math.cos( angle );\r\n      var s = Math.sin( angle );\r\n\r\n      return this.rowMajor(\r\n        c, -s, 0,\r\n        s, c, 0,\r\n        0, 0, 1,\r\n        Types.AFFINE );\r\n    },\r\n\r\n    setToSVGMatrix: function( svgMatrix ) {\r\n      return this.rowMajor(\r\n        svgMatrix.a, svgMatrix.c, svgMatrix.e,\r\n        svgMatrix.b, svgMatrix.d, svgMatrix.f,\r\n        0, 0, 1,\r\n        Types.AFFINE );\r\n    },\r\n\r\n    // a rotation matrix that rotates A to B (Vector3 instances), by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors\r\n    setRotationAToB: function( a, b ) {\r\n      // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation\r\n      var start = a;\r\n      var end = b;\r\n\r\n      var epsilon = 0.0001;\r\n\r\n      var e, h, f;\r\n\r\n      var v = start.cross( end );\r\n      e = start.dot( end );\r\n      f = ( e < 0 ) ? -e : e;\r\n\r\n      // if \"from\" and \"to\" vectors are nearly parallel\r\n      if ( f > 1.0 - epsilon ) {\r\n        var c1, c2, c3;\r\n\r\n        var x = new dot.Vector3(\r\n          ( start.x > 0.0 ) ? start.x : -start.x,\r\n          ( start.y > 0.0 ) ? start.y : -start.y,\r\n          ( start.z > 0.0 ) ? start.z : -start.z\r\n        );\r\n\r\n        if ( x.x < x.y ) {\r\n          if ( x.x < x.z ) {\r\n            x = dot.Vector3.X_UNIT;\r\n          }\r\n          else {\r\n            x = dot.Vector3.Z_UNIT;\r\n          }\r\n        }\r\n        else {\r\n          if ( x.y < x.z ) {\r\n            x = dot.Vector3.Y_UNIT;\r\n          }\r\n          else {\r\n            x = dot.Vector3.Z_UNIT;\r\n          }\r\n        }\r\n\r\n        var u = x.minus( start );\r\n        v = x.minus( end );\r\n\r\n        c1 = 2.0 / u.dot( u );\r\n        c2 = 2.0 / v.dot( v );\r\n        c3 = c1 * c2 * u.dot( v );\r\n\r\n        return this.rowMajor(\r\n          -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x + 1,\r\n          -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,\r\n          -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,\r\n          -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,\r\n          -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y + 1,\r\n          -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,\r\n          -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,\r\n          -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,\r\n          -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z + 1\r\n        );\r\n      }\r\n      else {\r\n        // the most common case, unless \"start\"=\"end\", or \"start\"=-\"end\"\r\n        var hvx, hvz, hvxy, hvxz, hvyz;\r\n        h = 1.0 / ( 1.0 + e );\r\n        hvx = h * v.x;\r\n        hvz = h * v.z;\r\n        hvxy = hvx * v.y;\r\n        hvxz = hvx * v.z;\r\n        hvyz = hvz * v.y;\r\n\r\n        return this.rowMajor(\r\n          e + hvx * v.x, hvxy - v.z, hvxz + v.y,\r\n          hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,\r\n          hvxz - v.y, hvyz + v.x, e + hvz * v.z\r\n        );\r\n      }\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutable operations (changes the parameter)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    multiplyVector2: function( v ) {\r\n      return v.setXY(\r\n        this.m00() * v.x + this.m01() * v.y + this.m02(),\r\n        this.m10() * v.x + this.m11() * v.y + this.m12() );\r\n    },\r\n\r\n    multiplyVector3: function( v ) {\r\n      return v.setXYZ(\r\n        this.m00() * v.x + this.m01() * v.y + this.m02() * v.z,\r\n        this.m10() * v.x + this.m11() * v.y + this.m12() * v.z,\r\n        this.m20() * v.x + this.m21() * v.y + this.m22() * v.z );\r\n    },\r\n\r\n    multiplyTransposeVector2: function( v ) {\r\n      return v.setXY(\r\n        this.m00() * v.x + this.m10() * v.y,\r\n        this.m01() * v.x + this.m11() * v.y );\r\n    },\r\n\r\n    multiplyRelativeVector2: function( v ) {\r\n      return v.setXY(\r\n        this.m00() * v.x + this.m01() * v.y,\r\n        this.m10() * v.y + this.m11() * v.y );\r\n    },\r\n\r\n    // sets the transform of a Canvas 2D rendering context to the affine part of this matrix\r\n    canvasSetTransform: function( context ) {\r\n      context.setTransform(\r\n        // inlined array entries\r\n        this.entries[ 0 ],\r\n        this.entries[ 1 ],\r\n        this.entries[ 3 ],\r\n        this.entries[ 4 ],\r\n        this.entries[ 6 ],\r\n        this.entries[ 7 ]\r\n      );\r\n    },\r\n\r\n    // appends the affine part of this matrix to the Canvas 2D rendering context\r\n    canvasAppendTransform: function( context ) {\r\n      if ( this.type !== Types.IDENTITY ) {\r\n        context.transform(\r\n          // inlined array entries\r\n          this.entries[ 0 ],\r\n          this.entries[ 1 ],\r\n          this.entries[ 3 ],\r\n          this.entries[ 4 ],\r\n          this.entries[ 6 ],\r\n          this.entries[ 7 ]\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  Poolable.mixin( Matrix3, {\r\n\r\n    //The default factory creates an identity matrix\r\n    defaultFactory: function() { return new Matrix3(); },\r\n\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n        var instance = pool.length ? pool.pop() : new Matrix3();\r\n        return instance.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n      };\r\n    }\r\n  } );\r\n\r\n  // create an immutable\r\n  Matrix3.IDENTITY = Matrix3.identity();\r\n  Matrix3.IDENTITY.makeImmutable();\r\n\r\n  Matrix3.X_REFLECTION = Matrix3.createFromPool( -1, 0, 0,\r\n    0, 1, 0,\r\n    0, 0, 1,\r\n    Types.AFFINE );\r\n  Matrix3.X_REFLECTION.makeImmutable();\r\n\r\n  Matrix3.Y_REFLECTION = Matrix3.createFromPool( 1, 0, 0,\r\n    0, -1, 0,\r\n    0, 0, 1,\r\n    Types.AFFINE );\r\n  Matrix3.Y_REFLECTION.makeImmutable();\r\n\r\n  //Shortcut for translation times a matrix (without allocating a translation matrix), see scenery#119\r\n  Matrix3.translationTimesMatrix = function( x, y, m ) {\r\n    var type;\r\n    if ( m.type === Types.IDENTITY || m.type === Types.TRANSLATION_2D ) {\r\n      return Matrix3.createFromPool(\r\n        1, 0, m.m02() + x,\r\n        0, 1, m.m12() + y,\r\n        0, 0, 1,\r\n        Types.TRANSLATION_2D );\r\n    }\r\n    else if ( m.type === Types.OTHER ) {\r\n      type = Types.OTHER;\r\n    }\r\n    else {\r\n      type = Types.AFFINE;\r\n    }\r\n    return Matrix3.createFromPool( m.m00(), m.m01(), m.m02() + x,\r\n      m.m10(), m.m11(), m.m12() + y,\r\n      m.m20(), m.m21(), m.m22(),\r\n      type );\r\n  };\r\n\r\n  Matrix3.printer = {\r\n    print: function( matrix ) {\r\n      console.log( matrix.toString() );\r\n    }\r\n  };\r\n\r\n  return Matrix3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Quadratic Bezier segment\r\n *\r\n * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/segments/Quadratic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;\r\n  var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Quadratic = function Quadratic( start, control, end ) {\r\n    this._start = start;\r\n    this._control = control;\r\n    this._end = end;\r\n\r\n    // TODO: performance test removal of these undefined declarations\r\n    this._startTangent = undefined;\r\n    this._endTangent = undefined;\r\n    this._tCriticalX = undefined; // replaced with null if not in range\r\n    this._tCriticalY = undefined; // replaced with null if not in range\r\n    this._bounds = undefined;\r\n  };\r\n  inherit( Segment, Segment.Quadratic, {\r\n\r\n    degree: 2,\r\n\r\n    getStart: function() {\r\n      return this._start;\r\n    },\r\n    get start() { return this._start; },\r\n\r\n    getControl: function() {\r\n      return this._control;\r\n    },\r\n    get control() { return this._control; },\r\n\r\n    getEnd: function() {\r\n      return this._end;\r\n    },\r\n    get end() { return this._end; },\r\n\r\n    getStartTangent: function() {\r\n      if ( this._startTangent === undefined ) {\r\n        var controlIsStart = this._start.equals( this._control );\r\n        // TODO: allocation reduction\r\n        this._startTangent = controlIsStart ?\r\n                             this._end.minus( this._start ).normalized() :\r\n                             this._control.minus( this._start ).normalized();\r\n      }\r\n      return this._startTangent;\r\n    },\r\n    get startTangent() { return this.getStartTangent(); },\r\n\r\n    getEndTangent: function() {\r\n      if ( this._endTangent === undefined ) {\r\n        var controlIsEnd = this._end.equals( this._control );\r\n        // TODO: allocation reduction\r\n        this._endTangent = controlIsEnd ?\r\n                           this._end.minus( this._start ).normalized() :\r\n                           this._end.minus( this._control ).normalized();\r\n      }\r\n      return this._endTangent;\r\n    },\r\n    get endTangent() { return this.getEndTangent(); },\r\n\r\n    getTCriticalX: function() {\r\n      // compute x where the derivative is 0 (used for bounds and other things)\r\n      if ( this._tCriticalX === undefined ) {\r\n        this._tCriticalX = Segment.Quadratic.extremaT( this._start.x, this._control.x, this._end.x );\r\n      }\r\n      return this._tCriticalX;\r\n    },\r\n    get tCriticalX() { return this.getTCriticalX(); },\r\n\r\n    getTCriticalY: function() {\r\n      // compute y where the derivative is 0 (used for bounds and other things)\r\n      if ( this._tCriticalY === undefined ) {\r\n        this._tCriticalY = Segment.Quadratic.extremaT( this._start.y, this._control.y, this._end.y );\r\n      }\r\n      return this._tCriticalY;\r\n    },\r\n    get tCriticalY() { return this.getTCriticalY(); },\r\n\r\n    getNondegenerateSegments: function() {\r\n      var start = this._start;\r\n      var control = this._control;\r\n      var end = this._end;\r\n\r\n      var startIsEnd = start.equals( end );\r\n      var startIsControl = start.equals( control );\r\n      var endIsControl = start.equals( control );\r\n\r\n      if ( startIsEnd && startIsControl ) {\r\n        // all same points\r\n        return [];\r\n      }\r\n      else if ( startIsEnd ) {\r\n        // this is a special collinear case, we basically line out to the farthest point and back\r\n        var halfPoint = this.positionAt( 0.5 );\r\n        return [\r\n          new Segment.Line( start, halfPoint ),\r\n          new Segment.Line( halfPoint, end )\r\n        ];\r\n      }\r\n      else if ( arePointsCollinear( start, control, end ) ) {\r\n        // if they are collinear, we can reduce to start->control and control->end, or if control is between, just one line segment\r\n        // also, start !== end (handled earlier)\r\n        if ( startIsControl || endIsControl ) {\r\n          // just a line segment!\r\n          return [ new Segment.Line( start, end ) ]; // no extra nondegenerate check since start !== end\r\n        }\r\n        // now control point must be unique. we check to see if our rendered path will be outside of the start->end line segment\r\n        var delta = end.minus( start );\r\n        var p1d = control.minus( start ).dot( delta.normalized ) / delta.magnitude();\r\n        var t = Segment.Quadratic.extremaT( 0, p1d, 1 );\r\n        if ( t !== null && t > 0 && t < 1 ) {\r\n          // we have a local max inside the range, indicating that our extrema point is outside of start->end\r\n          // we'll line to and from it\r\n          var pt = this.positionAt( t );\r\n          return _.flatten( [\r\n            new Segment.Line( start, pt ).getNondegenerateSegments(),\r\n            new Segment.Line( pt, end ).getNondegenerateSegments()\r\n          ] );\r\n        }\r\n        else {\r\n          // just provide a line segment, our rendered path doesn't go outside of this\r\n          return [ new Segment.Line( start, end ) ]; // no extra nondegenerate check since start !== end\r\n        }\r\n      }\r\n      else {\r\n        return [ this ];\r\n      }\r\n    },\r\n\r\n    getBounds: function() {\r\n      // calculate our temporary guaranteed lower bounds based on the end points\r\n      if ( this._bounds === undefined ) {\r\n        this._bounds = new Bounds2( Math.min( this._start.x, this._end.x ), Math.min( this._start.y, this._end.y ), Math.max( this._start.x, this._end.x ), Math.max( this._start.y, this._end.y ) );\r\n\r\n        // compute x and y where the derivative is 0, so we can include this in the bounds\r\n        var tCriticalX = this.getTCriticalX();\r\n        var tCriticalY = this.getTCriticalY();\r\n\r\n        if ( tCriticalX !== null && tCriticalX > 0 && tCriticalX < 1 ) {\r\n          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalX ) );\r\n        }\r\n        if ( tCriticalY !== null && tCriticalY > 0 && tCriticalY < 1 ) {\r\n          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalY ) );\r\n        }\r\n      }\r\n      return this._bounds;\r\n    },\r\n    get bounds() { return this.getBounds(); },\r\n\r\n    // can be described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end\r\n    positionAt: function( t ) {\r\n      var mt = 1 - t;\r\n      // TODO: allocation reduction\r\n      return this._start.times( mt * mt ).plus( this._control.times( 2 * mt * t ) ).plus( this._end.times( t * t ) );\r\n    },\r\n\r\n    // derivative: 2(1-t)( control - start ) + 2t( end - control )\r\n    tangentAt: function( t ) {\r\n      // TODO: allocation reduction\r\n      return this._control.minus( this._start ).times( 2 * ( 1 - t ) ).plus( this._end.minus( this._control ).times( 2 * t ) );\r\n    },\r\n\r\n    curvatureAt: function( t ) {\r\n      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31\r\n      // TODO: remove code duplication with Cubic\r\n      var epsilon = 0.0000001;\r\n      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {\r\n        var isZero = t < 0.5;\r\n        var p0 = isZero ? this._start : this._end;\r\n        var p1 = this._control;\r\n        var p2 = isZero ? this._end : this._start;\r\n        var d10 = p1.minus( p0 );\r\n        var a = d10.magnitude();\r\n        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );\r\n        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );\r\n      }\r\n      else {\r\n        return this.subdivided( t, true )[ 0 ].curvatureAt( 1 );\r\n      }\r\n    },\r\n\r\n    // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf\r\n    // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length\r\n\r\n    offsetTo: function( r, reverse ) {\r\n      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html\r\n      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      var curves = [ this ];\r\n\r\n      // subdivide this curve\r\n      var depth = 5; // generates 2^depth curves\r\n      for ( var i = 0; i < depth; i++ ) {\r\n        curves = _.flatten( _.map( curves, function( curve ) {\r\n          return curve.subdivided( 0.5, true );\r\n        } ) );\r\n      }\r\n\r\n      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );\r\n\r\n      if ( reverse ) {\r\n        offsetCurves.reverse();\r\n        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );\r\n      }\r\n\r\n      return offsetCurves;\r\n    },\r\n\r\n    subdivided: function( t ) {\r\n      // de Casteljau method\r\n      var leftMid = this._start.blend( this._control, t );\r\n      var rightMid = this._control.blend( this._end, t );\r\n      var mid = leftMid.blend( rightMid, t );\r\n      return [\r\n        new Segment.Quadratic( this._start, leftMid, mid ),\r\n        new Segment.Quadratic( mid, rightMid, this._end )\r\n      ];\r\n    },\r\n\r\n    // elevation of this quadratic Bezier curve to a cubic Bezier curve\r\n    degreeElevated: function() {\r\n      // TODO: allocation reduction\r\n      return new Segment.Cubic(\r\n        this._start,\r\n        this._start.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),\r\n        this._end.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),\r\n        this._end\r\n      );\r\n    },\r\n\r\n    reversed: function() {\r\n      return new Segment.Quadratic( this._end, this._control, this._start );\r\n    },\r\n\r\n    approximateOffset: function( r ) {\r\n      return new Segment.Quadratic(\r\n        this._start.plus( ( this._start.equals( this._control ) ? this._end.minus( this._start ) : this._control.minus( this._start ) ).perpendicular().normalized().times( r ) ),\r\n        this._control.plus( this._end.minus( this._start ).perpendicular().normalized().times( r ) ),\r\n        this._end.plus( ( this._end.equals( this._control ) ? this._end.minus( this._start ) : this._end.minus( this._control ) ).perpendicular().normalized().times( r ) )\r\n      );\r\n    },\r\n\r\n    getSVGPathFragment: function() {\r\n      return 'Q ' + kite.svgNumber( this._control.x ) + ' ' + kite.svgNumber( this._control.y ) + ' ' +\r\n             kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );\r\n    },\r\n\r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n\r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n\r\n    getInteriorExtremaTs: function() {\r\n      // TODO: we assume here we are reduce, so that a criticalX doesn't equal a criticalY?\r\n      var result = [];\r\n      var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n      if ( this.tCriticalX !== undefined && this.tCriticalX > epsilon && this.tCriticalX < 1 - epsilon ) {\r\n        result.push( this.tCriticalX );\r\n      }\r\n      if ( this.tCriticalY !== undefined && this.tCriticalY > epsilon && this.tCriticalY < 1 - epsilon ) {\r\n        result.push( this.tCriticalY );\r\n      }\r\n      return result.sort();\r\n    },\r\n\r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Quadratic.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n\r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    intersection: function( ray ) {\r\n      var self = this;\r\n      var result = [];\r\n\r\n      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );\r\n\r\n      var p0 = inverseMatrix.timesVector2( this._start );\r\n      var p1 = inverseMatrix.timesVector2( this._control );\r\n      var p2 = inverseMatrix.timesVector2( this._end );\r\n\r\n      //(1-t)^2 start + 2(1-t)t control + t^2 end\r\n      var a = p0.y - 2 * p1.y + p2.y;\r\n      var b = -2 * p0.y + 2 * p1.y;\r\n      var c = p0.y;\r\n\r\n      var ts = solveQuadraticRootsReal( a, b, c );\r\n\r\n      _.each( ts, function( t ) {\r\n        if ( t >= 0 && t <= 1 ) {\r\n          var hitPoint = self.positionAt( t );\r\n          var unitTangent = self.tangentAt( t ).normalized();\r\n          var perp = unitTangent.perpendicular();\r\n          var toHit = hitPoint.minus( ray.pos );\r\n\r\n          // make sure it's not behind the ray\r\n          if ( toHit.dot( ray.dir ) > 0 ) {\r\n            result.push( {\r\n              distance: toHit.magnitude(),\r\n              point: hitPoint,\r\n              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return result;\r\n    },\r\n\r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n\r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.quadraticCurveTo( this._control.x, this._control.y, this._end.x, this._end.y );\r\n    },\r\n\r\n    transformed: function( matrix ) {\r\n      return new Segment.Quadratic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control ), matrix.timesVector2( this._end ) );\r\n    },\r\n\r\n    // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b\r\n    reparameterized: function( a, b ) {\r\n      // to the polynomial pt^2 + qt + r:\r\n      var p = this._start.plus( this._end.plus( this._control.timesScalar( -2 ) ) );\r\n      var q = this._control.minus( this._start ).timesScalar( 2 );\r\n      var r = this._start;\r\n\r\n      // to the polynomial alpha*x^2 + beta*x + gamma:\r\n      var alpha = p.timesScalar( a * a );\r\n      var beta = p.timesScalar( a * b ).timesScalar( 2 ).plus( q.timesScalar( a ) );\r\n      var gamma = p.timesScalar( b * b ).plus( q.timesScalar( b ) ).plus( r );\r\n\r\n      // back to the form start,control,end\r\n      return new Segment.Quadratic( gamma, beta.timesScalar( 0.5 ).plus( gamma ), alpha.plus( beta ).plus( gamma ) );\r\n    }\r\n  } );\r\n\r\n  // one-dimensional solution to extrema\r\n  Segment.Quadratic.extremaT = function( start, control, end ) {\r\n    // compute t where the derivative is 0 (used for bounds and other things)\r\n    var divisorX = 2 * ( end - 2 * control + start );\r\n    if ( divisorX !== 0 ) {\r\n      return -2 * ( control - start ) / divisorX;\r\n    }\r\n    else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  return Segment.Quadratic;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Cubic Bezier segment.\r\n *\r\n * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info\r\n *\r\n * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/segments/Cubic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','DOT/Util','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;\r\n  var solveCubicRootsReal = require( 'DOT/Util' ).solveCubicRootsReal;\r\n  var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n  require( 'KITE/segments/Quadratic' );\r\n\r\n  Segment.Cubic = function Cubic( start, control1, control2, end ) {\r\n    this._start = start;\r\n    this._control1 = control1;\r\n    this._control2 = control2;\r\n    this._end = end;\r\n\r\n    // TODO: performance test removal of these undefined declarations\r\n    this._startTangent = undefined;\r\n    this._endTangent = undefined;\r\n    this._r = undefined;\r\n    this._s = undefined;\r\n\r\n    this._tCusp = undefined;\r\n    this._tDeterminant = undefined;\r\n    this._tInflection1 = undefined;\r\n    this._tInflection2 = undefined;\r\n    this._startQuadratic = undefined;\r\n    this._endQuadratic = undefined;\r\n\r\n    this._xExtremaT = undefined;\r\n    this._yExtremaT = undefined;\r\n\r\n    this._bounds = undefined;\r\n  };\r\n  inherit( Segment, Segment.Cubic, {\r\n\r\n    degree: 3,\r\n\r\n    getStart: function() {\r\n      return this._start;\r\n    },\r\n    get start() { return this._start; },\r\n\r\n    getControl1: function() {\r\n      return this._control1;\r\n    },\r\n    get control1() { return this._control1; },\r\n\r\n    getControl2: function() {\r\n      return this._control2;\r\n    },\r\n    get control2() { return this._control2; },\r\n\r\n    getEnd: function() {\r\n      return this._end;\r\n    },\r\n    get end() { return this._end; },\r\n\r\n    getStartTangent: function() {\r\n      if ( this._startTangent === undefined ) {\r\n        this._startTangent = this.tangentAt( 0 ).normalized();\r\n      }\r\n      return this._startTangent;\r\n    },\r\n    get startTangent() { return this.getStartTangent(); },\r\n\r\n    getEndTangent: function() {\r\n      if ( this._endTangent === undefined ) {\r\n        this._endTangent = this.tangentAt( 1 ).normalized();\r\n      }\r\n      return this._endTangent;\r\n    },\r\n    get endTangent() { return this.getEndTangent(); },\r\n\r\n    getR: function() {\r\n      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      if ( this._r === undefined ) {\r\n        this._r = this._control1.minus( this._start ).normalized();\r\n      }\r\n      return this._r;\r\n    },\r\n    get r() { return this.getR(); },\r\n\r\n    getS: function() {\r\n      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      if ( this._s === undefined ) {\r\n        this._s = this.getR().perpendicular();\r\n      }\r\n      return this._s;\r\n    },\r\n    get s() { return this.getS(); },\r\n\r\n    getTCusp: function() {\r\n      if ( this._tCusp === undefined ) {\r\n        this.computeCuspInfo();\r\n      }\r\n      assert && assert( this._tCusp !== undefined );\r\n      return this._tCusp;\r\n    },\r\n    get tCusp() { return this.getTCusp(); },\r\n\r\n    getTDeterminant: function() {\r\n      if ( this._tDeterminant === undefined ) {\r\n        this.computeCuspInfo();\r\n      }\r\n      assert && assert( this._tDeterminant !== undefined );\r\n      return this._tDeterminant;\r\n    },\r\n    get tDeterminant() { return this.getTDeterminant(); },\r\n\r\n    getTInflection1: function() {\r\n      if ( this._tInflection1 === undefined ) {\r\n        this.computeCuspInfo();\r\n      }\r\n      assert && assert( this._tInflection1 !== undefined );\r\n      return this._tInflection1;\r\n    },\r\n    get tInflection1() { return this.getTInflection1(); },\r\n\r\n    getTInflection2: function() {\r\n      if ( this._tInflection2 === undefined ) {\r\n        this.computeCuspInfo();\r\n      }\r\n      assert && assert( this._tInflection2 !== undefined );\r\n      return this._tInflection2;\r\n    },\r\n    get tInflection2() { return this.getTInflection2(); },\r\n\r\n    getStartQuadratic: function() {\r\n      if ( this._startQuadratic === undefined ) {\r\n        this.computeCuspSegments();\r\n      }\r\n      assert && assert( this._startQuadratic !== undefined );\r\n      return this._startQuadratic;\r\n    },\r\n    get startQuadratic() { return this.getStartQuadratic(); },\r\n\r\n    getEndQuadratic: function() {\r\n      if ( this._endQuadratic === undefined ) {\r\n        this.computeCuspSegments();\r\n      }\r\n      assert && assert( this._endQuadratic !== undefined );\r\n      return this._endQuadratic;\r\n    },\r\n    get endQuadratic() { return this.getEndQuadratic(); },\r\n\r\n    getXExtremaT: function() {\r\n      if ( this._xExtremaT === undefined ) {\r\n        this._xExtremaT = Segment.Cubic.extremaT( this._start.x, this._control1.x, this._control2.x, this._end.x );\r\n      }\r\n      return this._xExtremaT;\r\n    },\r\n    get xExtremaT() { return this.getXExtremaT(); },\r\n\r\n    getYExtremaT: function() {\r\n      if ( this._yExtremaT === undefined ) {\r\n        this._yExtremaT = Segment.Cubic.extremaT( this._start.y, this._control1.y, this._control2.y, this._end.y );\r\n      }\r\n      return this._yExtremaT;\r\n    },\r\n    get yExtremaT() { return this.getYExtremaT(); },\r\n\r\n    getBounds: function() {\r\n      if ( this._bounds === undefined ) {\r\n        this._bounds = Bounds2.NOTHING;\r\n        this._bounds = this._bounds.withPoint( this._start );\r\n        this._bounds = this._bounds.withPoint( this._end );\r\n\r\n        var cubic = this;\r\n        _.each( this.getXExtremaT(), function( t ) {\r\n          if ( t >= 0 && t <= 1 ) {\r\n            cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );\r\n          }\r\n        } );\r\n        _.each( this.getYExtremaT(), function( t ) {\r\n          if ( t >= 0 && t <= 1 ) {\r\n            cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );\r\n          }\r\n        } );\r\n\r\n        if ( this.hasCusp() ) {\r\n          this._bounds = this._bounds.withPoint( this.positionAt( this.getTCusp() ) );\r\n        }\r\n      }\r\n      return this._bounds;\r\n    },\r\n    get bounds() { return this.getBounds(); },\r\n\r\n    // t value for the cusp, and the related determinant and inflection points\r\n    computeCuspInfo: function() {\r\n      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      // TODO: allocation reduction\r\n      var a = this._start.times( -1 ).plus( this._control1.times( 3 ) ).plus( this._control2.times( -3 ) ).plus( this._end );\r\n      var b = this._start.times( 3 ).plus( this._control1.times( -6 ) ).plus( this._control2.times( 3 ) );\r\n      var c = this._start.times( -3 ).plus( this._control1.times( 3 ) );\r\n\r\n      var aPerp = a.perpendicular();\r\n      var bPerp = b.perpendicular();\r\n      var aPerpDotB = aPerp.dot( b );\r\n\r\n      this._tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB );\r\n      this._tDeterminant = this._tCusp * this._tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB );\r\n      if ( this._tDeterminant >= 0 ) {\r\n        var sqrtDet = Math.sqrt( this._tDeterminant );\r\n        this._tInflection1 = this._tCusp - sqrtDet;\r\n        this._tInflection2 = this._tCusp + sqrtDet;\r\n      }\r\n      else {\r\n        this._tInflection1 = null;\r\n        this._tInflection2 = null;\r\n      }\r\n    },\r\n\r\n    // the cusp allows us to split into 2 quadratic Bezier curves\r\n    computeCuspSegments: function() {\r\n      if ( this.hasCusp() ) {\r\n        // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.\r\n        // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)\r\n        var subdividedAtCusp = this.subdivided( this.getTCusp );\r\n        this._startQuadratic = new Segment.Quadratic( subdividedAtCusp[ 0 ].start, subdividedAtCusp[ 0 ].control1, subdividedAtCusp[ 0 ].end, false );\r\n        this._endQuadratic = new Segment.Quadratic( subdividedAtCusp[ 1 ].start, subdividedAtCusp[ 1 ].control2, subdividedAtCusp[ 1 ].end, false );\r\n      }\r\n      else {\r\n        this._startQuadratic = null;\r\n        this._endQuadratic = null;\r\n      }\r\n    },\r\n\r\n    getNondegenerateSegments: function() {\r\n      var start = this._start;\r\n      var control1 = this._control1;\r\n      var control2 = this._control2;\r\n      var end = this._end;\r\n\r\n      var reduced = this.degreeReduced( 1e-9 );\r\n\r\n      if ( start.equals( end ) && start.equals( control1 ) && start.equals( control2 ) ) {\r\n        // degenerate point\r\n        return [];\r\n      }\r\n      else if ( this.hasCusp() ) {\r\n        return _.flatten( [\r\n          this._startQuadratic.getNondegenerateSegments(),\r\n          this._endQuadratic.getNondegenerateSegments()\r\n        ] );\r\n      }\r\n      else if ( reduced ) {\r\n        // if we can reduce to a quadratic Bezier, always do this (and make sure it is non-degenerate)\r\n        return reduced.getNondegenerateSegments();\r\n      }\r\n      else if ( arePointsCollinear( start, control1, end ) && arePointsCollinear( start, control2, end ) ) {\r\n        throw new Error( 'TODO, use extrema T funcs' );\r\n      }\r\n      else {\r\n        return [ this ];\r\n      }\r\n    },\r\n\r\n    hasCusp: function() {\r\n      var tCusp = this.getTCusp();\r\n\r\n      var epsilon = 1e-7; // TODO: make this available to change?\r\n      return this.tangentAt( tCusp ).magnitude() < epsilon && tCusp >= 0 && tCusp <= 1;\r\n    },\r\n\r\n    // position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end\r\n    positionAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this._start.times( mt * mt * mt ).plus( this._control1.times( 3 * mt * mt * t ) ).plus( this._control2.times( 3 * mt * t * t ) ).plus( this._end.times( t * t * t ) );\r\n    },\r\n\r\n    // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2\r\n    tangentAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this._start.times( -3 * mt * mt ).plus( this._control1.times( 3 * mt * mt - 6 * mt * t ) ).plus( this._control2.times( 6 * mt * t - 3 * t * t ) ).plus( this._end.times( 3 * t * t ) );\r\n    },\r\n\r\n    curvatureAt: function( t ) {\r\n      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31\r\n      // TODO: remove code duplication with Quadratic\r\n      var epsilon = 0.0000001;\r\n      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {\r\n        var isZero = t < 0.5;\r\n        var p0 = isZero ? this._start : this._end;\r\n        var p1 = isZero ? this._control1 : this._control2;\r\n        var p2 = isZero ? this._control2 : this._control1;\r\n        var d10 = p1.minus( p0 );\r\n        var a = d10.magnitude();\r\n        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );\r\n        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );\r\n      }\r\n      else {\r\n        return this.subdivided( t )[ 0 ].curvatureAt( 1 );\r\n      }\r\n    },\r\n\r\n    toRS: function( point ) {\r\n      var firstVector = point.minus( this._start );\r\n      return new Vector2( firstVector.dot( this.getR() ), firstVector.dot( this.getS() ) );\r\n    },\r\n\r\n    subdivided: function( t ) {\r\n      // de Casteljau method\r\n      // TODO: add a 'bisect' or 'between' method for vectors?\r\n      var left = this._start.blend( this._control1, t );\r\n      var right = this._control2.blend( this._end, t );\r\n      var middle = this._control1.blend( this._control2, t );\r\n      var leftMid = left.blend( middle, t );\r\n      var rightMid = middle.blend( right, t );\r\n      var mid = leftMid.blend( rightMid, t );\r\n      return [\r\n        new Segment.Cubic( this._start, left, leftMid, mid ),\r\n        new Segment.Cubic( mid, rightMid, right, this._end )\r\n      ];\r\n    },\r\n\r\n    offsetTo: function( r, reverse ) {\r\n      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html\r\n      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n\r\n      // how many segments to create (possibly make this more adaptive?)\r\n      var quantity = 32;\r\n\r\n      var points = [];\r\n      var result = [];\r\n      for ( var i = 0; i < quantity; i++ ) {\r\n        var t = i / ( quantity - 1 );\r\n        if ( reverse ) {\r\n          t = 1 - t;\r\n        }\r\n\r\n        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );\r\n        if ( i > 0 ) {\r\n          result.push( new Segment.Line( points[ i - 1 ], points[ i ] ) );\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    getSVGPathFragment: function() {\r\n      return 'C ' + kite.svgNumber( this._control1.x ) + ' ' + kite.svgNumber( this._control1.y ) + ' ' +\r\n             kite.svgNumber( this._control2.x ) + ' ' + kite.svgNumber( this._control2.y ) + ' ' +\r\n             kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );\r\n    },\r\n\r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n\r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n\r\n    getInteriorExtremaTs: function() {\r\n      var ts = this.getXExtremaT().concat( this.getYExtremaT() );\r\n      var result = [];\r\n      _.each( ts, function( t ) {\r\n        var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n        if ( t > epsilon && t < 1 - epsilon ) {\r\n          // don't add duplicate t values\r\n          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort();\r\n    },\r\n\r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Cubic.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n\r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    intersection: function( ray ) {\r\n      var self = this;\r\n      var result = [];\r\n\r\n      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );\r\n\r\n      var p0 = inverseMatrix.timesVector2( this._start );\r\n      var p1 = inverseMatrix.timesVector2( this._control1 );\r\n      var p2 = inverseMatrix.timesVector2( this._control2 );\r\n      var p3 = inverseMatrix.timesVector2( this._end );\r\n\r\n      // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3\r\n      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;\r\n      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;\r\n      var c = -3 * p0.y + 3 * p1.y;\r\n      var d = p0.y;\r\n\r\n      var ts = solveCubicRootsReal( a, b, c, d );\r\n\r\n      _.each( ts, function( t ) {\r\n        if ( t >= 0 && t <= 1 ) {\r\n          var hitPoint = self.positionAt( t );\r\n          var unitTangent = self.tangentAt( t ).normalized();\r\n          var perp = unitTangent.perpendicular();\r\n          var toHit = hitPoint.minus( ray.pos );\r\n\r\n          // make sure it's not behind the ray\r\n          if ( toHit.dot( ray.dir ) > 0 ) {\r\n            result.push( {\r\n              distance: toHit.magnitude(),\r\n              point: hitPoint,\r\n              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return result;\r\n    },\r\n\r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n\r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.bezierCurveTo( this._control1.x, this._control1.y, this._control2.x, this._control2.y, this._end.x, this._end.y );\r\n    },\r\n\r\n    transformed: function( matrix ) {\r\n      return new Segment.Cubic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control1 ), matrix.timesVector2( this._control2 ), matrix.timesVector2( this._end ) );\r\n    },\r\n\r\n    // returns a degree-reduced quadratic Bezier if possible, otherwise it returns null\r\n    degreeReduced: function( epsilon ) {\r\n      epsilon = epsilon || 0; // if not provided, use an exact version\r\n      // TODO: allocation reduction\r\n      // TODO: performance: don't divide both by 2 here, combine it later!!\r\n      var controlA = this._control1.timesScalar( 3 ).minus( this._start ).dividedScalar( 2 );\r\n      var controlB = this._control2.timesScalar( 3 ).minus( this._end ).dividedScalar( 2 );\r\n      if ( controlA.minus( controlB ).magnitude() <= epsilon ) {\r\n        return new Segment.Quadratic(\r\n          this._start,\r\n          controlA.average( controlB ), // average the control points for stability. they should be almost identical\r\n          this._end\r\n        );\r\n      }\r\n      else {\r\n        // the two options for control points are too far away, this curve isn't easily reducible.\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    // windingIntersection: function( ray ) {\r\n    //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n    //   var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() );\r\n    //   assert && assert( inverseMatrix.timesVector2( ray.dir ).x > 0.99 ); // verify that we transform the unit vector to the x-unit\r\n\r\n    //   var y0 = inverseMatrix.timesVector2( this._start ).y;\r\n    //   var y1 = inverseMatrix.timesVector2( this._control1 ).y;\r\n    //   var y2 = inverseMatrix.timesVector2( this._control2 ).y;\r\n    //   var y3 = inverseMatrix.timesVector2( this._end ).y;\r\n\r\n    //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3\r\n    //   var a = -y0 + 3 * y1 - 3 * y2 + y3;\r\n    //   var b = 3 * y0 - 6 * y1 + 3 * y2;\r\n    //   var c = -3 * y0 + 3 * y1;\r\n    //   var d = y0;\r\n\r\n    //   // solve cubic roots\r\n    //   var ts = solveCubicRootsReal( a, b, c, d );\r\n\r\n    //   var result = 0;\r\n\r\n    //   // for each hit\r\n    //   _.each( ts, function( t ) {\r\n    //     if ( t >= 0 && t <= 1 ) {\r\n    //       result += ray.dir.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;\r\n    //     }\r\n    //   } );\r\n\r\n    //   return result;\r\n    // }\r\n  } );\r\n\r\n  // finds what t values the cubic extrema are at (if any). This is just the 1-dimensional case, used for multiple purposes\r\n  Segment.Cubic.extremaT = function( v0, v1, v2, v3 ) {\r\n    // coefficients of derivative\r\n    var a = -3 * v0 + 9 * v1 - 9 * v2 + 3 * v3;\r\n    var b = 6 * v0 - 12 * v1 + 6 * v2;\r\n    var c = -3 * v0 + 3 * v1;\r\n\r\n    return solveQuadraticRootsReal( a, b, c );\r\n  };\r\n\r\n  return Segment.Cubic;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Forward and inverse transforms with 3x3 matrices\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Transform3',['require','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  require( 'DOT/Matrix3' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Ray2' );\r\n\r\n  // takes a 4x4 matrix\r\n  dot.Transform3 = function Transform3( matrix ) {\r\n    this.listeners = [];\r\n\r\n    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices\r\n    this.setMatrix( matrix === undefined ? dot.Matrix3.IDENTITY : matrix );\r\n\r\n    phetAllocation && phetAllocation( 'Transform3' );\r\n  };\r\n  var Transform3 = dot.Transform3;\r\n\r\n  Transform3.prototype = {\r\n    constructor: Transform3,\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * mutators\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    setMatrix: function( matrix ) {\r\n      // TODO: performance: don't notify or handle instances where the matrix is detected to be the identity matrix?\r\n      assert && assert( matrix instanceof dot.Matrix3 );\r\n\r\n      assert && assert( matrix.isFinite(), 'Matrix was suspicious' );\r\n\r\n      //Temporary solution: if the programmer tried to set the top, bottom, etc of a node without defined bounds, do a no-op\r\n      //In the future, this should be replaced with the assertion above, once we have tested that everything is working properly\r\n      if ( !matrix.isFinite() ) {\r\n        return;\r\n      }\r\n\r\n      var oldMatrix = this.matrix;\r\n      var length = this.listeners.length;\r\n      var i;\r\n\r\n      // notify listeners before the change\r\n      for ( i = 0; i < length; i++ ) {\r\n        this.listeners[ i ].before( matrix, oldMatrix );\r\n      }\r\n\r\n      this.matrix = matrix;\r\n\r\n      // compute these lazily\r\n      this.inverse = null;\r\n      this.matrixTransposed = null;\r\n      this.inverseTransposed = null;\r\n\r\n      // notify listeners after the change\r\n      for ( i = 0; i < length; i++ ) {\r\n        this.listeners[ i ].after( matrix, oldMatrix );\r\n      }\r\n    },\r\n\r\n    prepend: function( matrix ) {\r\n      this.setMatrix( matrix.timesMatrix( this.matrix ) );\r\n    },\r\n\r\n    //Simpler case of prepending a translation without having to allocate a matrix for it, see scenery#119\r\n    prependTranslation: function( x, y ) {\r\n      this.setMatrix( dot.Matrix3.translationTimesMatrix( x, y, this.matrix ) );\r\n    },\r\n\r\n    append: function( matrix ) {\r\n      this.setMatrix( this.matrix.timesMatrix( matrix ) );\r\n    },\r\n\r\n    prependTransform: function( transform ) {\r\n      this.prepend( transform.matrix );\r\n    },\r\n\r\n    appendTransform: function( transform ) {\r\n      this.append( transform.matrix );\r\n    },\r\n\r\n    applyToCanvasContext: function( context ) {\r\n      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * getters\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // uses the same matrices, for use cases where the matrices are considered immutable\r\n    copy: function() {\r\n      var transform = new Transform3( this.matrix );\r\n      transform.inverse = this.inverse;\r\n      transform.matrixTransposed = this.matrixTransposed;\r\n      transform.inverseTransposed = this.inverseTransposed;\r\n    },\r\n\r\n    // copies matrices, for use cases where the matrices are considered mutable\r\n    deepCopy: function() {\r\n      var transform = new Transform3( this.matrix.copy() );\r\n      transform.inverse = this.inverse ? this.inverse.copy() : null;\r\n      transform.matrixTransposed = this.matrixTransposed ? this.matrixTransposed.copy() : null;\r\n      transform.inverseTransposed = this.inverseTransposed ? this.inverseTransposed.copy() : null;\r\n    },\r\n\r\n    getMatrix: function() {\r\n      return this.matrix;\r\n    },\r\n\r\n    getInverse: function() {\r\n      if ( this.inverse === null ) {\r\n        this.inverse = this.matrix.inverted();\r\n      }\r\n      return this.inverse;\r\n    },\r\n\r\n    getMatrixTransposed: function() {\r\n      if ( this.matrixTransposed === null ) {\r\n        this.matrixTransposed = this.matrix.transposed();\r\n      }\r\n      return this.matrixTransposed;\r\n    },\r\n\r\n    getInverseTransposed: function() {\r\n      if ( this.inverseTransposed === null ) {\r\n        this.inverseTransposed = this.getInverse().transposed();\r\n      }\r\n      return this.inverseTransposed;\r\n    },\r\n\r\n    isIdentity: function() {\r\n      return this.matrix.type === dot.Matrix3.Types.IDENTITY;\r\n    },\r\n\r\n    isFinite: function() {\r\n      return this.matrix.isFinite();\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * forward transforms (for Vector2 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // transform a position (includes translation)\r\n    transformPosition2: function( vec2 ) {\r\n      return this.matrix.timesVector2( vec2 );\r\n    },\r\n\r\n    // transform a vector (exclude translation)\r\n    transformDelta2: function( vec2 ) {\r\n      var m = this.getMatrix();\r\n      // m . vec2 - m . Vector2.ZERO\r\n      return new dot.Vector2( m.m00() * vec2.x + m.m01() * vec2.y, m.m10() * vec2.x + m.m11() * vec2.y );\r\n    },\r\n\r\n    // transform a normal vector (different than a normal vector)\r\n    transformNormal2: function( vec2 ) {\r\n      return this.getInverse().timesTransposeVector2( vec2 );\r\n    },\r\n\r\n    transformX: function( x ) {\r\n      var m = this.getMatrix();\r\n      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );\r\n      return m.m00() * x + m.m02();\r\n    },\r\n\r\n    transformY: function( y ) {\r\n      var m = this.getMatrix();\r\n      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );\r\n      return m.m11() * y + m.m12();\r\n    },\r\n\r\n    transformDeltaX: function( x ) {\r\n      var m = this.getMatrix();\r\n      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );\r\n      // same as this.transformDelta2( new dot.Vector2( x, 0 ) ).x;\r\n      return m.m00() * x;\r\n    },\r\n\r\n    transformDeltaY: function( y ) {\r\n      var m = this.getMatrix();\r\n      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );\r\n      // same as this.transformDelta2( new dot.Vector2( 0, y ) ).y;\r\n      return m.m11() * y;\r\n    },\r\n\r\n    transformBounds2: function( bounds2 ) {\r\n      return bounds2.transformed( this.matrix );\r\n    },\r\n\r\n    transformShape: function( shape ) {\r\n      return shape.transformed( this.matrix );\r\n    },\r\n\r\n    transformRay2: function( ray ) {\r\n      return new dot.Ray2( this.transformPosition2( ray.pos ), this.transformDelta2( ray.dir ).normalized() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * inverse transforms (for Vector2 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    inversePosition2: function( vec2 ) {\r\n      return this.getInverse().timesVector2( vec2 );\r\n    },\r\n\r\n    inverseDelta2: function( vec2 ) {\r\n      var m = this.getInverse();\r\n      // m . vec2 - m . Vector2.ZERO\r\n      return new dot.Vector2( m.m00() * vec2.x + m.m01() * vec2.y, m.m10() * vec2.x + m.m11() * vec2.y );\r\n    },\r\n\r\n    inverseNormal2: function( vec2 ) {\r\n      return this.matrix.timesTransposeVector2( vec2 );\r\n    },\r\n\r\n    inverseX: function( x ) {\r\n      var m = this.getInverse();\r\n      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );\r\n      return m.m00() * x + m.m02();\r\n    },\r\n\r\n    inverseY: function( y ) {\r\n      var m = this.getInverse();\r\n      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );\r\n      return m.m11() * y + m.m12();\r\n    },\r\n\r\n    inverseDeltaX: function( x ) {\r\n      var m = this.getInverse();\r\n      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );\r\n      // same as this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;\r\n      return m.m00() * x;\r\n    },\r\n\r\n    inverseDeltaY: function( y ) {\r\n      var m = this.getInverse();\r\n      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );\r\n      // same as this.inverseDelta2( new dot.Vector2( 0, y ) ).y;\r\n      return m.m11() * y;\r\n    },\r\n\r\n    inverseBounds2: function( bounds2 ) {\r\n      return bounds2.transformed( this.getInverse() );\r\n    },\r\n\r\n    inverseShape: function( shape ) {\r\n      return shape.transformed( this.getInverse() );\r\n    },\r\n\r\n    inverseRay2: function( ray ) {\r\n      return new dot.Ray2( this.inversePosition2( ray.pos ), this.inverseDelta2( ray.dir ).normalized() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * listeners\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // note: listener.before( matrix, oldMatrix ) will be called before the change, listener.after( matrix, oldMatrix ) will be called after\r\n    addTransformListener: function( listener ) {\r\n      assert && assert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.push( listener );\r\n    },\r\n\r\n    // useful for making sure the listener is triggered first\r\n    prependTransformListener: function( listener ) {\r\n      assert && assert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.unshift( listener );\r\n    },\r\n\r\n    removeTransformListener: function( listener ) {\r\n      assert && assert( _.contains( this.listeners, listener ) );\r\n      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );\r\n    }\r\n  };\r\n\r\n  return Transform3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Elliptical arc segment\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/segments/EllipticalArc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Subpath'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var toDegrees = require( 'DOT/Util' ).toDegrees;\r\n  var DotUtil = require( 'DOT/Util' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n  require( 'KITE/util/Subpath' );\r\n\r\n  // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n  // Canvas notes were at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse\r\n  // context.ellipse was removed from the Canvas spec\r\n  Segment.EllipticalArc = function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n    if ( radiusX < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radiusX = -radiusX;\r\n      startAngle = Math.PI - startAngle;\r\n      endAngle = Math.PI - endAngle;\r\n      anticlockwise = !anticlockwise;\r\n    }\r\n    if ( radiusY < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radiusY = -radiusY;\r\n      startAngle = -startAngle;\r\n      endAngle = -endAngle;\r\n      anticlockwise = !anticlockwise;\r\n    }\r\n    if ( radiusX < radiusY ) {\r\n      // swap radiusX and radiusY internally for consistent Canvas / SVG output\r\n      rotation += Math.PI / 2;\r\n      startAngle -= Math.PI / 2;\r\n      endAngle -= Math.PI / 2;\r\n\r\n      // swap radiusX and radiusY\r\n      var tmpR = radiusX;\r\n      radiusX = radiusY;\r\n      radiusY = tmpR;\r\n    }\r\n\r\n    this._center = center;\r\n    this._radiusX = radiusX;\r\n    this._radiusY = radiusY;\r\n    this._rotation = rotation;\r\n    this._startAngle = startAngle;\r\n    this._endAngle = endAngle;\r\n    this._anticlockwise = anticlockwise;\r\n\r\n    // TODO: performance test removal of these undefined declarations\r\n    this._unitTransform = undefined;\r\n    this._start = undefined;\r\n    this._end = undefined;\r\n    this._startTangent = undefined;\r\n    this._endTangent = undefined;\r\n    this._actualEndAngle = undefined;\r\n    this._isFullPerimeter = undefined;\r\n    this._angleDifference = undefined;\r\n    this._unitArcSegment = undefined;\r\n\r\n    if ( radiusX < radiusY ) {\r\n      // TODO: check this\r\n      throw new Error( 'Not verified to work if radiusX < radiusY' );\r\n    }\r\n\r\n    // constraints shared with Segment.Arc\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );\r\n  };\r\n  inherit( Segment, Segment.EllipticalArc, {\r\n\r\n    getCenter: function() {\r\n      return this._center;\r\n    },\r\n    get center() { return this.getCenter(); },\r\n\r\n    getRadiusX: function() {\r\n      return this._radiusX;\r\n    },\r\n    get radiusX() { return this.getRadiusX(); },\r\n\r\n    getRadiusY: function() {\r\n      return this._radiusY;\r\n    },\r\n    get radiusY() { return this.getRadiusY(); },\r\n\r\n    getRotation: function() {\r\n      return this._rotation;\r\n    },\r\n    get rotation() { return this.getRotation(); },\r\n\r\n    getStartAngle: function() {\r\n      return this._startAngle;\r\n    },\r\n    get startAngle() { return this.getStartAngle(); },\r\n\r\n    getEndAngle: function() {\r\n      return this._endAngle;\r\n    },\r\n    get endAngle() { return this.getEndAngle(); },\r\n\r\n    getAnticlockwise: function() {\r\n      return this._anticlockwise;\r\n    },\r\n    get anticlockwise() { return this.getAnticlockwise(); },\r\n\r\n    getUnitTransform: function() {\r\n      if ( this._unitTransform === undefined ) {\r\n        this._unitTransform = Segment.EllipticalArc.computeUnitTransform( this._center, this._radiusX, this._radiusY, this._rotation );\r\n      }\r\n      return this._unitTransform;\r\n    },\r\n    get unitTransform() { return this.getUnitTransform(); },\r\n\r\n    getStart: function() {\r\n      if ( this._start === undefined ) {\r\n        this._start = this.positionAtAngle( this._startAngle );\r\n      }\r\n      return this._start;\r\n    },\r\n    get start() { return this.getStart(); },\r\n\r\n    getEnd: function() {\r\n      if ( this._end === undefined ) {\r\n        this._end = this.positionAtAngle( this._endAngle );\r\n      }\r\n      return this._end;\r\n    },\r\n    get end() { return this.getEnd(); },\r\n\r\n    getStartTangent: function() {\r\n      if ( this._startTangent === undefined ) {\r\n        this._startTangent = this.tangentAtAngle( this._startAngle );\r\n      }\r\n      return this._startTangent;\r\n    },\r\n    get startTangent() { return this.getStartTangent(); },\r\n\r\n    getEndTangent: function() {\r\n      if ( this._endTangent === undefined ) {\r\n        this._endTangent = this.tangentAtAngle( this._endAngle );\r\n      }\r\n      return this._endTangent;\r\n    },\r\n    get endTangent() { return this.getEndTangent(); },\r\n\r\n    getActualEndAngle: function() {\r\n      if ( this._actualEndAngle === undefined ) {\r\n        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle\r\n        if ( this._anticlockwise ) {\r\n          // angle is 'decreasing'\r\n          // -2pi <= end - start < 2pi\r\n          if ( this._startAngle > this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle;\r\n          }\r\n          else if ( this._startAngle < this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle - 2 * Math.PI;\r\n          }\r\n          else {\r\n            // equal\r\n            this._actualEndAngle = this._startAngle;\r\n          }\r\n        }\r\n        else {\r\n          // angle is 'increasing'\r\n          // -2pi < end - start <= 2pi\r\n          if ( this._startAngle < this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle;\r\n          }\r\n          else if ( this._startAngle > this._endAngle ) {\r\n            this._actualEndAngle = this._endAngle + Math.PI * 2;\r\n          }\r\n          else {\r\n            // equal\r\n            this._actualEndAngle = this._startAngle;\r\n          }\r\n        }\r\n      }\r\n      return this._actualEndAngle;\r\n    },\r\n    get actualEndAngle() { return this.getActualEndAngle(); },\r\n\r\n    getIsFullPerimeter: function() {\r\n      if ( this._isFullPerimeter === undefined ) {\r\n        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );\r\n      }\r\n      return this._isFullPerimeter;\r\n    },\r\n    get isFullPerimeter() { return this.getIsFullPerimeter(); },\r\n\r\n    getAngleDifference: function() {\r\n      if ( this._angleDifference === undefined ) {\r\n        // compute an angle difference that represents how \"much\" of the circle our arc covers\r\n        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;\r\n        if ( this._angleDifference < 0 ) {\r\n          this._angleDifference += Math.PI * 2;\r\n        }\r\n        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive\r\n      }\r\n      return this._angleDifference;\r\n    },\r\n    get angleDifference() { return this.getAngleDifference(); },\r\n\r\n    // a unit arg segment that we can map to our ellipse. useful for hit testing and such.\r\n    getUnitArcSegment: function() {\r\n      if ( this._unitArcSegment === undefined ) {\r\n        this._unitArcSegment = new Segment.Arc( Vector2.ZERO, 1, this._startAngle, this._endAngle, this._anticlockwise );\r\n      }\r\n      return this._unitArcSegment;\r\n    },\r\n\r\n    // temporary shims\r\n    getBounds: function() {\r\n      if ( this._bounds === undefined ) {\r\n        this._bounds = Bounds2.NOTHING.withPoint( this.getStart() )\r\n          .withPoint( this.getEnd() );\r\n\r\n        // if the angles are different, check extrema points\r\n        if ( this._startAngle !== this._endAngle ) {\r\n          // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.\r\n          // we find one extrema point for both x and y, since the other two are just rotated by pi from them.\r\n          var xAngle = Math.atan( -( this._radiusY / this._radiusX ) * Math.tan( this._rotation ) );\r\n          var yAngle = Math.atan( ( this._radiusY / this._radiusX ) / Math.tan( this._rotation ) );\r\n\r\n          // check all of the extrema points\r\n          this.possibleExtremaAngles = [\r\n            xAngle,\r\n            xAngle + Math.PI,\r\n            yAngle,\r\n            yAngle + Math.PI\r\n          ];\r\n\r\n          _.each( this.possibleExtremaAngles, this.includeBoundsAtAngle.bind( this ) );\r\n        }\r\n      }\r\n      return this._bounds;\r\n    },\r\n    get bounds() { return this.getBounds(); },\r\n\r\n    getNondegenerateSegments: function() {\r\n      if ( this._radiusX <= 0 || this._radiusY <= 0 || this._startAngle === this._endAngle ) {\r\n        return [];\r\n      }\r\n      else if ( this._radiusX === this._radiusY ) {\r\n        // reduce to an Arc\r\n        var startAngle = this._startAngle - this._rotation;\r\n        var endAngle = this._endAngle - this._rotation;\r\n\r\n        // preserve full circles\r\n        if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {\r\n          endAngle = this._anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;\r\n        }\r\n        return [ new Segment.Arc( this._center, this._radiusX, startAngle, endAngle, this._anticlockwise ) ];\r\n      }\r\n      else {\r\n        return [ this ];\r\n      }\r\n    },\r\n\r\n    includeBoundsAtAngle: function( angle ) {\r\n      if ( this.containsAngle( angle ) ) {\r\n        // the boundary point is in the arc\r\n        this._bounds = this._bounds.withPoint( this.positionAtAngle( angle ) );\r\n      }\r\n    },\r\n\r\n    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.\r\n    mapAngle: function( angle ) {\r\n      // consider an assert that we contain that angle?\r\n      return ( this._startAngle > this.getActualEndAngle() ) ?\r\n             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :\r\n             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );\r\n    },\r\n\r\n    tAtAngle: function( angle ) {\r\n      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );\r\n    },\r\n\r\n    angleAt: function( t ) {\r\n      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;\r\n    },\r\n\r\n    positionAt: function( t ) {\r\n      return this.positionAtAngle( this.angleAt( t ) );\r\n    },\r\n\r\n    tangentAt: function( t ) {\r\n      return this.tangentAtAngle( this.angleAt( t ) );\r\n    },\r\n\r\n    curvatureAt: function( t ) {\r\n      // see http://mathworld.wolfram.com/Ellipse.html (59)\r\n      var angle = this.angleAt( t );\r\n      var aq = this._radiusX * Math.sin( angle );\r\n      var bq = this._radiusY * Math.cos( angle );\r\n      var denominator = Math.pow( bq * bq + aq * aq, 3 / 2 );\r\n      return ( this._anticlockwise ? -1 : 1 ) * this._radiusX * this._radiusY / denominator;\r\n    },\r\n\r\n    positionAtAngle: function( angle ) {\r\n      return this.getUnitTransform().transformPosition2( Vector2.createPolar( 1, angle ) );\r\n    },\r\n\r\n    tangentAtAngle: function( angle ) {\r\n      var normal = this.getUnitTransform().transformNormal2( Vector2.createPolar( 1, angle ) );\r\n\r\n      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();\r\n    },\r\n\r\n    // TODO: refactor? exact same as Segment.Arc\r\n    containsAngle: function( angle ) {\r\n      // transform the angle into the appropriate coordinate form\r\n      // TODO: check anticlockwise version!\r\n      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;\r\n\r\n      // get the angle between 0 and 2pi\r\n      var positiveMinAngle = normalizedAngle % ( Math.PI * 2 );\r\n      // check this because modular arithmetic with negative numbers reveal a negative number\r\n      if ( positiveMinAngle < 0 ) {\r\n        positiveMinAngle += Math.PI * 2;\r\n      }\r\n\r\n      return positiveMinAngle <= this.getAngleDifference();\r\n    },\r\n\r\n    // discretizes the elliptical arc and returns an offset curve as a list of lineTos\r\n    offsetTo: function( r, reverse ) {\r\n      // how many segments to create (possibly make this more adaptive?)\r\n      var quantity = 32;\r\n\r\n      var points = [];\r\n      var result = [];\r\n      for ( var i = 0; i < quantity; i++ ) {\r\n        var ratio = i / ( quantity - 1 );\r\n        if ( reverse ) {\r\n          ratio = 1 - ratio;\r\n        }\r\n        var angle = this.angleAt( ratio );\r\n\r\n        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );\r\n        if ( i > 0 ) {\r\n          result.push( new Segment.Line( points[ i - 1 ], points[ i ] ) );\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    getSVGPathFragment: function() {\r\n      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info\r\n      // rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'\r\n      var sweepFlag = this._anticlockwise ? '0' : '1';\r\n      var largeArcFlag;\r\n      var degreesRotation = toDegrees( this._rotation ); // bleh, degrees?\r\n      if ( this.getAngleDifference() < Math.PI * 2 - epsilon ) {\r\n        largeArcFlag = this.getAngleDifference() < Math.PI ? '0' : '1';\r\n        return 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' + degreesRotation +\r\n               ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );\r\n      }\r\n      else {\r\n        // ellipse (or almost-ellipse) case needs to be handled differently\r\n        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs\r\n\r\n        // get the angle that is between and opposite of both of the points\r\n        var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?\r\n        var splitPoint = this.positionAtAngle( splitOppositeAngle );\r\n\r\n        largeArcFlag = '0'; // since we split it in 2, it's always the small arc\r\n\r\n        var firstArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +\r\n                       degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +\r\n                       kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );\r\n        var secondArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +\r\n                        degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +\r\n                        kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );\r\n\r\n        return firstArc + ' ' + secondArc;\r\n      }\r\n    },\r\n\r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n\r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n\r\n    // not including 0 and 1\r\n    getInteriorExtremaTs: function() {\r\n      var that = this;\r\n      var result = [];\r\n      _.each( this.possibleExtremaAngles, function( angle ) {\r\n        if ( that.containsAngle( angle ) ) {\r\n          var t = that.tAtAngle( angle );\r\n          var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n          if ( t > epsilon && t < 1 - epsilon ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort(); // modifies original, which is OK\r\n    },\r\n\r\n    subdivided: function( t ) {\r\n      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles\r\n      var angle0 = this.angleAt( 0 );\r\n      var angleT = this.angleAt( t );\r\n      var angle1 = this.angleAt( 1 );\r\n      return [\r\n        new Segment.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angle0, angleT, this._anticlockwise ),\r\n        new Segment.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angleT, angle1, this._anticlockwise )\r\n      ];\r\n    },\r\n\r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.EllipticalArc.intersectsBounds unimplemented' );\r\n    },\r\n\r\n    intersection: function( ray ) {\r\n      // be lazy. transform it into the space of a non-elliptical arc.\r\n      var unitTransform = this.getUnitTransform();\r\n      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );\r\n      var hits = this.getUnitArcSegment().intersection( rayInUnitCircleSpace );\r\n\r\n      return _.map( hits, function( hit ) {\r\n        var transformedPoint = unitTransform.transformPosition2( hit.point );\r\n        return {\r\n          distance: ray.pos.distance( transformedPoint ),\r\n          point: transformedPoint,\r\n          normal: unitTransform.inverseNormal2( hit.normal ),\r\n          wind: hit.wind\r\n        };\r\n      } );\r\n    },\r\n\r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      // be lazy. transform it into the space of a non-elliptical arc.\r\n      var rayInUnitCircleSpace = this.getUnitTransform().inverseRay2( ray );\r\n      return this.getUnitArcSegment().windingIntersection( rayInUnitCircleSpace );\r\n    },\r\n\r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      if ( context.ellipse ) {\r\n        context.ellipse( this._center.x, this._center.y, this._radiusX, this._radiusY, this._rotation, this._startAngle, this._endAngle, this._anticlockwise );\r\n      }\r\n      else {\r\n        // fake the ellipse call by using transforms\r\n        this.getUnitTransform().getMatrix().canvasAppendTransform( context );\r\n        context.arc( 0, 0, 1, this._startAngle, this._endAngle, this._anticlockwise );\r\n        this.getUnitTransform().getInverse().canvasAppendTransform( context );\r\n      }\r\n    },\r\n\r\n    transformed: function( matrix ) {\r\n      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusX, this._rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );\r\n      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusY, this._rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );\r\n      var rotation = transformedSemiMajorAxis.angle();\r\n      var radiusX = transformedSemiMajorAxis.magnitude();\r\n      var radiusY = transformedSemiMinorAxis.magnitude();\r\n\r\n      var reflected = matrix.getDeterminant() < 0;\r\n\r\n      // reverse the 'clockwiseness' if our transform includes a reflection\r\n      // TODO: check reflections. swapping angle signs should fix clockwiseness\r\n      var anticlockwise = reflected ? !this._anticlockwise : this._anticlockwise;\r\n      var startAngle = reflected ? -this._startAngle : this._startAngle;\r\n      var endAngle = reflected ? -this._endAngle : this._endAngle;\r\n\r\n      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {\r\n        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;\r\n      }\r\n\r\n      return new Segment.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n    }\r\n  } );\r\n\r\n  // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n  // transforms the unit circle onto our ellipse\r\n  Segment.EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {\r\n    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this._center) when available\r\n      .timesMatrix( Matrix3.rotation2( rotation ) )\r\n      .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );\r\n  };\r\n\r\n  return Segment.EllipticalArc;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Shape handling\r\n *\r\n * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.\r\n * Familiarity with how Canvas handles subpaths is helpful for understanding this code.\r\n *\r\n * Canvas spec: http://www.w3.org/TR/2dcontext/\r\n * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html\r\n *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)\r\n * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html\r\n *\r\n * TODO: add nonzero / evenodd support when browsers support it\r\n * TODO: docs\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'KITE/Shape',['require','KITE/kite','DOT/Vector2','DOT/Bounds2','DOT/Ray2','KITE/util/Subpath','KITE/parser/svgPath','KITE/util/LineStyles','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n\r\n  var kite = require( 'KITE/kite' );\r\n\r\n  // TODO: clean up imports\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Ray2 = require( 'DOT/Ray2' );\r\n\r\n  var Subpath = require( 'KITE/util/Subpath' );\r\n\r\n  var svgPath = require( 'KITE/parser/svgPath' );\r\n  require( 'KITE/util/LineStyles' );\r\n  require( 'KITE/segments/Arc' );\r\n  require( 'KITE/segments/Cubic' );\r\n  require( 'KITE/segments/EllipticalArc' );\r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Quadratic' );\r\n\r\n  // for brevity\r\n  function p( x, y ) { return new Vector2( x, y ); }\r\n\r\n  function v( x, y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type\r\n\r\n  // a normalized vector for non-zero winding checks\r\n  // var weirdDir = p( Math.PI, 22 / 7 );\r\n\r\n  // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'\r\n  kite.Shape = function Shape( subpaths, bounds ) {\r\n    // lower-level piecewise mathematical description using segments, also individually immutable\r\n    this.subpaths = ( typeof subpaths === 'object' ) ? subpaths : [];\r\n    assert && assert( this.subpaths.length === 0 || this.subpaths[ 0 ].constructor.name !== 'Array' );\r\n\r\n    // computed bounds for all pieces added so far\r\n    this.bounds = ( bounds || Bounds2.NOTHING ).copy();\r\n\r\n    var that = this;\r\n    if ( subpaths && typeof subpaths !== 'object' ) {\r\n      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' );\r\n      // parse the SVG path\r\n      _.each( svgPath.parse( subpaths ), function( item ) {\r\n        assert && assert( Shape.prototype[ item.cmd ] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );\r\n        that[ item.cmd ].apply( that, item.args );\r\n      } );\r\n    }\r\n\r\n    this.resetControlPoints();\r\n\r\n    phetAllocation && phetAllocation( 'Shape' );\r\n  };\r\n  var Shape = kite.Shape;\r\n\r\n  Shape.prototype = {\r\n    constructor: Shape,\r\n\r\n    // for tracking the last quadratic/cubic control point for smooth* functions\r\n    // see https://github.com/phetsims/kite/issues/38\r\n    resetControlPoints: function() {\r\n      this.lastQuadraticControlPoint = null;\r\n      this.lastCubicControlPoint = null;\r\n    },\r\n    setQuadraticControlPoint: function( point ) {\r\n      this.lastQuadraticControlPoint = point;\r\n      this.lastCubicControlPoint = null;\r\n    },\r\n    setCubicControlPoint: function( point ) {\r\n      this.lastQuadraticControlPoint = null;\r\n      this.lastCubicControlPoint = point;\r\n    },\r\n\r\n    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },\r\n    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },\r\n    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },\r\n    moveToPoint: function( point ) {\r\n      this.addSubpath( new kite.Subpath().addPoint( point ) );\r\n      this.resetControlPoints();\r\n\r\n      return this;\r\n    },\r\n\r\n    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },\r\n    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },\r\n    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },\r\n    lineToPoint: function( point ) {\r\n      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-lineto\r\n      if ( this.hasSubpaths() ) {\r\n        var start = this.getLastSubpath().getLastPoint();\r\n        var end = point;\r\n        var line = new kite.Segment.Line( start, end );\r\n        this.getLastSubpath().addPoint( end );\r\n        this.addSegmentAndBounds( line );\r\n        assert && assert( !isNaN( this.bounds.getX() ) );\r\n      }\r\n      else {\r\n        this.ensure( point );\r\n      }\r\n      this.resetControlPoints();\r\n\r\n      return this;\r\n    },\r\n\r\n    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },\r\n    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },\r\n\r\n    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },\r\n    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },\r\n\r\n    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToPointRelative: function( controlPoint, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );\r\n    },\r\n    // TODO: consider a rename to put 'smooth' farther back?\r\n    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },\r\n    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    quadraticCurveToPoint: function( controlPoint, point ) {\r\n      var shape = this;\r\n\r\n      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-quadraticcurveto\r\n      this.ensure( controlPoint );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var quadratic = new kite.Segment.Quadratic( start, controlPoint, point );\r\n      this.getLastSubpath().addPoint( point );\r\n      var nondegenerateSegments = quadratic.getNondegenerateSegments();\r\n      _.each( nondegenerateSegments, function( segment ) {\r\n        // TODO: optimization\r\n        shape.addSegmentAndBounds( segment );\r\n      } );\r\n      this.setQuadraticControlPoint( controlPoint );\r\n\r\n      return this;\r\n    },\r\n\r\n    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToPointRelative: function( control1, control2, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );\r\n    },\r\n    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },\r\n    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    cubicCurveToPoint: function( control1, control2, point ) {\r\n      var shape = this;\r\n      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-quadraticcurveto\r\n      this.ensure( control1 );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var cubic = new kite.Segment.Cubic( start, control1, control2, point );\r\n\r\n      var nondegenerateSegments = cubic.getNondegenerateSegments();\r\n      _.each( nondegenerateSegments, function( segment ) {\r\n        shape.addSegmentAndBounds( segment );\r\n      } );\r\n      this.getLastSubpath().addPoint( point );\r\n\r\n      this.setCubicControlPoint( control2 );\r\n\r\n      return this;\r\n    },\r\n\r\n    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },\r\n    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-arc\r\n\r\n      var arc = new kite.Segment.Arc( center, radius, startAngle, endAngle, anticlockwise );\r\n\r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = arc.getStart();\r\n      var endPoint = arc.getEnd();\r\n\r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.addSegmentAndBounds( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n\r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n\r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n\r\n      this.addSegmentAndBounds( arc );\r\n      this.resetControlPoints();\r\n\r\n      return this;\r\n    },\r\n\r\n    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },\r\n    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-arc\r\n\r\n      var ellipticalArc = new kite.Segment.EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n\r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = ellipticalArc.start;\r\n      var endPoint = ellipticalArc.end;\r\n\r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.addSegmentAndBounds( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n\r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n\r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n\r\n      this.addSegmentAndBounds( ellipticalArc );\r\n      this.resetControlPoints();\r\n\r\n      return this;\r\n    },\r\n\r\n    close: function() {\r\n      if ( this.hasSubpaths() ) {\r\n        var previousPath = this.getLastSubpath();\r\n        var nextPath = new kite.Subpath();\r\n\r\n        previousPath.close();\r\n        this.addSubpath( nextPath );\r\n        nextPath.addPoint( previousPath.getFirstPoint() );\r\n      }\r\n      this.resetControlPoints();\r\n      return this;\r\n    },\r\n\r\n    // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html\r\n    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );\r\n    },\r\n    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      throw new Error( 'ellipticalArcTo unimplemented' );\r\n    },\r\n\r\n    /*\r\n     * Draws a circle using the arc() call with the following parameters:\r\n     * circle( center, radius ) // center is a Vector2\r\n     * circle( centerX, centerY, radius )\r\n     */\r\n    circle: function( centerX, centerY, radius ) {\r\n      if ( typeof centerX === 'object' ) {\r\n        // circle( center, radius )\r\n        var center = centerX;\r\n        radius = centerY;\r\n        return this.arcPoint( center, radius, 0, Math.PI * 2, false );\r\n      }\r\n      else {\r\n        // circle( centerX, centerY, radius )\r\n        return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n\r\n    /*\r\n     * Draws an ellipse using the ellipticalArc() call with the following parameters:\r\n     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2\r\n     * ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n     *\r\n     * The rotation is about the centerX, centerY.\r\n     */\r\n    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {\r\n      // TODO: separate into ellipse() and ellipsePoint()?\r\n      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n      if ( typeof centerX === 'object' ) {\r\n        // ellipse( center, radiusX, radiusY, rotation )\r\n        var center = centerX;\r\n        rotation = radiusY;\r\n        radiusY = radiusX;\r\n        radiusX = centerY;\r\n        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      }\r\n      else {\r\n        // ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n\r\n    rect: function( x, y, width, height ) {\r\n      var subpath = new kite.Subpath();\r\n      this.addSubpath( subpath );\r\n      subpath.addPoint( v( x, y ) );\r\n      subpath.addPoint( v( x + width, y ) );\r\n      subpath.addPoint( v( x + width, y + height ) );\r\n      subpath.addPoint( v( x, y + height ) );\r\n      this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[ 0 ], subpath.points[ 1 ] ) );\r\n      this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[ 1 ], subpath.points[ 2 ] ) );\r\n      this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[ 2 ], subpath.points[ 3 ] ) );\r\n      subpath.close();\r\n      this.addSubpath( new kite.Subpath() );\r\n      this.getLastSubpath().addPoint( v( x, y ) );\r\n      assert && assert( !isNaN( this.bounds.getX() ) );\r\n      this.resetControlPoints();\r\n\r\n      return this;\r\n    },\r\n\r\n    //Create a round rectangle. All arguments are number.\r\n    roundRect: function( x, y, width, height, arcw, arch ) {\r\n      var lowX = x + arcw;\r\n      var highX = x + width - arcw;\r\n      var lowY = y + arch;\r\n      var highY = y + height - arch;\r\n      // if ( true ) {\r\n      if ( arcw === arch ) {\r\n        // we can use circular arcs, which have well defined stroked offsets\r\n        this\r\n          .arc( highX, lowY, arcw, -Math.PI / 2, 0, false )\r\n          .arc( highX, highY, arcw, 0, Math.PI / 2, false )\r\n          .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )\r\n          .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )\r\n          .close();\r\n      }\r\n      else {\r\n        // we have to resort to elliptical arcs\r\n        this\r\n          .ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )\r\n          .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )\r\n          .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )\r\n          .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )\r\n          .close();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    polygon: function( vertices ) {\r\n      var length = vertices.length;\r\n      if ( length > 0 ) {\r\n        this.moveToPoint( vertices[ 0 ] );\r\n        for ( var i = 1; i < length; i++ ) {\r\n          this.lineToPoint( vertices[ i ] );\r\n        }\r\n      }\r\n      return this.close();\r\n    },\r\n\r\n    copy: function() {\r\n      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one\r\n      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );\r\n    },\r\n\r\n    // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!\r\n    writeToContext: function( context ) {\r\n      var len = this.subpaths.length;\r\n      for ( var i = 0; i < len; i++ ) {\r\n        this.subpaths[ i ].writeToContext( context );\r\n      }\r\n    },\r\n\r\n    // returns something like \"M150 0 L75 200 L225 200 Z\" for a triangle\r\n    getSVGPath: function() {\r\n      var subpathStrings = [];\r\n      var len = this.subpaths.length;\r\n      for ( var i = 0; i < len; i++ ) {\r\n        var subpath = this.subpaths[ i ];\r\n        if ( subpath.isDrawable() ) {\r\n          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point\r\n          var startPoint = subpath.getFirstSegment().start;\r\n          assert && assert( startPoint.equals( subpath.getFirstPoint(), 0.00001 ) ); // sanity check\r\n          var string = 'M ' + kite.svgNumber( startPoint.x ) + ' ' + kite.svgNumber( startPoint.y ) + ' ';\r\n\r\n          string += _.map( subpath.segments, function( segment ) { return segment.getSVGPathFragment(); } ).join( ' ' );\r\n\r\n          if ( subpath.isClosed() ) {\r\n            string += ' Z';\r\n          }\r\n          subpathStrings.push( string );\r\n        }\r\n      }\r\n      return subpathStrings.join( ' ' );\r\n    },\r\n\r\n    // return a new Shape that is transformed by the associated matrix\r\n    transformed: function( matrix ) {\r\n      // TODO: allocation reduction\r\n      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n\r\n    /*\r\n     * Provided options (see Segment.nonlinearTransformed)\r\n     * - minLevels:                       how many levels to force subdivisions\r\n     * - maxLevels:                       prevent subdivision past this level\r\n     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve. smaller => more subdivision\r\n     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments. smaller => more subdivision\r\n     * -   OR includeCurvature:           {Boolean}, whether to include a default curveEpsilon (usually off by default)\r\n     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied\r\n     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]\r\n     *                                    instead of using our brute-force logic. Supports optimizations for custom non-linear transforms (like polar coordinates)\r\n     */\r\n    nonlinearTransformed: function( options ) {\r\n      // defaults\r\n      options = _.extend( {\r\n        minLevels: 0,\r\n        maxLevels: 7,\r\n        distanceEpsilon: 0.16, // NOTE: this will change when the Shape is scaled, since this is a threshold for the square of a distance value\r\n        curveEpsilon: ( options && options.includeCurvature ) ? 0.002 : null\r\n      }, options );\r\n\r\n      // TODO: allocation reduction\r\n      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.nonlinearTransformed( options ); } );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n\r\n    /*\r\n     * Maps points by treating their x coordinate as polar angle, and y coordinate as polar magnitude.\r\n     * See http://en.wikipedia.org/wiki/Polar_coordinate_system\r\n     *\r\n     * Please see Shape.nonlinearTransformed for more documentation on adaptive discretization options (minLevels, maxLevels, distanceEpsilon, curveEpsilon)\r\n     *\r\n     * Example: A line from (0,10) to (pi,10) will be transformed to a circular arc from (10,0) to (-10,0) passing through (0,10).\r\n     */\r\n    polarToCartesian: function( options ) {\r\n      return this.nonlinearTransformed( _.extend( {\r\n        pointMap: function( p ) {\r\n          return Vector2.createPolar( p.y, p.x );\r\n          // return new Vector2( p.y * Math.cos( p.x ), p.y * Math.sin( p.x ) );\r\n        },\r\n        methodName: 'polarToCartesian' // this will be called on Segments if it exists to do more optimized conversion (see Line)\r\n      }, options ) );\r\n    },\r\n\r\n    /*\r\n     * Converts each segment into lines, using an adaptive (midpoint distance subdivision) method.\r\n     *\r\n     * NOTE: uses nonlinearTransformed method internally, but since we don't provide a pointMap or methodName, it won't create anything but line segments.\r\n     * See nonlinearTransformed for documentation of options\r\n     */\r\n    toPiecewiseLinear: function( options ) {\r\n      assert && assert( !options.pointMap, 'No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments' );\r\n      assert && assert( !options.methodName, 'No methodName for toPiecewiseLinear allowed, since it could create non-linear segments' );\r\n      return this.nonlinearTransformed( options );\r\n    },\r\n\r\n    // returns the bounds. if lineStyles exists, include the stroke in the bounds\r\n    // TODO: consider renaming to getBounds()? (yes, definitely rename)\r\n    computeBounds: function( lineStyles ) {\r\n      if ( lineStyles ) {\r\n        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );\r\n      }\r\n      else {\r\n        return this.bounds;\r\n      }\r\n    },\r\n\r\n    getBoundsWithTransform: function( matrix, lineStyles ) {\r\n      // if we don't need to handle rotation/shear, don't use the extra effort!\r\n      if ( matrix.isAxisAligned() ) {\r\n        return this.computeBounds( lineStyles );\r\n      }\r\n\r\n      var bounds = Bounds2.NOTHING.copy();\r\n\r\n      var numSubpaths = this.subpaths.length;\r\n      for ( var i = 0; i < numSubpaths; i++ ) {\r\n        var subpath = this.subpaths[ i ];\r\n        bounds.includeBounds( subpath.getBoundsWithTransform( matrix ) );\r\n      }\r\n\r\n      if ( lineStyles ) {\r\n        bounds.includeBounds( this.getStrokedShape( lineStyles ).getBoundsWithTransform( matrix ) );\r\n      }\r\n\r\n      return bounds;\r\n    },\r\n\r\n    containsPoint: function( point ) {\r\n      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape\r\n      var ray = new Ray2( point, Vector2.X_UNIT );\r\n\r\n      return this.windingIntersection( ray ) !== 0;\r\n    },\r\n\r\n    intersection: function( ray ) {\r\n      var hits = [];\r\n      var numSubpaths = this.subpaths.length;\r\n      for ( var i = 0; i < numSubpaths; i++ ) {\r\n        var subpath = this.subpaths[ i ];\r\n\r\n        if ( subpath.isDrawable() ) {\r\n          var numSegments = subpath.segments.length;\r\n          for ( var k = 0; k < numSegments; k++ ) {\r\n            var segment = subpath.segments[ k ];\r\n            hits = hits.concat( segment.intersection( ray ) );\r\n          }\r\n\r\n          if ( subpath.hasClosingSegment() ) {\r\n            hits = hits.concat( subpath.getClosingSegment().intersection( ray ) );\r\n          }\r\n        }\r\n      }\r\n      return _.sortBy( hits, function( hit ) { return hit.distance; } );\r\n    },\r\n\r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n\r\n      var numSubpaths = this.subpaths.length;\r\n      for ( var i = 0; i < numSubpaths; i++ ) {\r\n        var subpath = this.subpaths[ i ];\r\n\r\n        if ( subpath.isDrawable() ) {\r\n          var numSegments = subpath.segments.length;\r\n          for ( var k = 0; k < numSegments; k++ ) {\r\n            wind += subpath.segments[ k ].windingIntersection( ray );\r\n          }\r\n\r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            wind += subpath.getClosingSegment().windingIntersection( ray );\r\n          }\r\n        }\r\n      }\r\n\r\n      return wind;\r\n    },\r\n\r\n    intersectsBounds: function( bounds ) {\r\n      var numSubpaths = this.subpaths.length;\r\n      for ( var i = 0; i < numSubpaths; i++ ) {\r\n        var subpath = this.subpaths[ i ];\r\n\r\n        if ( subpath.isDrawable() ) {\r\n          var numSegments = subpath.segments.length;\r\n          for ( var k = 0; k < numSegments; k++ ) {\r\n            if ( subpath.segments[ k ].intersectsBounds( bounds ) ) {\r\n              return true;\r\n            }\r\n          }\r\n\r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            if ( subpath.getClosingSegment().intersectsBounds( bounds ) ) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n\r\n    // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)\r\n    // TODO: rename stroked( lineStyles )\r\n    getStrokedShape: function( lineStyles ) {\r\n      var subpaths = [];\r\n      var bounds = Bounds2.NOTHING.copy();\r\n      var subLen = this.subpaths.length;\r\n      for ( var i = 0; i < subLen; i++ ) {\r\n        var subpath = this.subpaths[ i ];\r\n        var strokedSubpath = subpath.stroked( lineStyles );\r\n        subpaths = subpaths.concat( strokedSubpath );\r\n      }\r\n      subLen = subpaths.length;\r\n      for ( i = 0; i < subLen; i++ ) {\r\n        bounds.includeBounds( subpaths[ i ].bounds );\r\n      }\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n\r\n    // {experimental!}\r\n    getOffsetShape: function( distance ) {\r\n      // TODO: abstract away this type of behavior\r\n      var subpaths = [];\r\n      var bounds = Bounds2.NOTHING.copy();\r\n      var subLen = this.subpaths.length;\r\n      for ( var i = 0; i < subLen; i++ ) {\r\n        subpaths.push( this.subpaths[ i ].offset( distance ) );\r\n      }\r\n      subLen = subpaths.length;\r\n      for ( i = 0; i < subLen; i++ ) {\r\n        bounds.includeBounds( subpaths[ i ].bounds );\r\n      }\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n\r\n    toString: function() {\r\n      // TODO: consider a more verbose but safer way?\r\n      return 'new kite.Shape( \\'' + this.getSVGPath() + '\\' )';\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Internal subpath computations\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    addSegmentAndBounds: function( segment ) {\r\n      this.getLastSubpath().addSegment( segment );\r\n      this.bounds = this.bounds.includeBounds( this.getLastSubpath().bounds );\r\n    },\r\n\r\n    ensure: function( point ) {\r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new Subpath() );\r\n        this.getLastSubpath().addPoint( point );\r\n      }\r\n    },\r\n\r\n    addSubpath: function( subpath ) {\r\n      this.subpaths.push( subpath );\r\n\r\n      return this; // allow chaining\r\n    },\r\n\r\n    hasSubpaths: function() {\r\n      return this.subpaths.length > 0;\r\n    },\r\n\r\n    getLastSubpath: function() {\r\n      return _.last( this.subpaths );\r\n    },\r\n\r\n    // gets the last point in the last subpath, or null if it doesn't exist\r\n    getLastPoint: function() {\r\n      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;\r\n    },\r\n\r\n    getLastSegment: function() {\r\n      if ( !this.hasSubpaths() ) { return null; }\r\n\r\n      var subpath = this.getLastSubpath();\r\n      if ( !subpath.isDrawable() ) { return null; }\r\n\r\n      return subpath.getLastSegment();\r\n    },\r\n\r\n    // returns the point to be used for smooth quadratic segments\r\n    getSmoothQuadraticControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n\r\n      if ( this.lastQuadraticControlPoint ) {\r\n        return lastPoint.plus( lastPoint.minus( this.lastQuadraticControlPoint ) );\r\n      }\r\n      else {\r\n        return lastPoint;\r\n      }\r\n    },\r\n\r\n    // returns the point to be used for smooth cubic segments\r\n    getSmoothCubicControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n\r\n      if ( this.lastCubicControlPoint ) {\r\n        return lastPoint.plus( lastPoint.minus( this.lastCubicControlPoint ) );\r\n      }\r\n      else {\r\n        return lastPoint;\r\n      }\r\n    },\r\n\r\n    getRelativePoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      return lastPoint ? lastPoint : Vector2.ZERO;\r\n    }\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Shape shortcuts\r\n   *----------------------------------------------------------------------------*/\r\n\r\n  Shape.rectangle = function( x, y, width, height ) {\r\n    return new Shape().rect( x, y, width, height );\r\n  };\r\n  Shape.rect = Shape.rectangle;\r\n\r\n  // Create a round rectangle {Shape}, with {Number} arguments. Uses circular or elliptical arcs if given.\r\n  Shape.roundRect = function( x, y, width, height, arcw, arch ) {\r\n    return new Shape().roundRect( x, y, width, height, arcw, arch );\r\n  };\r\n  Shape.roundRectangle = Shape.roundRect;\r\n\r\n  Shape.polygon = function( vertices ) {\r\n    return new Shape().polygon( vertices );\r\n  };\r\n\r\n  Shape.bounds = function( bounds ) {\r\n    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );\r\n  };\r\n\r\n  //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments\r\n  Shape.lineSegment = function( a, b, c, d ) {\r\n    // TODO: add type assertions?\r\n    if ( typeof a === 'number' ) {\r\n      return new Shape().moveTo( a, b ).lineTo( c, d );\r\n    }\r\n    else {\r\n      return new Shape().moveToPoint( a ).lineToPoint( b );\r\n    }\r\n  };\r\n\r\n  Shape.regularPolygon = function( sides, radius ) {\r\n    var shape = new Shape();\r\n    _.each( _.range( sides ), function( k ) {\r\n      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );\r\n      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );\r\n    } );\r\n    return shape.close();\r\n  };\r\n\r\n  // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0\r\n  Shape.circle = function( centerX, centerY, radius ) {\r\n    if ( centerY === undefined ) {\r\n      // circle( radius ), center = 0,0\r\n      return new Shape().circle( 0, 0, centerX );\r\n    }\r\n    return new Shape().circle( centerX, centerY, radius ).close();\r\n  };\r\n\r\n  /*\r\n   * Supports ellipse( centerX, centerY, radiusX, radiusY, rotation ), ellipse( center, radiusX, radiusY, rotation ), and ellipse( radiusX, radiusY, rotation )\r\n   * with the center default to 0,0 and rotation of 0.  The rotation is about the centerX, centerY.\r\n   */\r\n  Shape.ellipse = function( centerX, centerY, radiusX, radiusY, rotation ) {\r\n    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n    if ( radiusY === undefined ) {\r\n      // ellipse( radiusX, radiusY ), center = 0,0\r\n      return new Shape().ellipse( 0, 0, centerX, centerY, radiusX );\r\n    }\r\n    return new Shape().ellipse( centerX, centerY, radiusX, radiusY, rotation ).close();\r\n  };\r\n\r\n  // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )\r\n  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {\r\n    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );\r\n  };\r\n\r\n  return Shape;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A 3D cuboid-shaped bounded area (bounding box)\r\n *\r\n * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not\r\n * store these with the Bounds3 instance, since we want to lower the memory footprint.\r\n *\r\n * minX, minY, minZ, maxX, maxY, and maxZ are actually stored. We don't do x,y,z,width,height,depth because this can't properly express\r\n * semi-infinite bounds (like a half-plane), or easily handle what Bounds3.NOTHING and Bounds3.EVERYTHING do with\r\n * the constructive solid areas.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Bounds3',['require','DOT/dot','DOT/Vector3'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  require( 'DOT/Vector3' );\r\n\r\n  // not using x,y,width,height so that it can handle infinity-based cases in a better way\r\n  dot.Bounds3 = function Bounds3( minX, minY, minZ, maxX, maxY, maxZ ) {\r\n    assert && assert( maxY !== undefined, 'Bounds3 requires 4 parameters' );\r\n    this.minX = minX;\r\n    this.minY = minY;\r\n    this.minZ = minZ;\r\n    this.maxX = maxX;\r\n    this.maxY = maxY;\r\n    this.maxZ = maxZ;\r\n\r\n    phetAllocation && phetAllocation( 'Bounds3' );\r\n  };\r\n  var Bounds3 = dot.Bounds3;\r\n\r\n  Bounds3.prototype = {\r\n    constructor: Bounds3,\r\n\r\n    isBounds: true,\r\n    dimension: 3,\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Properties\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    getWidth: function() { return this.maxX - this.minX; },\r\n    get width() { return this.getWidth(); },\r\n\r\n    getHeight: function() { return this.maxY - this.minY; },\r\n    get height() { return this.getHeight(); },\r\n\r\n    getDepth: function() { return this.maxZ - this.minZ; },\r\n    get depth() { return this.getDepth(); },\r\n\r\n    /*\r\n     * Convenience locations\r\n     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the \"upper\", and minY is the \"lower\"\r\n     *\r\n     *             minX (x)     centerX        maxX\r\n     *          ---------------------------------------\r\n     * minY (y) | upperLeft   upperCenter   upperRight\r\n     * centerY  | centerLeft    center      centerRight\r\n     * maxY     | lowerLeft   lowerCenter   lowerRight\r\n     */\r\n    getX: function() { return this.minX; },\r\n    get x() { return this.getX(); },\r\n    getY: function() { return this.minY; },\r\n    get y() { return this.getY(); },\r\n    getZ: function() { return this.minZ; },\r\n    get z() { return this.getZ(); },\r\n\r\n    getMinX: function() { return this.minX; },\r\n    get left() { return this.minX; },\r\n    getMinY: function() { return this.minY; },\r\n    get top() { return this.minY; },\r\n    getMinZ: function() { return this.minZ; },\r\n    get back() { return this.minZ; },\r\n    getMaxX: function() { return this.maxX; },\r\n    get right() { return this.maxX; },\r\n    getMaxY: function() { return this.maxY; },\r\n    get bottom() { return this.maxY; },\r\n    getMaxZ: function() { return this.maxZ; },\r\n    get front() { return this.maxZ; },\r\n\r\n    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },\r\n    get centerX() { return this.getCenterX(); },\r\n    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },\r\n    get centerY() { return this.getCenterY(); },\r\n    getCenterZ: function() { return ( this.maxZ + this.minZ ) / 2; },\r\n    get centerZ() { return this.getCenterZ(); },\r\n\r\n    getCenter: function() { return new dot.Vector3( this.getCenterX(), this.getCenterY(), this.getCenterZ() ); },\r\n    get center() { return this.getCenter(); },\r\n\r\n    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0 || this.getDepth() < 0; },\r\n\r\n    isFinite: function() {\r\n      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.minZ ) && isFinite( this.maxX ) && isFinite( this.maxY ) && isFinite( this.maxZ );\r\n    },\r\n\r\n    isValid: function() {\r\n      return !this.isEmpty() && this.isFinite();\r\n    },\r\n\r\n    // whether the coordinates are inside the bounding box (or on the boundary)\r\n    containsCoordinates: function( x, y, z ) {\r\n      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY && this.minZ <= z && z <= this.maxZ;\r\n    },\r\n\r\n    // whether the point is inside the bounding box (or on the boundary)\r\n    containsPoint: function( point ) {\r\n      return this.containsCoordinates( point.x, point.y, point.z );\r\n    },\r\n\r\n    // whether this bounding box completely contains the argument bounding box\r\n    containsBounds: function( bounds ) {\r\n      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY && this.minZ <= bounds.minZ && this.maxZ >= bounds.maxZ;\r\n    },\r\n\r\n    // whether the intersection is non-empty (if they share any part of a boundary, this will be true)\r\n    intersectsBounds: function( bounds ) {\r\n      // TODO: more efficient way of doing this?\r\n      return !this.intersection( bounds ).isEmpty();\r\n    },\r\n\r\n    toString: function() {\r\n      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + '),z:(' + this.minZ + ',' + this.maxZ + ')]';\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.minX === other.minX && this.minY === other.minY && this.minZ === other.minZ && this.maxX === other.maxX && this.maxY === other.maxY && this.maxZ === other.maxZ;\r\n    },\r\n\r\n    equalsEpsilon: function( other, epsilon ) {\r\n      epsilon = epsilon || 0;\r\n      var thisFinite = this.isFinite();\r\n      var otherFinite = other.isFinite();\r\n      if ( thisFinite && otherFinite ) {\r\n        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity\r\n        return Math.abs( this.minX - other.minX ) < epsilon &&\r\n               Math.abs( this.minY - other.minY ) < epsilon &&\r\n               Math.abs( this.minZ - other.minZ ) < epsilon &&\r\n               Math.abs( this.maxX - other.maxX ) < epsilon &&\r\n               Math.abs( this.maxY - other.maxY ) < epsilon &&\r\n               Math.abs( this.maxZ - other.maxZ ) < epsilon;\r\n      }\r\n      else if ( thisFinite !== otherFinite ) {\r\n        return false; // one is finite, the other is not. definitely not equal\r\n      }\r\n      else if ( this === other ) {\r\n        return true; // exact same instance, must be equal\r\n      }\r\n      else {\r\n        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both\r\n        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&\r\n               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&\r\n               ( isFinite( this.minZ + other.minZ ) ? ( Math.abs( this.minZ - other.minZ ) < epsilon ) : ( this.minZ === other.minZ ) ) &&\r\n               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&\r\n               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) ) &&\r\n               ( isFinite( this.maxZ + other.maxZ ) ? ( Math.abs( this.maxZ - other.maxZ ) < epsilon ) : ( this.maxZ === other.maxZ ) );\r\n      }\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutable operations\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // create a copy, or if bounds is passed in, set that bounds to our value\r\n    copy: function( bounds ) {\r\n      if ( bounds ) {\r\n        return bounds.set( this );\r\n      }\r\n      else {\r\n        return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ );\r\n      }\r\n    },\r\n\r\n    // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)\r\n    union: function( bounds ) {\r\n      return new Bounds3(\r\n        Math.min( this.minX, bounds.minX ),\r\n        Math.min( this.minY, bounds.minY ),\r\n        Math.min( this.minZ, bounds.minZ ),\r\n        Math.max( this.maxX, bounds.maxX ),\r\n        Math.max( this.maxY, bounds.maxY ),\r\n        Math.max( this.maxZ, bounds.maxZ )\r\n      );\r\n    },\r\n    intersection: function( bounds ) {\r\n      return new Bounds3(\r\n        Math.max( this.minX, bounds.minX ),\r\n        Math.max( this.minY, bounds.minY ),\r\n        Math.max( this.minZ, bounds.minZ ),\r\n        Math.min( this.maxX, bounds.maxX ),\r\n        Math.min( this.maxY, bounds.maxY ),\r\n        Math.min( this.maxZ, bounds.maxZ )\r\n      );\r\n    },\r\n    // TODO: difference should be well-defined, but more logic is needed to compute\r\n\r\n    withCoordinates: function( x, y, z ) {\r\n      return new Bounds3(\r\n        Math.min( this.minX, x ),\r\n        Math.min( this.minY, y ),\r\n        Math.min( this.minZ, z ),\r\n        Math.max( this.maxX, x ),\r\n        Math.max( this.maxY, y ),\r\n        Math.max( this.maxZ, z )\r\n      );\r\n    },\r\n\r\n    // like a union with a point-sized bounding box\r\n    withPoint: function( point ) {\r\n      return this.withCoordinates( point.x, point.y, point.z );\r\n    },\r\n\r\n    withMinX: function( minX ) { return new Bounds3( minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ ); },\r\n    withMinY: function( minY ) { return new Bounds3( this.minX, minY, this.minZ, this.maxX, this.maxY, this.maxZ ); },\r\n    withMinZ: function( minZ ) { return new Bounds3( this.minX, this.minY, minZ, this.maxX, this.maxY, this.maxZ ); },\r\n    withMaxX: function( maxX ) { return new Bounds3( this.minX, this.minY, this.minZ, maxX, this.maxY, this.maxZ ); },\r\n    withMaxY: function( maxY ) { return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, maxY, this.maxZ ); },\r\n    withMaxZ: function( maxZ ) { return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, this.maxY, maxZ ); },\r\n\r\n    // copy rounded to integral values, expanding where necessary\r\n    roundedOut: function() {\r\n      return new Bounds3(\r\n        Math.floor( this.minX ),\r\n        Math.floor( this.minY ),\r\n        Math.floor( this.minZ ),\r\n        Math.ceil( this.maxX ),\r\n        Math.ceil( this.maxY ),\r\n        Math.ceil( this.maxZ )\r\n      );\r\n    },\r\n\r\n    // copy rounded to integral values, contracting where necessary\r\n    roundedIn: function() {\r\n      return new Bounds3(\r\n        Math.ceil( this.minX ),\r\n        Math.ceil( this.minY ),\r\n        Math.ceil( this.minZ ),\r\n        Math.floor( this.maxX ),\r\n        Math.floor( this.maxY ),\r\n        Math.floor( this.maxZ )\r\n      );\r\n    },\r\n\r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transformed: function( matrix ) {\r\n      return this.copy().transform( matrix );\r\n    },\r\n\r\n    // returns copy expanded on all sides by length d\r\n    dilated: function( d ) {\r\n      return new Bounds3( this.minX - d, this.minY - d, this.minZ - d, this.maxX + d, this.maxY + d, this.maxZ + d );\r\n    },\r\n\r\n    // dilates only in the x direction\r\n    dilatedX: function( x ) {\r\n      return new Bounds3( this.minX - x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );\r\n    },\r\n\r\n    // dilates only in the y direction\r\n    dilatedY: function( y ) {\r\n      return new Bounds3( this.minX, this.minY - y, this.minZ, this.maxX, this.maxY + y, this.maxZ );\r\n    },\r\n\r\n    // dilates only in the z direction\r\n    dilatedZ: function( z ) {\r\n      return new Bounds3( this.minX, this.minY, this.minZ - z, this.maxX, this.maxY, this.maxZ + z );\r\n    },\r\n\r\n    // dilate with different amounts in the x, y and z directions\r\n    dilatedXYZ: function( x, y, z ) {\r\n      return new Bounds3( this.minX - x, this.minY - y, this.minZ - z, this.maxX + x, this.maxY + y, this.maxZ + z );\r\n    },\r\n\r\n    // returns copy contracted on all sides by length d, or x/y/z separately\r\n    eroded: function( d ) { return this.dilated( -d ); },\r\n    erodedX: function( x ) { return this.dilatedX( -x ); },\r\n    erodedY: function( y ) { return this.dilatedY( -y ); },\r\n    erodedZ: function( z ) { return this.dilatedZ( -z ); },\r\n    erodedXYZ: function( x, y, z ) { return this.dilatedXYZ( -x, -y, -z ); },\r\n\r\n    shiftedX: function( x ) {\r\n      return new Bounds3( this.minX + x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );\r\n    },\r\n\r\n    shiftedY: function( y ) {\r\n      return new Bounds3( this.minX, this.minY + y, this.minZ, this.maxX, this.maxY + y, this.maxZ );\r\n    },\r\n\r\n    shiftedZ: function( z ) {\r\n      return new Bounds3( this.minX, this.minY, this.minZ + z, this.maxX, this.maxY, this.maxZ + z );\r\n    },\r\n\r\n    shifted: function( x, y, z ) {\r\n      return new Bounds3( this.minX + x, this.minY + y, this.minZ + z, this.maxX + x, this.maxY + y, this.maxZ + z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutable operations\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // core mutations (every other mutator should call one of these once)\r\n    setMinMax: function( minX, minY, minZ, maxX, maxY, maxZ ) {\r\n      this.minX = minX;\r\n      this.minY = minY;\r\n      this.minZ = minZ;\r\n      this.maxX = maxX;\r\n      this.maxY = maxY;\r\n      this.maxZ = maxZ;\r\n      return this;\r\n    },\r\n    setMinX: function( minX ) {\r\n      this.minX = minX;\r\n      return this;\r\n    },\r\n    setMinY: function( minY ) {\r\n      this.minY = minY;\r\n      return this;\r\n    },\r\n    setMinZ: function( minZ ) {\r\n      this.minZ = minZ;\r\n      return this;\r\n    },\r\n    setMaxX: function( maxX ) {\r\n      this.maxX = maxX;\r\n      return this;\r\n    },\r\n    setMaxY: function( maxY ) {\r\n      this.maxY = maxY;\r\n      return this;\r\n    },\r\n    setMaxZ: function( maxZ ) {\r\n      this.maxZ = maxZ;\r\n      return this;\r\n    },\r\n\r\n    set: function( bounds ) {\r\n      return this.setMinMax( bounds.minX, bounds.minY, bounds.minZ, bounds.maxX, bounds.maxY, bounds.maxZ );\r\n    },\r\n\r\n    // mutable union\r\n    includeBounds: function( bounds ) {\r\n      return this.setMinMax(\r\n        Math.min( this.minX, bounds.minX ),\r\n        Math.min( this.minY, bounds.minY ),\r\n        Math.min( this.minZ, bounds.minZ ),\r\n        Math.max( this.maxX, bounds.maxX ),\r\n        Math.max( this.maxY, bounds.maxY ),\r\n        Math.max( this.maxZ, bounds.maxZ )\r\n      );\r\n    },\r\n\r\n    // mutable intersection\r\n    constrainBounds: function( bounds ) {\r\n      return this.setMinMax(\r\n        Math.max( this.minX, bounds.minX ),\r\n        Math.max( this.minY, bounds.minY ),\r\n        Math.max( this.minZ, bounds.minZ ),\r\n        Math.min( this.maxX, bounds.maxX ),\r\n        Math.min( this.maxY, bounds.maxY ),\r\n        Math.min( this.maxZ, bounds.maxZ )\r\n      );\r\n    },\r\n\r\n    addCoordinates: function( x, y, z ) {\r\n      return this.setMinMax(\r\n        Math.min( this.minX, x ),\r\n        Math.min( this.minY, y ),\r\n        Math.min( this.minZ, z ),\r\n        Math.max( this.maxX, x ),\r\n        Math.max( this.maxY, y ),\r\n        Math.max( this.maxZ, z )\r\n      );\r\n    },\r\n\r\n    addPoint: function( point ) {\r\n      return this.addCoordinates( point.x, point.y, point.z );\r\n    },\r\n\r\n    // round to integral values, expanding where necessary\r\n    roundOut: function() {\r\n      return this.setMinMax(\r\n        Math.floor( this.minX ),\r\n        Math.floor( this.minY ),\r\n        Math.floor( this.minZ ),\r\n        Math.ceil( this.maxX ),\r\n        Math.ceil( this.maxY ),\r\n        Math.ceil( this.maxZ )\r\n      );\r\n    },\r\n\r\n    // round to integral values, contracting where necessary\r\n    roundIn: function() {\r\n      return this.setMinMax(\r\n        Math.ceil( this.minX ),\r\n        Math.ceil( this.minY ),\r\n        Math.ceil( this.minZ ),\r\n        Math.floor( this.maxX ),\r\n        Math.floor( this.maxY ),\r\n        Math.floor( this.maxZ )\r\n      );\r\n    },\r\n\r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transform: function( matrix ) {\r\n      // do nothing\r\n      if ( this.isEmpty() ) {\r\n        return this;\r\n      }\r\n\r\n      // optimization to bail for identity matrices\r\n      if ( matrix.isIdentity() ) {\r\n        return this;\r\n      }\r\n\r\n      var minX = Number.POSITIVE_INFINITY;\r\n      var minY = Number.POSITIVE_INFINITY;\r\n      var minZ = Number.POSITIVE_INFINITY;\r\n      var maxX = Number.NEGATIVE_INFINITY;\r\n      var maxY = Number.NEGATIVE_INFINITY;\r\n      var maxZ = Number.NEGATIVE_INFINITY;\r\n\r\n      // using mutable vector so we don't create excessive instances of Vector2 during this\r\n      // make sure all 4 corners are inside this transformed bounding box\r\n      var vector = new dot.Vector3();\r\n\r\n      function withIt( vector ) {\r\n        minX = Math.min( minX, vector.x );\r\n        minY = Math.min( minY, vector.y );\r\n        minZ = Math.min( minZ, vector.z );\r\n        maxX = Math.max( maxX, vector.x );\r\n        maxY = Math.max( maxY, vector.y );\r\n        maxZ = Math.max( maxZ, vector.z );\r\n      }\r\n\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.minY, this.minZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.maxY, this.minZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.minY, this.minZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.maxY, this.minZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.minY, this.maxZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.maxY, this.maxZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.minY, this.maxZ ) ) );\r\n      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.maxY, this.maxZ ) ) );\r\n      return this.setMinMax( minX, minY, minZ, maxX, maxY, maxZ );\r\n    },\r\n\r\n    // expands on all sides by length d\r\n    dilate: function( d ) {\r\n      return this.setMinMax( this.minX - d, this.minY - d, this.minZ - d, this.maxX + d, this.maxY + d, this.maxZ + d );\r\n    },\r\n\r\n    // dilates only in the x direction\r\n    dilateX: function( x ) {\r\n      return this.setMinMax( this.minX - x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );\r\n    },\r\n\r\n    // dilates only in the y direction\r\n    dilateY: function( y ) {\r\n      return this.setMinMax( this.minX, this.minY - y, this.minZ, this.maxX, this.maxY + y, this.maxZ );\r\n    },\r\n\r\n    // dilates only in the z direction\r\n    dilateZ: function( z ) {\r\n      return this.setMinMax( this.minX, this.minY, this.minZ - z, this.maxX, this.maxY, this.maxZ + z );\r\n    },\r\n\r\n    // dilate with different amounts in the x, y and z directions\r\n    dilateXYZ: function( x, y, z ) {\r\n      return this.setMinMax( this.minX - x, this.minY - y, this.minZ - z, this.maxX + x, this.maxY + y, this.maxZ + z );\r\n    },\r\n\r\n    // contracts on all sides by length d, or x/y/z independently\r\n    erode: function( d ) { return this.dilate( -d ); },\r\n    erodeX: function( x ) { return this.dilateX( -x ); },\r\n    erodeY: function( y ) { return this.dilateY( -y ); },\r\n    erodeZ: function( z ) { return this.dilateZ( -z ); },\r\n    erodeXYZ: function( x, y, z ) { return this.dilateXYZ( -x, -y, -z ); },\r\n\r\n    shiftX: function( x ) {\r\n      return this.setMinMax( this.minX + x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );\r\n    },\r\n\r\n    shiftY: function( y ) {\r\n      return this.setMinMax( this.minX, this.minY + y, this.minZ, this.maxX, this.maxY + y, this.maxZ );\r\n    },\r\n\r\n    shiftZ: function( z ) {\r\n      return this.setMinMax( this.minX, this.minY, this.minZ + z, this.maxX, this.maxY, this.maxZ + z );\r\n    },\r\n\r\n    shift: function( x, y, z ) {\r\n      return this.setMinMax( this.minX + x, this.minY + y, this.minZ + z, this.maxX + x, this.maxY + y, this.maxZ + z );\r\n    }\r\n  };\r\n\r\n  Bounds3.cuboid = function( x, y, z, width, height, depth ) {\r\n    return new Bounds3( x, y, z, x + width, y + height, z + depth );\r\n  };\r\n\r\n  // a volume-less point bounds, which can be dilated to form a centered bounds\r\n  Bounds3.point = function( x, y, z ) {\r\n    return new Bounds3( x, y, z, x, y, z );\r\n  };\r\n\r\n  // specific bounds useful for operations\r\n  Bounds3.EVERYTHING = new Bounds3( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );\r\n  Bounds3.NOTHING = new Bounds3( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );\r\n\r\n  return Bounds3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Module that includes all Kite dependencies, so that requiring this module will return an object\r\n * that consists of the entire exported 'kite' namespace API.\r\n *\r\n * The API is actually generated by the 'kite' module, so if this module (or all other modules) are\r\n * not included, the 'kite' namespace may not be complete.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'main',[\r\n  'KITE/kite',\r\n\r\n  'KITE/Shape',\r\n  'KITE/segments/Arc',\r\n  'KITE/segments/Cubic',\r\n  'KITE/segments/EllipticalArc',\r\n  'KITE/segments/Line',\r\n  'KITE/segments/Quadratic',\r\n  'KITE/segments/Segment',\r\n  'KITE/util/LineStyles',\r\n  'KITE/util/Subpath',\r\n\r\n  'KITE/parser/svgPath'\r\n], function( kite // note: we don't need any of the other parts, we just need to specify them as dependencies so they fill in the kite namespace\r\n) {\r\n  'use strict';\r\n\r\n  return kite;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Immutable complex number handling\r\n *\r\n * TODO: handle quaternions in a Quaternion.js!\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n * @author Chris Malley\r\n */\r\n\r\ndefine( 'DOT/Complex',['require','DOT/dot','PHET_CORE/inherit','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n\r\n  // not using x,y,width,height so that it can handle infinity-based cases in a better way\r\n  dot.Complex = function Complex( real, imaginary ) {\r\n    Vector2.call( this, real, imaginary );\r\n    this.real = real;\r\n    this.imaginary = imaginary;\r\n  };\r\n  var Complex = dot.Complex;\r\n\r\n  Complex.real = function( real ) {\r\n    return new Complex( real, 0 );\r\n  };\r\n\r\n  Complex.imaginary = function( imaginary ) {\r\n    return new Complex( 0, imaginary );\r\n  };\r\n\r\n  Complex.createPolar = function( magnitude, phase ) {\r\n    return new Complex( magnitude * Math.cos( phase ), magnitude * Math.sin( phase ) );\r\n  };\r\n\r\n  // inheriting Vector2 for now since many times we may want to treat the complex number as a vector\r\n  // ideally, we should have Vector2-likeness be a mixin?\r\n  // we also inherit the immutable form since we add 'real' and 'imaginary' properties,\r\n  // without adding extra logic to mutators in Vector2\r\n  inherit( Vector2.Immutable, Complex, {\r\n    phase: Vector2.prototype.angle,\r\n\r\n    // TODO: remove times() from Vector2? or have it do this for vectors\r\n    times: function( c ) {\r\n      return new Complex( this.real * c.real - this.imaginary * c.imaginary, this.real * c.imaginary + this.imaginary * c.real );\r\n    },\r\n\r\n    dividedBy: function( c ) {\r\n      var cMag = c.magnitudeSquared();\r\n      return new Complex(\r\n        ( this.real * c.real + this.imaginary * c.imaginary ) / cMag,\r\n        ( this.imaginary * c.real - this.real * c.imaginary ) / cMag\r\n      );\r\n    },\r\n\r\n    // TODO: pow()\r\n    sqrt: function() {\r\n      var mag = this.magnitude();\r\n      return new Complex( Math.sqrt( ( mag + this.real ) / 2 ),\r\n        ( this.imaginary >= 0 ? 1 : -1 ) * Math.sqrt( ( mag - this.real ) / 2 ) );\r\n    },\r\n\r\n    conjugate: function() {\r\n      return new Complex( this.real, -this.imaginary );\r\n    },\r\n\r\n    // e^(a+bi) = ( e^a ) * ( cos(b) + i * sin(b) )\r\n    exponentiated: function() {\r\n      return Complex.createPolar( Math.exp( this.real ), this.imaginary );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Complex(\" + this.x + \", \" + this.y + \")\";\r\n    }\r\n  } );\r\n\r\n  Complex.ZERO = new Complex( 0, 0 );\r\n  Complex.ONE = new Complex( 1, 0 );\r\n  Complex.I = new Complex( 0, 1 );\r\n\r\n  return Complex;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * 2D convex hulls\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/ConvexHull2',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  // counter-clockwise turn if > 0, clockwise turn if < 0, collinear if === 0.\r\n  function ccw( p1, p2, p3 ) {\r\n    return p2.minus( p1 ).crossScalar( p3.minus( p1 ) );\r\n  }\r\n\r\n  dot.ConvexHull2 = {\r\n    // test: all collinear, multiple ways of having same angle, etc.\r\n\r\n    // points is an array of Vector2 instances. see http://en.wikipedia.org/wiki/Graham_scan\r\n    grahamScan: function( points, includeCollinear ) {\r\n      if ( points.length <= 2 ) {\r\n        return points;\r\n      }\r\n\r\n      // find the point 'p' with the lowest y value\r\n      var minY = Number.POSITIVE_INFINITY;\r\n      var p = null;\r\n      _.each( points, function( point ) {\r\n        if ( point.y <= minY ) {\r\n          // if two points have the same y value, take the one with the lowest x\r\n          if ( point.y === minY && p ) {\r\n            if ( point.x < p.x ) {\r\n              p = point;\r\n            }\r\n          }\r\n          else {\r\n            minY = point.y;\r\n            p = point;\r\n          }\r\n        }\r\n      } );\r\n\r\n      // sorts the points by their angle. Between 0 and PI\r\n      points = _.sortBy( points, function( point ) {\r\n        return point.minus( p ).angle();\r\n      } );\r\n\r\n      // remove p from points (relies on the above statement making a defensive copy)\r\n      points.splice( _.indexOf( points, p ), 1 );\r\n\r\n      // our result array\r\n      var result = [ p ];\r\n\r\n      _.each( points, function( point ) {\r\n        // ignore points equal to our starting point\r\n        if ( p.x === point.x && p.y === point.y ) { return; }\r\n\r\n        function isRightTurn() {\r\n          if ( result.length < 2 ) {\r\n            return false;\r\n          }\r\n          var cross = ccw( result[ result.length - 2 ], result[ result.length - 1 ], point );\r\n          return includeCollinear ? ( cross < 0 ) : ( cross <= 0 );\r\n        }\r\n\r\n        while ( isRightTurn() ) {\r\n          result.pop();\r\n        }\r\n        result.push( point );\r\n      } );\r\n\r\n      return result;\r\n    }\r\n  };\r\n\r\n  return dot.ConvexHull2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Basic width and height\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Dimension2',['require','DOT/dot','DOT/Bounds2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n  require( 'DOT/Bounds2' );\r\n\r\n  dot.Dimension2 = function Dimension2( width, height ) {\r\n    this.width = width;\r\n    this.height = height;\r\n  };\r\n  var Dimension2 = dot.Dimension2;\r\n\r\n  Dimension2.prototype = {\r\n    constructor: Dimension2,\r\n\r\n    toString: function() {\r\n      return \"[\" + this.width + \"w, \" + this.height + \"h]\";\r\n    },\r\n\r\n    set: function( dimension ) {\r\n      this.width = dimension.width;\r\n      this.height = dimension.height;\r\n      return this;\r\n    },\r\n\r\n    setWidth: function( width ) {\r\n      this.width = width;\r\n      return this;\r\n    },\r\n\r\n    setHeight: function( width ) {\r\n      this.width = width;\r\n      return this;\r\n    },\r\n\r\n    copy: function( dimension ) {\r\n      if ( dimension ) {\r\n        return dimension.set( this );\r\n      }\r\n      else {\r\n        return new Dimension2( this.width, this.height );\r\n      }\r\n    },\r\n\r\n    toBounds: function( x, y ) {\r\n      x = x || 0;\r\n      y = y || 0;\r\n      return new dot.Bounds2( x, y, this.width + x, this.height + y );\r\n    },\r\n\r\n    equals: function( other ) {\r\n      return this.width === other.width && this.height === other.height;\r\n    }\r\n  };\r\n\r\n  return Dimension2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Eigensystem decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * Eigenvalues and eigenvectors of a real matrix.\r\n * <P>\r\n * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is\r\n * diagonal and the eigenvector matrix V is orthogonal.\r\n * I.e. A = V.times(D.times(V.transpose())) and\r\n * V.times(V.transpose()) equals the identity matrix.\r\n * <P>\r\n * If A is not symmetric, then the eigenvalue matrix D is block diagonal\r\n * with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,\r\n * lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The\r\n * columns of V represent the eigenvectors in the sense that A*V = V*D,\r\n * i.e. A.times(V) equals V.times(D).  The matrix V may be badly\r\n * conditioned, or even singular, so the validity of the equation\r\n * A = V*D*inverse(V) depends upon V.cond().\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/EigenvalueDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.EigenvalueDecomposition = function EigenvalueDecomposition( matrix ) {\r\n    var i, j;\r\n\r\n    var A = matrix.entries;\r\n    this.n = matrix.getColumnDimension(); // Row and column dimension (square matrix).\r\n    var n = this.n;\r\n    this.V = new Float32Array( n * n ); // Array for internal storage of eigenvectors.\r\n\r\n    // Arrays for internal storage of eigenvalues.\r\n    this.d = new Float32Array( n );\r\n    this.e = new Float32Array( n );\r\n\r\n    this.issymmetric = true;\r\n    for ( j = 0; (j < n) && this.issymmetric; j++ ) {\r\n      for ( i = 0; (i < n) && this.issymmetric; i++ ) {\r\n        this.issymmetric = (A[ i * this.n + j ] === A[ j * this.n + i ]);\r\n      }\r\n    }\r\n\r\n    if ( this.issymmetric ) {\r\n      for ( i = 0; i < n; i++ ) {\r\n        for ( j = 0; j < n; j++ ) {\r\n          this.V[ i * this.n + j ] = A[ i * this.n + j ];\r\n        }\r\n      }\r\n\r\n      // Tridiagonalize.\r\n      this.tred2();\r\n\r\n      // Diagonalize.\r\n      this.tql2();\r\n\r\n    }\r\n    else {\r\n      this.H = new Float32Array( n * n ); // Array for internal storage of nonsymmetric Hessenberg form.\r\n      this.ort = new Float32Array( n ); // // Working storage for nonsymmetric algorithm.\r\n\r\n      for ( j = 0; j < n; j++ ) {\r\n        for ( i = 0; i < n; i++ ) {\r\n          this.H[ i * this.n + j ] = A[ i * this.n + j ];\r\n        }\r\n      }\r\n\r\n      // Reduce to Hessenberg form.\r\n      this.orthes();\r\n\r\n      // Reduce Hessenberg to real Schur form.\r\n      this.hqr2();\r\n    }\r\n  };\r\n  var EigenvalueDecomposition = dot.EigenvalueDecomposition;\r\n\r\n  EigenvalueDecomposition.prototype = {\r\n    constructor: EigenvalueDecomposition,\r\n\r\n    // Return the eigenvector matrix\r\n    getV: function() {\r\n      return this.V.copy();\r\n    },\r\n\r\n    // {Array} Return the real parts of the eigenvalues\r\n    getRealEigenvalues: function() {\r\n      return this.d;\r\n    },\r\n\r\n    // {Array} Return the imaginary parts of the eigenvalues\r\n    getImagEigenvalues: function() {\r\n      return this.e;\r\n    },\r\n\r\n    // Return the block diagonal eigenvalue matrix\r\n    getD: function() {\r\n      var n = this.n, d = this.d, e = this.e;\r\n\r\n      var X = new dot.Matrix( n, n );\r\n      var D = X.entries;\r\n      for ( var i = 0; i < n; i++ ) {\r\n        for ( var j = 0; j < n; j++ ) {\r\n          D[ i * this.n + j ] = 0.0;\r\n        }\r\n        D[ i * this.n + i ] = d[ i ];\r\n        if ( e[ i ] > 0 ) {\r\n          D[ i * this.n + i + 1 ] = e[ i ];\r\n        }\r\n        else if ( e[ i ] < 0 ) {\r\n          D[ i * this.n + i - 1 ] = e[ i ];\r\n        }\r\n      }\r\n      return X;\r\n    },\r\n\r\n    // Symmetric Householder reduction to tridiagonal form.\r\n    tred2: function() {\r\n      var n = this.n, V = this.V, d = this.d, e = this.e;\r\n      var i, j, k, f, g, h;\r\n\r\n      //  This is derived from the Algol procedures tred2 by\r\n      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for\r\n      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutine in EISPACK.\r\n\r\n      for ( j = 0; j < n; j++ ) {\r\n        d[ j ] = V[ (n - 1) * n + j ];\r\n      }\r\n\r\n      // Householder reduction to tridiagonal form.\r\n\r\n      for ( i = n - 1; i > 0; i-- ) {\r\n\r\n        // Scale to avoid under/overflow.\r\n\r\n        var scale = 0.0;\r\n        h = 0.0;\r\n        for ( k = 0; k < i; k++ ) {\r\n          scale = scale + Math.abs( d[ k ] );\r\n        }\r\n        if ( scale === 0.0 ) {\r\n          e[ i ] = d[ i - 1 ];\r\n          for ( j = 0; j < i; j++ ) {\r\n            d[ j ] = V[ (i - 1) * n + j ];\r\n            V[ i * this.n + j ] = 0.0;\r\n            V[ j * this.n + i ] = 0.0;\r\n          }\r\n        }\r\n        else {\r\n\r\n          // Generate Householder vector.\r\n\r\n          for ( k = 0; k < i; k++ ) {\r\n            d[ k ] /= scale;\r\n            h += d[ k ] * d[ k ];\r\n          }\r\n          f = d[ i - 1 ];\r\n          g = Math.sqrt( h );\r\n          if ( f > 0 ) {\r\n            g = -g;\r\n          }\r\n          e[ i ] = scale * g;\r\n          h = h - f * g;\r\n          d[ i - 1 ] = f - g;\r\n          for ( j = 0; j < i; j++ ) {\r\n            e[ j ] = 0.0;\r\n          }\r\n\r\n          // Apply similarity transformation to remaining columns.\r\n\r\n          for ( j = 0; j < i; j++ ) {\r\n            f = d[ j ];\r\n            V[ j * this.n + i ] = f;\r\n            g = e[ j ] + V[ j * n + j ] * f;\r\n            for ( k = j + 1; k <= i - 1; k++ ) {\r\n              g += V[ k * n + j ] * d[ k ];\r\n              e[ k ] += V[ k * n + j ] * f;\r\n            }\r\n            e[ j ] = g;\r\n          }\r\n          f = 0.0;\r\n          for ( j = 0; j < i; j++ ) {\r\n            e[ j ] /= h;\r\n            f += e[ j ] * d[ j ];\r\n          }\r\n          var hh = f / (h + h);\r\n          for ( j = 0; j < i; j++ ) {\r\n            e[ j ] -= hh * d[ j ];\r\n          }\r\n          for ( j = 0; j < i; j++ ) {\r\n            f = d[ j ];\r\n            g = e[ j ];\r\n            for ( k = j; k <= i - 1; k++ ) {\r\n              V[ k * n + j ] -= (f * e[ k ] + g * d[ k ]);\r\n            }\r\n            d[ j ] = V[ (i - 1) * n + j ];\r\n            V[ i * this.n + j ] = 0.0;\r\n          }\r\n        }\r\n        d[ i ] = h;\r\n      }\r\n\r\n      // Accumulate transformations.\r\n\r\n      for ( i = 0; i < n - 1; i++ ) {\r\n        V[ (n - 1) * n + i ] = V[ i * n + i ];\r\n        V[ i * n + i ] = 1.0;\r\n        h = d[ i + 1 ];\r\n        if ( h !== 0.0 ) {\r\n          for ( k = 0; k <= i; k++ ) {\r\n            d[ k ] = V[ k * n + (i + 1) ] / h;\r\n          }\r\n          for ( j = 0; j <= i; j++ ) {\r\n            g = 0.0;\r\n            for ( k = 0; k <= i; k++ ) {\r\n              g += V[ k * n + (i + 1) ] * V[ k * n + j ];\r\n            }\r\n            for ( k = 0; k <= i; k++ ) {\r\n              V[ k * n + j ] -= g * d[ k ];\r\n            }\r\n          }\r\n        }\r\n        for ( k = 0; k <= i; k++ ) {\r\n          V[ k * n + (i + 1) ] = 0.0;\r\n        }\r\n      }\r\n      for ( j = 0; j < n; j++ ) {\r\n        d[ j ] = V[ (n - 1) * n + j ];\r\n        V[ (n - 1) * n + j ] = 0.0;\r\n      }\r\n      V[ (n - 1) * n + (n - 1) ] = 1.0;\r\n      e[ 0 ] = 0.0;\r\n    },\r\n\r\n    // Symmetric tridiagonal QL algorithm.\r\n    tql2: function() {\r\n      var n = this.n, V = this.V, d = this.d, e = this.e;\r\n      var i, j, k, l, g, p;\r\n      var iter;\r\n\r\n      //  This is derived from the Algol procedures tql2, by\r\n      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for\r\n      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutine in EISPACK.\r\n\r\n      for ( i = 1; i < n; i++ ) {\r\n        e[ i - 1 ] = e[ i ];\r\n      }\r\n      e[ n - 1 ] = 0.0;\r\n\r\n      var f = 0.0;\r\n      var tst1 = 0.0;\r\n      var eps = Math.pow( 2.0, -52.0 );\r\n      for ( l = 0; l < n; l++ ) {\r\n\r\n        // Find small subdiagonal element\r\n\r\n        tst1 = Math.max( tst1, Math.abs( d[ l ] ) + Math.abs( e[ l ] ) );\r\n        var m = l;\r\n        while ( m < n ) {\r\n          if ( Math.abs( e[ m ] ) <= eps * tst1 ) {\r\n            break;\r\n          }\r\n          m++;\r\n        }\r\n\r\n        // If m === l, d[l] is an eigenvalue,\r\n        // otherwise, iterate.\r\n\r\n        if ( m > l ) {\r\n          iter = 0;\r\n          do {\r\n            iter = iter + 1;  // (Could check iteration count here.)\r\n\r\n            // Compute implicit shift\r\n\r\n            g = d[ l ];\r\n            p = (d[ l + 1 ] - g) / (2.0 * e[ l ]);\r\n            var r = dot.Matrix.hypot( p, 1.0 );\r\n            if ( p < 0 ) {\r\n              r = -r;\r\n            }\r\n            d[ l ] = e[ l ] / (p + r);\r\n            d[ l + 1 ] = e[ l ] * (p + r);\r\n            var dl1 = d[ l + 1 ];\r\n            var h = g - d[ l ];\r\n            for ( i = l + 2; i < n; i++ ) {\r\n              d[ i ] -= h;\r\n            }\r\n            f = f + h;\r\n\r\n            // Implicit QL transformation.\r\n\r\n            p = d[ m ];\r\n            var c = 1.0;\r\n            var c2 = c;\r\n            var c3 = c;\r\n            var el1 = e[ l + 1 ];\r\n            var s = 0.0;\r\n            var s2 = 0.0;\r\n            for ( i = m - 1; i >= l; i-- ) {\r\n              c3 = c2;\r\n              c2 = c;\r\n              s2 = s;\r\n              g = c * e[ i ];\r\n              h = c * p;\r\n              r = dot.Matrix.hypot( p, e[ i ] );\r\n              e[ i + 1 ] = s * r;\r\n              s = e[ i ] / r;\r\n              c = p / r;\r\n              p = c * d[ i ] - s * g;\r\n              d[ i + 1 ] = h + s * (c * g + s * d[ i ]);\r\n\r\n              // Accumulate transformation.\r\n\r\n              for ( k = 0; k < n; k++ ) {\r\n                h = V[ k * n + (i + 1) ];\r\n                V[ k * n + (i + 1) ] = s * V[ k * n + i ] + c * h;\r\n                V[ k * n + i ] = c * V[ k * n + i ] - s * h;\r\n              }\r\n            }\r\n            p = -s * s2 * c3 * el1 * e[ l ] / dl1;\r\n            e[ l ] = s * p;\r\n            d[ l ] = c * p;\r\n\r\n            // Check for convergence.\r\n\r\n          } while ( Math.abs( e[ l ] ) > eps * tst1 );\r\n        }\r\n        d[ l ] = d[ l ] + f;\r\n        e[ l ] = 0.0;\r\n      }\r\n\r\n      // Sort eigenvalues and corresponding vectors.\r\n\r\n      for ( i = 0; i < n - 1; i++ ) {\r\n        k = i;\r\n        p = d[ i ];\r\n        for ( j = i + 1; j < n; j++ ) {\r\n          if ( d[ j ] < p ) {\r\n            k = j;\r\n            p = d[ j ];\r\n          }\r\n        }\r\n        if ( k !== i ) {\r\n          d[ k ] = d[ i ];\r\n          d[ i ] = p;\r\n          for ( j = 0; j < n; j++ ) {\r\n            p = V[ j * this.n + i ];\r\n            V[ j * this.n + i ] = V[ j * n + k ];\r\n            V[ j * n + k ] = p;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Nonsymmetric reduction to Hessenberg form.\r\n    orthes: function() {\r\n      var n = this.n, V = this.V, H = this.H, ort = this.ort;\r\n      var i, j, m, f, g;\r\n\r\n      //  This is derived from the Algol procedures orthes and ortran,\r\n      //  by Martin and Wilkinson, Handbook for Auto. Comp.,\r\n      //  Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutines in EISPACK.\r\n\r\n      var low = 0;\r\n      var high = n - 1;\r\n\r\n      for ( m = low + 1; m <= high - 1; m++ ) {\r\n\r\n        // Scale column.\r\n\r\n        var scale = 0.0;\r\n        for ( i = m; i <= high; i++ ) {\r\n          scale = scale + Math.abs( H[ i * n + (m - 1) ] );\r\n        }\r\n        if ( scale !== 0.0 ) {\r\n\r\n          // Compute Householder transformation.\r\n\r\n          var h = 0.0;\r\n          for ( i = high; i >= m; i-- ) {\r\n            ort[ i ] = H[ i * n + (m - 1) ] / scale;\r\n            h += ort[ i ] * ort[ i ];\r\n          }\r\n          g = Math.sqrt( h );\r\n          if ( ort[ m ] > 0 ) {\r\n            g = -g;\r\n          }\r\n          h = h - ort[ m ] * g;\r\n          ort[ m ] = ort[ m ] - g;\r\n\r\n          // Apply Householder similarity transformation\r\n          // H = (I-u*u'/h)*H*(I-u*u')/h)\r\n\r\n          for ( j = m; j < n; j++ ) {\r\n            f = 0.0;\r\n            for ( i = high; i >= m; i-- ) {\r\n              f += ort[ i ] * H[ i * this.n + j ];\r\n            }\r\n            f = f / h;\r\n            for ( i = m; i <= high; i++ ) {\r\n              H[ i * this.n + j ] -= f * ort[ i ];\r\n            }\r\n          }\r\n\r\n          for ( i = 0; i <= high; i++ ) {\r\n            f = 0.0;\r\n            for ( j = high; j >= m; j-- ) {\r\n              f += ort[ j ] * H[ i * this.n + j ];\r\n            }\r\n            f = f / h;\r\n            for ( j = m; j <= high; j++ ) {\r\n              H[ i * this.n + j ] -= f * ort[ j ];\r\n            }\r\n          }\r\n          ort[ m ] = scale * ort[ m ];\r\n          H[ m * n + (m - 1) ] = scale * g;\r\n        }\r\n      }\r\n\r\n      // Accumulate transformations (Algol's ortran).\r\n\r\n      for ( i = 0; i < n; i++ ) {\r\n        for ( j = 0; j < n; j++ ) {\r\n          V[ i * this.n + j ] = (i === j ? 1.0 : 0.0);\r\n        }\r\n      }\r\n\r\n      for ( m = high - 1; m >= low + 1; m-- ) {\r\n        if ( H[ m * n + (m - 1) ] !== 0.0 ) {\r\n          for ( i = m + 1; i <= high; i++ ) {\r\n            ort[ i ] = H[ i * n + (m - 1) ];\r\n          }\r\n          for ( j = m; j <= high; j++ ) {\r\n            g = 0.0;\r\n            for ( i = m; i <= high; i++ ) {\r\n              g += ort[ i ] * V[ i * this.n + j ];\r\n            }\r\n            // Double division avoids possible underflow\r\n            g = (g / ort[ m ]) / H[ m * n + (m - 1) ];\r\n            for ( i = m; i <= high; i++ ) {\r\n              V[ i * this.n + j ] += g * ort[ i ];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Complex scalar division.\r\n    cdiv: function( xr, xi, yr, yi ) {\r\n      var r, d;\r\n      if ( Math.abs( yr ) > Math.abs( yi ) ) {\r\n        r = yi / yr;\r\n        d = yr + r * yi;\r\n        this.cdivr = (xr + r * xi) / d;\r\n        this.cdivi = (xi - r * xr) / d;\r\n      }\r\n      else {\r\n        r = yr / yi;\r\n        d = yi + r * yr;\r\n        this.cdivr = (r * xr + xi) / d;\r\n        this.cdivi = (r * xi - xr) / d;\r\n      }\r\n    },\r\n\r\n    // Nonsymmetric reduction from Hessenberg to real Schur form.\r\n    hqr2: function() {\r\n      var n, V = this.V, d = this.d, e = this.e, H = this.H;\r\n      var i, j, k, l, m;\r\n      var iter;\r\n\r\n      //  This is derived from the Algol procedure hqr2,\r\n      //  by Martin and Wilkinson, Handbook for Auto. Comp.,\r\n      //  Vol.ii-Linear Algebra, and the corresponding\r\n      //  Fortran subroutine in EISPACK.\r\n\r\n      // Initialize\r\n\r\n      var nn = this.n;\r\n      n = nn - 1;\r\n      var low = 0;\r\n      var high = nn - 1;\r\n      var eps = Math.pow( 2.0, -52.0 );\r\n      var exshift = 0.0;\r\n      var p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;\r\n\r\n      // Store roots isolated by balanc and compute matrix norm\r\n\r\n      var norm = 0.0;\r\n      for ( i = 0; i < nn; i++ ) {\r\n        if ( i < low || i > high ) {\r\n          d[ i ] = H[ i * n + i ];\r\n          e[ i ] = 0.0;\r\n        }\r\n        for ( j = Math.max( i - 1, 0 ); j < nn; j++ ) {\r\n          norm = norm + Math.abs( H[ i * this.n + j ] );\r\n        }\r\n      }\r\n\r\n      // Outer loop over eigenvalue index\r\n\r\n      iter = 0;\r\n      while ( n >= low ) {\r\n\r\n        // Look for single small sub-diagonal element\r\n\r\n        l = n;\r\n        while ( l > low ) {\r\n          s = Math.abs( H[ (l - 1) * n + (l - 1) ] ) + Math.abs( H[ l * n + l ] );\r\n          if ( s === 0.0 ) {\r\n            s = norm;\r\n          }\r\n          if ( Math.abs( H[ l * n + (l - 1) ] ) < eps * s ) {\r\n            break;\r\n          }\r\n          l--;\r\n        }\r\n\r\n        // Check for convergence\r\n        // One root found\r\n\r\n        if ( l === n ) {\r\n          H[ n * n + n ] = H[ n * n + n ] + exshift;\r\n          d[ n ] = H[ n * n + n ];\r\n          e[ n ] = 0.0;\r\n          n--;\r\n          iter = 0;\r\n\r\n          // Two roots found\r\n\r\n        }\r\n        else if ( l === n - 1 ) {\r\n          w = H[ n * n + n - 1 ] * H[ (n - 1) * n + n ];\r\n          p = (H[ (n - 1) * n + (n - 1) ] - H[ n * n + n ]) / 2.0;\r\n          q = p * p + w;\r\n          z = Math.sqrt( Math.abs( q ) );\r\n          H[ n * n + n ] = H[ n * n + n ] + exshift;\r\n          H[ (n - 1) * n + (n - 1) ] = H[ (n - 1) * n + (n - 1) ] + exshift;\r\n          x = H[ n * n + n ];\r\n\r\n          // Real pair\r\n\r\n          if ( q >= 0 ) {\r\n            if ( p >= 0 ) {\r\n              z = p + z;\r\n            }\r\n            else {\r\n              z = p - z;\r\n            }\r\n            d[ n - 1 ] = x + z;\r\n            d[ n ] = d[ n - 1 ];\r\n            if ( z !== 0.0 ) {\r\n              d[ n ] = x - w / z;\r\n            }\r\n            e[ n - 1 ] = 0.0;\r\n            e[ n ] = 0.0;\r\n            x = H[ n * n + n - 1 ];\r\n            s = Math.abs( x ) + Math.abs( z );\r\n            p = x / s;\r\n            q = z / s;\r\n            r = Math.sqrt( p * p + q * q );\r\n            p = p / r;\r\n            q = q / r;\r\n\r\n            // Row modification\r\n\r\n            for ( j = n - 1; j < nn; j++ ) {\r\n              z = H[ (n - 1) * n + j ];\r\n              H[ (n - 1) * n + j ] = q * z + p * H[ n * n + j ];\r\n              H[ n * n + j ] = q * H[ n * n + j ] - p * z;\r\n            }\r\n\r\n            // Column modification\r\n\r\n            for ( i = 0; i <= n; i++ ) {\r\n              z = H[ i * n + n - 1 ];\r\n              H[ i * n + n - 1 ] = q * z + p * H[ i * n + n ];\r\n              H[ i * n + n ] = q * H[ i * n + n ] - p * z;\r\n            }\r\n\r\n            // Accumulate transformations\r\n\r\n            for ( i = low; i <= high; i++ ) {\r\n              z = V[ i * n + n - 1 ];\r\n              V[ i * n + n - 1 ] = q * z + p * V[ i * n + n ];\r\n              V[ i * n + n ] = q * V[ i * n + n ] - p * z;\r\n            }\r\n\r\n            // Complex pair\r\n\r\n          }\r\n          else {\r\n            d[ n - 1 ] = x + p;\r\n            d[ n ] = x + p;\r\n            e[ n - 1 ] = z;\r\n            e[ n ] = -z;\r\n          }\r\n          n = n - 2;\r\n          iter = 0;\r\n\r\n          // No convergence yet\r\n\r\n        }\r\n        else {\r\n\r\n          // Form shift\r\n\r\n          x = H[ n * n + n ];\r\n          y = 0.0;\r\n          w = 0.0;\r\n          if ( l < n ) {\r\n            y = H[ (n - 1) * n + (n - 1) ];\r\n            w = H[ n * n + n - 1 ] * H[ (n - 1) * n + n ];\r\n          }\r\n\r\n          // Wilkinson's original ad hoc shift\r\n\r\n          if ( iter === 10 ) {\r\n            exshift += x;\r\n            for ( i = low; i <= n; i++ ) {\r\n              H[ i * n + i ] -= x;\r\n            }\r\n            s = Math.abs( H[ n * n + n - 1 ] ) + Math.abs( H[ (n - 1) * n + n - 2 ] );\r\n            x = y = 0.75 * s;\r\n            w = -0.4375 * s * s;\r\n          }\r\n\r\n          // MATLAB's new ad hoc shift\r\n\r\n          if ( iter === 30 ) {\r\n            s = (y - x) / 2.0;\r\n            s = s * s + w;\r\n            if ( s > 0 ) {\r\n              s = Math.sqrt( s );\r\n              if ( y < x ) {\r\n                s = -s;\r\n              }\r\n              s = x - w / ((y - x) / 2.0 + s);\r\n              for ( i = low; i <= n; i++ ) {\r\n                H[ i * n + i ] -= s;\r\n              }\r\n              exshift += s;\r\n              x = y = w = 0.964;\r\n            }\r\n          }\r\n\r\n          iter = iter + 1;   // (Could check iteration count here.)\r\n\r\n          // Look for two consecutive small sub-diagonal elements\r\n\r\n          m = n - 2;\r\n          while ( m >= l ) {\r\n            z = H[ m * n + m ];\r\n            r = x - z;\r\n            s = y - z;\r\n            p = (r * s - w) / H[ (m + 1) * n + m ] + H[ m * n + m + 1 ];\r\n            q = H[ (m + 1) * n + m + 1 ] - z - r - s;\r\n            r = H[ (m + 2) * n + m + 1 ];\r\n            s = Math.abs( p ) + Math.abs( q ) + Math.abs( r );\r\n            p = p / s;\r\n            q = q / s;\r\n            r = r / s;\r\n            if ( m === l ) {\r\n              break;\r\n            }\r\n            if ( Math.abs( H[ m * n + (m - 1) ] ) * (Math.abs( q ) + Math.abs( r )) <\r\n                 eps * (Math.abs( p ) * (Math.abs( H[ (m - 1) * n + m - 1 ] ) + Math.abs( z ) +\r\n                                         Math.abs( H[ (m + 1) * n + m + 1 ] ))) ) {\r\n              break;\r\n            }\r\n            m--;\r\n          }\r\n\r\n          for ( i = m + 2; i <= n; i++ ) {\r\n            H[ i * n + i - 2 ] = 0.0;\r\n            if ( i > m + 2 ) {\r\n              H[ i * n + i - 3 ] = 0.0;\r\n            }\r\n          }\r\n\r\n          // Double QR step involving rows l:n and columns m:n\r\n\r\n          for ( k = m; k <= n - 1; k++ ) {\r\n            var notlast = (k !== n - 1);\r\n            if ( k !== m ) {\r\n              p = H[ k * n + k - 1 ];\r\n              q = H[ (k + 1) * n + k - 1 ];\r\n              r = (notlast ? H[ (k + 2) * n + k - 1 ] : 0.0);\r\n              x = Math.abs( p ) + Math.abs( q ) + Math.abs( r );\r\n              if ( x !== 0.0 ) {\r\n                p = p / x;\r\n                q = q / x;\r\n                r = r / x;\r\n              }\r\n            }\r\n            if ( x === 0.0 ) {\r\n              break;\r\n            }\r\n            s = Math.sqrt( p * p + q * q + r * r );\r\n            if ( p < 0 ) {\r\n              s = -s;\r\n            }\r\n            if ( s !== 0 ) {\r\n              if ( k !== m ) {\r\n                H[ k * n + k - 1 ] = -s * x;\r\n              }\r\n              else if ( l !== m ) {\r\n                H[ k * n + k - 1 ] = -H[ k * n + k - 1 ];\r\n              }\r\n              p = p + s;\r\n              x = p / s;\r\n              y = q / s;\r\n              z = r / s;\r\n              q = q / p;\r\n              r = r / p;\r\n\r\n              // Row modification\r\n\r\n              for ( j = k; j < nn; j++ ) {\r\n                p = H[ k * n + j ] + q * H[ (k + 1) * n + j ];\r\n                if ( notlast ) {\r\n                  p = p + r * H[ (k + 2) * n + j ];\r\n                  H[ (k + 2) * n + j ] = H[ (k + 2) * n + j ] - p * z;\r\n                }\r\n                H[ k * n + j ] = H[ k * n + j ] - p * x;\r\n                H[ (k + 1) * n + j ] = H[ (k + 1) * n + j ] - p * y;\r\n              }\r\n\r\n              // Column modification\r\n\r\n              for ( i = 0; i <= Math.min( n, k + 3 ); i++ ) {\r\n                p = x * H[ i * n + k ] + y * H[ i * n + k + 1 ];\r\n                if ( notlast ) {\r\n                  p = p + z * H[ i * n + k + 2 ];\r\n                  H[ i * n + k + 2 ] = H[ i * n + k + 2 ] - p * r;\r\n                }\r\n                H[ i * n + k ] = H[ i * n + k ] - p;\r\n                H[ i * n + k + 1 ] = H[ i * n + k + 1 ] - p * q;\r\n              }\r\n\r\n              // Accumulate transformations\r\n\r\n              for ( i = low; i <= high; i++ ) {\r\n                p = x * V[ i * n + k ] + y * V[ i * n + k + 1 ];\r\n                if ( notlast ) {\r\n                  p = p + z * V[ i * n + k + 2 ];\r\n                  V[ i * n + k + 2 ] = V[ i * n + k + 2 ] - p * r;\r\n                }\r\n                V[ i * n + k ] = V[ i * n + k ] - p;\r\n                V[ i * n + k + 1 ] = V[ i * n + k + 1 ] - p * q;\r\n              }\r\n            }  // (s !== 0)\r\n          }  // k loop\r\n        }  // check convergence\r\n      }  // while (n >= low)\r\n\r\n      // Backsubstitute to find vectors of upper triangular form\r\n\r\n      if ( norm === 0.0 ) {\r\n        return;\r\n      }\r\n\r\n      for ( n = nn - 1; n >= 0; n-- ) {\r\n        p = d[ n ];\r\n        q = e[ n ];\r\n\r\n        // Real vector\r\n\r\n        if ( q === 0 ) {\r\n          l = n;\r\n          H[ n * n + n ] = 1.0;\r\n          for ( i = n - 1; i >= 0; i-- ) {\r\n            w = H[ i * n + i ] - p;\r\n            r = 0.0;\r\n            for ( j = l; j <= n; j++ ) {\r\n              r = r + H[ i * this.n + j ] * H[ j * n + n ];\r\n            }\r\n            if ( e[ i ] < 0.0 ) {\r\n              z = w;\r\n              s = r;\r\n            }\r\n            else {\r\n              l = i;\r\n              if ( e[ i ] === 0.0 ) {\r\n                if ( w !== 0.0 ) {\r\n                  H[ i * n + n ] = -r / w;\r\n                }\r\n                else {\r\n                  H[ i * n + n ] = -r / (eps * norm);\r\n                }\r\n\r\n                // Solve real equations\r\n\r\n              }\r\n              else {\r\n                x = H[ i * n + i + 1 ];\r\n                y = H[ (i + 1) * n + i ];\r\n                q = (d[ i ] - p) * (d[ i ] - p) + e[ i ] * e[ i ];\r\n                t = (x * s - z * r) / q;\r\n                H[ i * n + n ] = t;\r\n                if ( Math.abs( x ) > Math.abs( z ) ) {\r\n                  H[ (i + 1) * n + n ] = (-r - w * t) / x;\r\n                }\r\n                else {\r\n                  H[ (i + 1) * n + n ] = (-s - y * t) / z;\r\n                }\r\n              }\r\n\r\n              // Overflow control\r\n\r\n              t = Math.abs( H[ i * n + n ] );\r\n              if ( (eps * t) * t > 1 ) {\r\n                for ( j = i; j <= n; j++ ) {\r\n                  H[ j * n + n ] = H[ j * n + n ] / t;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Complex vector\r\n\r\n        }\r\n        else if ( q < 0 ) {\r\n          l = n - 1;\r\n\r\n          // Last vector component imaginary so matrix is triangular\r\n\r\n          if ( Math.abs( H[ n * n + n - 1 ] ) > Math.abs( H[ (n - 1) * n + n ] ) ) {\r\n            H[ (n - 1) * n + (n - 1) ] = q / H[ n * n + n - 1 ];\r\n            H[ (n - 1) * n + n ] = -(H[ n * n + n ] - p) / H[ n * n + n - 1 ];\r\n          }\r\n          else {\r\n            this.cdiv( 0.0, -H[ (n - 1) * n + n ], H[ (n - 1) * n + (n - 1) ] - p, q );\r\n            H[ (n - 1) * n + (n - 1) ] = this.cdivr;\r\n            H[ (n - 1) * n + n ] = this.cdivi;\r\n          }\r\n          H[ n * n + n - 1 ] = 0.0;\r\n          H[ n * n + n ] = 1.0;\r\n          for ( i = n - 2; i >= 0; i-- ) {\r\n            var ra, sa, vr, vi;\r\n            ra = 0.0;\r\n            sa = 0.0;\r\n            for ( j = l; j <= n; j++ ) {\r\n              ra = ra + H[ i * this.n + j ] * H[ j * n + n - 1 ];\r\n              sa = sa + H[ i * this.n + j ] * H[ j * n + n ];\r\n            }\r\n            w = H[ i * n + i ] - p;\r\n\r\n            if ( e[ i ] < 0.0 ) {\r\n              z = w;\r\n              r = ra;\r\n              s = sa;\r\n            }\r\n            else {\r\n              l = i;\r\n              if ( e[ i ] === 0 ) {\r\n                this.cdiv( -ra, -sa, w, q );\r\n                H[ i * n + n - 1 ] = this.cdivr;\r\n                H[ i * n + n ] = this.cdivi;\r\n              }\r\n              else {\r\n\r\n                // Solve complex equations\r\n\r\n                x = H[ i * n + i + 1 ];\r\n                y = H[ (i + 1) * n + i ];\r\n                vr = (d[ i ] - p) * (d[ i ] - p) + e[ i ] * e[ i ] - q * q;\r\n                vi = (d[ i ] - p) * 2.0 * q;\r\n                if ( vr === 0.0 && vi === 0.0 ) {\r\n                  vr = eps * norm * (Math.abs( w ) + Math.abs( q ) +\r\n                                     Math.abs( x ) + Math.abs( y ) + Math.abs( z ));\r\n                }\r\n                this.cdiv( x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi );\r\n                H[ i * n + n - 1 ] = this.cdivr;\r\n                H[ i * n + n ] = this.cdivi;\r\n                if ( Math.abs( x ) > (Math.abs( z ) + Math.abs( q )) ) {\r\n                  H[ (i + 1) * n + n - 1 ] = (-ra - w * H[ i * n + n - 1 ] + q * H[ i * n + n ]) / x;\r\n                  H[ (i + 1) * n + n ] = (-sa - w * H[ i * n + n ] - q * H[ i * n + n - 1 ]) / x;\r\n                }\r\n                else {\r\n                  this.cdiv( -r - y * H[ i * n + n - 1 ], -s - y * H[ i * n + n ], z, q );\r\n                  H[ (i + 1) * n + n - 1 ] = this.cdivr;\r\n                  H[ (i + 1) * n + n ] = this.cdivi;\r\n                }\r\n              }\r\n\r\n              // Overflow control\r\n              t = Math.max( Math.abs( H[ i * n + n - 1 ] ), Math.abs( H[ i * n + n ] ) );\r\n              if ( (eps * t) * t > 1 ) {\r\n                for ( j = i; j <= n; j++ ) {\r\n                  H[ j * n + n - 1 ] = H[ j * n + n - 1 ] / t;\r\n                  H[ j * n + n ] = H[ j * n + n ] / t;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Vectors of isolated roots\r\n      for ( i = 0; i < nn; i++ ) {\r\n        if ( i < low || i > high ) {\r\n          for ( j = i; j < nn; j++ ) {\r\n            V[ i * this.n + j ] = H[ i * this.n + j ];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Back transformation to get eigenvectors of original matrix\r\n      for ( j = nn - 1; j >= low; j-- ) {\r\n        for ( i = low; i <= high; i++ ) {\r\n          z = 0.0;\r\n          for ( k = low; k <= Math.min( j, high ); k++ ) {\r\n            z = z + V[ i * n + k ] * H[ k * n + j ];\r\n          }\r\n          V[ i * this.n + j ] = z;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return EigenvalueDecomposition;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Function for doing a linear mapping between two domains ('a' and 'b').\r\n * <p>\r\n * Example usage:\r\n * <code>\r\n * var f = new dot.LinearFunction( 0, 100, 0, 200 );\r\n * f( 50 ); // 100\r\n * f.inverse( 100 ); // 50\r\n * </code>\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  // modules\r\n  require( 'DOT/Util' );\r\n\r\n  /**\r\n   * @param {Number} a1\r\n   * @param {Number} a2\r\n   * @param {Number} b1\r\n   * @param {Number} b2\r\n   * @param {Boolean} clamp clamp the result to the provided ranges, false by default\r\n   * @constructor\r\n   */\r\n  dot.LinearFunction = function LinearFunction( a1, a2, b1, b2, clamp ) {\r\n\r\n    clamp = _.isUndefined( clamp ) ? false : clamp;\r\n\r\n    /*\r\n     * Linearly interpolate two points and evaluate the line equation for a third point.\r\n     * f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>\r\n     * Optionally clamp the result to the range [b1,b2].\r\n     */\r\n    var map = function( a1, a2, b1, b2, a3, clamp ) {\r\n      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );\r\n      if ( clamp ) {\r\n        var max = Math.max( b1, b2 );\r\n        var min = Math.min( b1, b2 );\r\n        b3 = dot.Util.clamp( b3, min, max );\r\n      }\r\n      return b3;\r\n    };\r\n\r\n    // Maps from a to b.\r\n    var evaluate = function( a3 ) {\r\n      return map( a1, a2, b1, b2, a3, clamp );\r\n    };\r\n\r\n    // Maps from b to a.\r\n    evaluate.inverse = function( b3 ) {\r\n      return map( b1, b2, a1, a2, b3, clamp );\r\n    };\r\n\r\n    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)\r\n  };\r\n\r\n  return dot.LinearFunction;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * LU decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/LUDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.LUDecomposition = function LUDecomposition( matrix ) {\r\n    var i, j, k;\r\n\r\n    this.matrix = matrix;\r\n\r\n    // TODO: size!\r\n    this.LU = matrix.getArrayCopy();\r\n    var LU = this.LU;\r\n    this.m = matrix.getRowDimension();\r\n    var m = this.m;\r\n    this.n = matrix.getColumnDimension();\r\n    var n = this.n;\r\n    this.piv = new Uint32Array( m );\r\n    for ( i = 0; i < m; i++ ) {\r\n      this.piv[ i ] = i;\r\n    }\r\n    this.pivsign = 1;\r\n    var LUcolj = new Float32Array( m );\r\n\r\n    // Outer loop.\r\n\r\n    for ( j = 0; j < n; j++ ) {\r\n\r\n      // Make a copy of the j-th column to localize references.\r\n      for ( i = 0; i < m; i++ ) {\r\n        LUcolj[ i ] = LU[ matrix.index( i, j ) ];\r\n      }\r\n\r\n      // Apply previous transformations.\r\n\r\n      for ( i = 0; i < m; i++ ) {\r\n        // Most of the time is spent in the following dot product.\r\n        var kmax = Math.min( i, j );\r\n        var s = 0.0;\r\n        for ( k = 0; k < kmax; k++ ) {\r\n          var ik = matrix.index( i, k );\r\n          s += LU[ ik ] * LUcolj[ k ];\r\n        }\r\n\r\n        LUcolj[ i ] -= s;\r\n        LU[ matrix.index( i, j ) ] = LUcolj[ i ];\r\n      }\r\n\r\n      // Find pivot and exchange if necessary.\r\n\r\n      var p = j;\r\n      for ( i = j + 1; i < m; i++ ) {\r\n        if ( Math.abs( LUcolj[ i ] ) > Math.abs( LUcolj[ p ] ) ) {\r\n          p = i;\r\n        }\r\n      }\r\n      if ( p !== j ) {\r\n        for ( k = 0; k < n; k++ ) {\r\n          var pk = matrix.index( p, k );\r\n          var jk = matrix.index( j, k );\r\n          var t = LU[ pk ];\r\n          LU[ pk ] = LU[ jk ];\r\n          LU[ jk ] = t;\r\n        }\r\n        k = this.piv[ p ];\r\n        this.piv[ p ] = this.piv[ j ];\r\n        this.piv[ j ] = k;\r\n        this.pivsign = -this.pivsign;\r\n      }\r\n\r\n      // Compute multipliers.\r\n\r\n      if ( j < m && LU[ this.matrix.index( j, j ) ] !== 0.0 ) {\r\n        for ( i = j + 1; i < m; i++ ) {\r\n          LU[ matrix.index( i, j ) ] /= LU[ matrix.index( j, j ) ];\r\n        }\r\n      }\r\n    }\r\n  };\r\n  var LUDecomposition = dot.LUDecomposition;\r\n\r\n  LUDecomposition.prototype = {\r\n    constructor: LUDecomposition,\r\n\r\n    isNonsingular: function() {\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        var index = this.matrix.index( j, j );\r\n        if ( this.LU[ index ] === 0 ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    getL: function() {\r\n      var result = new dot.Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i > j ) {\r\n            result.entries[ result.index( i, j ) ] = this.LU[ this.matrix.index( i, j ) ];\r\n          }\r\n          else if ( i === j ) {\r\n            result.entries[ result.index( i, j ) ] = 1.0;\r\n          }\r\n          else {\r\n            result.entries[ result.index( i, j ) ] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getU: function() {\r\n      var result = new dot.Matrix( this.n, this.n );\r\n      for ( var i = 0; i < this.n; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i <= j ) {\r\n            result.entries[ result.index( i, j ) ] = this.LU[ this.matrix.index( i, j ) ];\r\n          }\r\n          else {\r\n            result.entries[ result.index( i, j ) ] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getPivot: function() {\r\n      var p = new Uint32Array( this.m );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        p[ i ] = this.piv[ i ];\r\n      }\r\n      return p;\r\n    },\r\n\r\n    getDoublePivot: function() {\r\n      var vals = new Float32Array( this.m );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        vals[ i ] = this.piv[ i ];\r\n      }\r\n      return vals;\r\n    },\r\n\r\n    det: function() {\r\n      if ( this.m !== this.n ) {\r\n        throw new Error( \"Matrix must be square.\" );\r\n      }\r\n      var d = this.pivsign;\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        d *= this.LU[ this.matrix.index( j, j ) ];\r\n      }\r\n      return d;\r\n    },\r\n\r\n    solve: function( matrix ) {\r\n      var i, j, k;\r\n      if ( matrix.getRowDimension() !== this.m ) {\r\n        throw new Error( \"Matrix row dimensions must agree.\" );\r\n      }\r\n      if ( !this.isNonsingular() ) {\r\n        throw new Error( \"Matrix is singular.\" );\r\n      }\r\n\r\n      // Copy right hand side with pivoting\r\n      var nx = matrix.getColumnDimension();\r\n      var Xmat = matrix.getArrayRowMatrix( this.piv, 0, nx - 1 );\r\n\r\n      // Solve L*Y = B(piv,:)\r\n      for ( k = 0; k < this.n; k++ ) {\r\n        for ( i = k + 1; i < this.n; i++ ) {\r\n          for ( j = 0; j < nx; j++ ) {\r\n            Xmat.entries[ Xmat.index( i, j ) ] -= Xmat.entries[ Xmat.index( k, j ) ] * this.LU[ this.matrix.index( i, k ) ];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Solve U*X = Y;\r\n      for ( k = this.n - 1; k >= 0; k-- ) {\r\n        for ( j = 0; j < nx; j++ ) {\r\n          Xmat.entries[ Xmat.index( k, j ) ] /= this.LU[ this.matrix.index( k, k ) ];\r\n        }\r\n        for ( i = 0; i < k; i++ ) {\r\n          for ( j = 0; j < nx; j++ ) {\r\n            Xmat.entries[ Xmat.index( i, j ) ] -= Xmat.entries[ Xmat.index( k, j ) ] * this.LU[ this.matrix.index( i, k ) ];\r\n          }\r\n        }\r\n      }\r\n      return Xmat;\r\n    }\r\n  };\r\n\r\n  return LUDecomposition;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * SVD decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/SingularValueDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.SingularValueDecomposition = function SingularValueDecomposition( matrix ) {\r\n    this.matrix = matrix;\r\n\r\n    var Arg = matrix;\r\n\r\n    // Derived from LINPACK code.\r\n    // Initialize.\r\n    var A = Arg.getArrayCopy();\r\n    this.m = Arg.getRowDimension();\r\n    this.n = Arg.getColumnDimension();\r\n    var m = this.m;\r\n    var n = this.n;\r\n\r\n    var min = Math.min;\r\n    var max = Math.max;\r\n    var pow = Math.pow;\r\n    var abs = Math.abs;\r\n\r\n    /* Apparently the failing cases are only a proper subset of (m<n),\r\n     so let's not throw error.  Correct fix to come later?\r\n     if (m<n) {\r\n     throw new IllegalArgumentException(\"Jama SVD only works for m >= n\"); }\r\n     */\r\n    var nu = min( m, n );\r\n    this.s = new Float32Array( min( m + 1, n ) );\r\n    var s = this.s;\r\n    this.U = new Float32Array( m * nu );\r\n    var U = this.U;\r\n    this.V = new Float32Array( n * n );\r\n    var V = this.V;\r\n    var e = new Float32Array( n );\r\n    var work = new Float32Array( m );\r\n    var wantu = true;\r\n    var wantv = true;\r\n\r\n    var i, j, k, t, f;\r\n    var cs, sn;\r\n\r\n    var hypot = dot.Matrix.hypot;\r\n\r\n    // Reduce A to bidiagonal form, storing the diagonal elements\r\n    // in s and the super-diagonal elements in e.\r\n\r\n    var nct = min( m - 1, n );\r\n    var nrt = max( 0, min( n - 2, m ) );\r\n    for ( k = 0; k < max( nct, nrt ); k++ ) {\r\n      if ( k < nct ) {\r\n\r\n        // Compute the transformation for the k-th column and\r\n        // place the k-th diagonal in s[k].\r\n        // Compute 2-norm of k-th column without under/overflow.\r\n        s[ k ] = 0;\r\n        for ( i = k; i < m; i++ ) {\r\n          s[ k ] = hypot( s[ k ], A[ i * n + k ] );\r\n        }\r\n        if ( s[ k ] !== 0.0 ) {\r\n          if ( A[ k * n + k ] < 0.0 ) {\r\n            s[ k ] = -s[ k ];\r\n          }\r\n          for ( i = k; i < m; i++ ) {\r\n            A[ i * n + k ] /= s[ k ];\r\n          }\r\n          A[ k * n + k ] += 1.0;\r\n        }\r\n        s[ k ] = -s[ k ];\r\n      }\r\n      for ( j = k + 1; j < n; j++ ) {\r\n        if ( (k < nct) && (s[ k ] !== 0.0) ) {\r\n\r\n          // Apply the transformation.\r\n\r\n          t = 0;\r\n          for ( i = k; i < m; i++ ) {\r\n            t += A[ i * n + k ] * A[ i * n + j ];\r\n          }\r\n          t = -t / A[ k * n + k ];\r\n          for ( i = k; i < m; i++ ) {\r\n            A[ i * n + j ] += t * A[ i * n + k ];\r\n          }\r\n        }\r\n\r\n        // Place the k-th row of A into e for the\r\n        // subsequent calculation of the row transformation.\r\n\r\n        e[ j ] = A[ k * n + j ];\r\n      }\r\n      if ( wantu && (k < nct) ) {\r\n\r\n        // Place the transformation in U for subsequent back\r\n        // multiplication.\r\n\r\n        for ( i = k; i < m; i++ ) {\r\n          U[ i * nu + k ] = A[ i * n + k ];\r\n        }\r\n      }\r\n      if ( k < nrt ) {\r\n\r\n        // Compute the k-th row transformation and place the\r\n        // k-th super-diagonal in e[k].\r\n        // Compute 2-norm without under/overflow.\r\n        e[ k ] = 0;\r\n        for ( i = k + 1; i < n; i++ ) {\r\n          e[ k ] = hypot( e[ k ], e[ i ] );\r\n        }\r\n        if ( e[ k ] !== 0.0 ) {\r\n          if ( e[ k + 1 ] < 0.0 ) {\r\n            e[ k ] = -e[ k ];\r\n          }\r\n          for ( i = k + 1; i < n; i++ ) {\r\n            e[ i ] /= e[ k ];\r\n          }\r\n          e[ k + 1 ] += 1.0;\r\n        }\r\n        e[ k ] = -e[ k ];\r\n        if ( (k + 1 < m) && (e[ k ] !== 0.0) ) {\r\n\r\n          // Apply the transformation.\r\n\r\n          for ( i = k + 1; i < m; i++ ) {\r\n            work[ i ] = 0.0;\r\n          }\r\n          for ( j = k + 1; j < n; j++ ) {\r\n            for ( i = k + 1; i < m; i++ ) {\r\n              work[ i ] += e[ j ] * A[ i * n + j ];\r\n            }\r\n          }\r\n          for ( j = k + 1; j < n; j++ ) {\r\n            t = -e[ j ] / e[ k + 1 ];\r\n            for ( i = k + 1; i < m; i++ ) {\r\n              A[ i * n + j ] += t * work[ i ];\r\n            }\r\n          }\r\n        }\r\n        if ( wantv ) {\r\n\r\n          // Place the transformation in V for subsequent\r\n          // back multiplication.\r\n\r\n          for ( i = k + 1; i < n; i++ ) {\r\n            V[ i * n + k ] = e[ i ];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Set up the final bidiagonal matrix or order p.\r\n\r\n    var p = min( n, m + 1 );\r\n    if ( nct < n ) {\r\n      s[ nct ] = A[ nct * n + nct ];\r\n    }\r\n    if ( m < p ) {\r\n      s[ p - 1 ] = 0.0;\r\n    }\r\n    if ( nrt + 1 < p ) {\r\n      e[ nrt ] = A[ nrt * n + p - 1 ];\r\n    }\r\n    e[ p - 1 ] = 0.0;\r\n\r\n    // If required, generate U.\r\n\r\n    if ( wantu ) {\r\n      for ( j = nct; j < nu; j++ ) {\r\n        for ( i = 0; i < m; i++ ) {\r\n          U[ i * nu + j ] = 0.0;\r\n        }\r\n        U[ j * nu + j ] = 1.0;\r\n      }\r\n      for ( k = nct - 1; k >= 0; k-- ) {\r\n        if ( s[ k ] !== 0.0 ) {\r\n          for ( j = k + 1; j < nu; j++ ) {\r\n            t = 0;\r\n            for ( i = k; i < m; i++ ) {\r\n              t += U[ i * nu + k ] * U[ i * nu + j ];\r\n            }\r\n            t = -t / U[ k * nu + k ];\r\n            for ( i = k; i < m; i++ ) {\r\n              U[ i * nu + j ] += t * U[ i * nu + k ];\r\n            }\r\n          }\r\n          for ( i = k; i < m; i++ ) {\r\n            U[ i * nu + k ] = -U[ i * nu + k ];\r\n          }\r\n          U[ k * nu + k ] = 1.0 + U[ k * nu + k ];\r\n          for ( i = 0; i < k - 1; i++ ) {\r\n            U[ i * nu + k ] = 0.0;\r\n          }\r\n        }\r\n        else {\r\n          for ( i = 0; i < m; i++ ) {\r\n            U[ i * nu + k ] = 0.0;\r\n          }\r\n          U[ k * nu + k ] = 1.0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // If required, generate V.\r\n\r\n    if ( wantv ) {\r\n      for ( k = n - 1; k >= 0; k-- ) {\r\n        if ( (k < nrt) && (e[ k ] !== 0.0) ) {\r\n          for ( j = k + 1; j < nu; j++ ) {\r\n            t = 0;\r\n            for ( i = k + 1; i < n; i++ ) {\r\n              t += V[ i * n + k ] * V[ i * n + j ];\r\n            }\r\n            t = -t / V[ (k + 1) * n + k ];\r\n            for ( i = k + 1; i < n; i++ ) {\r\n              V[ i * n + j ] += t * V[ i * n + k ];\r\n            }\r\n          }\r\n        }\r\n        for ( i = 0; i < n; i++ ) {\r\n          V[ i * n + k ] = 0.0;\r\n        }\r\n        V[ k * n + k ] = 1.0;\r\n      }\r\n    }\r\n\r\n    // Main iteration loop for the singular values.\r\n\r\n    var pp = p - 1;\r\n    var iter = 0;\r\n    var eps = pow( 2.0, -52.0 );\r\n    var tiny = pow( 2.0, -966.0 );\r\n    while ( p > 0 ) {\r\n      var kase;\r\n\r\n      // Here is where a test for too many iterations would go.\r\n      if ( iter > 500 ) {\r\n        break;\r\n      }\r\n\r\n      // This section of the program inspects for\r\n      // negligible elements in the s and e arrays.  On\r\n      // completion the variables kase and k are set as follows.\r\n\r\n      // kase = 1   if s(p) and e[k-1] are negligible and k<p\r\n      // kase = 2   if s(k) is negligible and k<p\r\n      // kase = 3   if e[k-1] is negligible, k<p, and\r\n      //        s(k), ..., s(p) are not negligible (qr step).\r\n      // kase = 4   if e(p-1) is negligible (convergence).\r\n\r\n      for ( k = p - 2; k >= -1; k-- ) {\r\n        if ( k === -1 ) {\r\n          break;\r\n        }\r\n        if ( abs( e[ k ] ) <=\r\n             tiny + eps * (abs( s[ k ] ) + abs( s[ k + 1 ] )) ) {\r\n          e[ k ] = 0.0;\r\n          break;\r\n        }\r\n      }\r\n      if ( k === p - 2 ) {\r\n        kase = 4;\r\n      }\r\n      else {\r\n        var ks;\r\n        for ( ks = p - 1; ks >= k; ks-- ) {\r\n          if ( ks === k ) {\r\n            break;\r\n          }\r\n          t = (ks !== p ? abs( e[ ks ] ) : 0) +\r\n              (ks !== k + 1 ? abs( e[ ks - 1 ] ) : 0);\r\n          if ( abs( s[ ks ] ) <= tiny + eps * t ) {\r\n            s[ ks ] = 0.0;\r\n            break;\r\n          }\r\n        }\r\n        if ( ks === k ) {\r\n          kase = 3;\r\n        }\r\n        else if ( ks === p - 1 ) {\r\n          kase = 1;\r\n        }\r\n        else {\r\n          kase = 2;\r\n          k = ks;\r\n        }\r\n      }\r\n      k++;\r\n\r\n      // Perform the task indicated by kase.\r\n\r\n      switch( kase ) {\r\n\r\n        // Deflate negligible s(p).\r\n\r\n        case 1:\r\n        {\r\n          f = e[ p - 2 ];\r\n          e[ p - 2 ] = 0.0;\r\n          for ( j = p - 2; j >= k; j-- ) {\r\n            t = hypot( s[ j ], f );\r\n            cs = s[ j ] / t;\r\n            sn = f / t;\r\n            s[ j ] = t;\r\n            if ( j !== k ) {\r\n              f = -sn * e[ j - 1 ];\r\n              e[ j - 1 ] = cs * e[ j - 1 ];\r\n            }\r\n            if ( wantv ) {\r\n              for ( i = 0; i < n; i++ ) {\r\n                t = cs * V[ i * n + j ] + sn * V[ i * n + p - 1 ];\r\n                V[ i * n + p - 1 ] = -sn * V[ i * n + j ] + cs * V[ i * n + p - 1 ];\r\n                V[ i * n + j ] = t;\r\n              }\r\n            }\r\n          }\r\n        }\r\n          break;\r\n\r\n        // Split at negligible s(k).\r\n\r\n        case 2:\r\n        {\r\n          f = e[ k - 1 ];\r\n          e[ k - 1 ] = 0.0;\r\n          for ( j = k; j < p; j++ ) {\r\n            t = hypot( s[ j ], f );\r\n            cs = s[ j ] / t;\r\n            sn = f / t;\r\n            s[ j ] = t;\r\n            f = -sn * e[ j ];\r\n            e[ j ] = cs * e[ j ];\r\n            if ( wantu ) {\r\n              for ( i = 0; i < m; i++ ) {\r\n                t = cs * U[ i * nu + j ] + sn * U[ i * nu + k - 1 ];\r\n                U[ i * nu + k - 1 ] = -sn * U[ i * nu + j ] + cs * U[ i * nu + k - 1 ];\r\n                U[ i * nu + j ] = t;\r\n              }\r\n            }\r\n          }\r\n        }\r\n          break;\r\n\r\n        // Perform one qr step.\r\n\r\n        case 3:\r\n        {\r\n\r\n          // Calculate the shift.\r\n\r\n          var scale = max( max( max( max(\r\n              abs( s[ p - 1 ] ), abs( s[ p - 2 ] ) ), abs( e[ p - 2 ] ) ),\r\n            abs( s[ k ] ) ), abs( e[ k ] ) );\r\n          var sp = s[ p - 1 ] / scale;\r\n          var spm1 = s[ p - 2 ] / scale;\r\n          var epm1 = e[ p - 2 ] / scale;\r\n          var sk = s[ k ] / scale;\r\n          var ek = e[ k ] / scale;\r\n          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\r\n          var c = (sp * epm1) * (sp * epm1);\r\n          var shift = 0.0;\r\n          if ( (b !== 0.0) || (c !== 0.0) ) {\r\n            shift = Math.sqrt( b * b + c );\r\n            if ( b < 0.0 ) {\r\n              shift = -shift;\r\n            }\r\n            shift = c / (b + shift);\r\n          }\r\n          f = (sk + sp) * (sk - sp) + shift;\r\n          var g = sk * ek;\r\n\r\n          // Chase zeros.\r\n\r\n          for ( j = k; j < p - 1; j++ ) {\r\n            t = hypot( f, g );\r\n            cs = f / t;\r\n            sn = g / t;\r\n            if ( j !== k ) {\r\n              e[ j - 1 ] = t;\r\n            }\r\n            f = cs * s[ j ] + sn * e[ j ];\r\n            e[ j ] = cs * e[ j ] - sn * s[ j ];\r\n            g = sn * s[ j + 1 ];\r\n            s[ j + 1 ] = cs * s[ j + 1 ];\r\n            if ( wantv ) {\r\n              for ( i = 0; i < n; i++ ) {\r\n                t = cs * V[ i * n + j ] + sn * V[ i * n + j + 1 ];\r\n                V[ i * n + j + 1 ] = -sn * V[ i * n + j ] + cs * V[ i * n + j + 1 ];\r\n                V[ i * n + j ] = t;\r\n              }\r\n            }\r\n            t = hypot( f, g );\r\n            cs = f / t;\r\n            sn = g / t;\r\n            s[ j ] = t;\r\n            f = cs * e[ j ] + sn * s[ j + 1 ];\r\n            s[ j + 1 ] = -sn * e[ j ] + cs * s[ j + 1 ];\r\n            g = sn * e[ j + 1 ];\r\n            e[ j + 1 ] = cs * e[ j + 1 ];\r\n            if ( wantu && (j < m - 1) ) {\r\n              for ( i = 0; i < m; i++ ) {\r\n                t = cs * U[ i * nu + j ] + sn * U[ i * nu + j + 1 ];\r\n                U[ i * nu + j + 1 ] = -sn * U[ i * nu + j ] + cs * U[ i * nu + j + 1 ];\r\n                U[ i * nu + j ] = t;\r\n              }\r\n            }\r\n          }\r\n          e[ p - 2 ] = f;\r\n          iter = iter + 1;\r\n        }\r\n          break;\r\n\r\n        // Convergence.\r\n\r\n        case 4:\r\n        {\r\n\r\n          // Make the singular values positive.\r\n\r\n          if ( s[ k ] <= 0.0 ) {\r\n            s[ k ] = (s[ k ] < 0.0 ? -s[ k ] : 0.0);\r\n            if ( wantv ) {\r\n              for ( i = 0; i <= pp; i++ ) {\r\n                V[ i * n + k ] = -V[ i * n + k ];\r\n              }\r\n            }\r\n          }\r\n\r\n          // Order the singular values.\r\n\r\n          while ( k < pp ) {\r\n            if ( s[ k ] >= s[ k + 1 ] ) {\r\n              break;\r\n            }\r\n            t = s[ k ];\r\n            s[ k ] = s[ k + 1 ];\r\n            s[ k + 1 ] = t;\r\n            if ( wantv && (k < n - 1) ) {\r\n              for ( i = 0; i < n; i++ ) {\r\n                t = V[ i * n + k + 1 ];\r\n                V[ i * n + k + 1 ] = V[ i * n + k ];\r\n                V[ i * n + k ] = t;\r\n              }\r\n            }\r\n            if ( wantu && (k < m - 1) ) {\r\n              for ( i = 0; i < m; i++ ) {\r\n                t = U[ i * nu + k + 1 ];\r\n                U[ i * nu + k + 1 ] = U[ i * nu + k ];\r\n                U[ i * nu + k ] = t;\r\n              }\r\n            }\r\n            k++;\r\n          }\r\n          iter = 0;\r\n          p--;\r\n        }\r\n          break;\r\n      }\r\n    }\r\n  };\r\n  var SingularValueDecomposition = dot.SingularValueDecomposition;\r\n\r\n  SingularValueDecomposition.prototype = {\r\n    constructor: SingularValueDecomposition,\r\n\r\n    getU: function() {\r\n      return new dot.Matrix( this.m, Math.min( this.m + 1, this.n ), this.U, true ); // the \"fast\" flag added, since U is Float32Array\r\n    },\r\n\r\n    getV: function() {\r\n      return new dot.Matrix( this.n, this.n, this.V, true );\r\n    },\r\n\r\n    getSingularValues: function() {\r\n      return this.s;\r\n    },\r\n\r\n    getS: function() {\r\n      var result = new dot.Matrix( this.n, this.n );\r\n      for ( var i = 0; i < this.n; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          result.entries[ result.index( i, j ) ] = 0.0;\r\n        }\r\n        result.entries[ result.index( i, i ) ] = this.s[ i ];\r\n      }\r\n      return result;\r\n    },\r\n\r\n    norm2: function() {\r\n      return this.s[ 0 ];\r\n    },\r\n\r\n    cond: function() {\r\n      return this.s[ 0 ] / this.s[ Math.min( this.m, this.n ) - 1 ];\r\n    },\r\n\r\n    rank: function() {\r\n      // changed to 23 from 52 (bits of mantissa), since we are using floats here!\r\n      var eps = Math.pow( 2.0, -23.0 );\r\n      var tol = Math.max( this.m, this.n ) * this.s[ 0 ] * eps;\r\n      var r = 0;\r\n      for ( var i = 0; i < this.s.length; i++ ) {\r\n        if ( this.s[ i ] > tol ) {\r\n          r++;\r\n        }\r\n      }\r\n      return r;\r\n    }\r\n  };\r\n\r\n  return SingularValueDecomposition;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Tests whether a reference is to an array.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/isArray',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.isArray = function isArray( array ) {\r\n    // yes, this is actually how to do this. see http://stackoverflow.com/questions/4775722/javascript-check-if-object-is-array\r\n    return Object.prototype.toString.call( array ) === '[object Array]';\r\n  };\r\n\r\n  return core.isArray;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * QR decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/QRDecomposition',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency\r\n\r\n  dot.QRDecomposition = function QRDecomposition( matrix ) {\r\n    this.matrix = matrix;\r\n\r\n    // TODO: size!\r\n    this.QR = matrix.getArrayCopy();\r\n    var QR = this.QR;\r\n    this.m = matrix.getRowDimension();\r\n    var m = this.m;\r\n    this.n = matrix.getColumnDimension();\r\n    var n = this.n;\r\n\r\n    this.Rdiag = new Float32Array( n );\r\n\r\n    var i, j, k;\r\n\r\n    // Main loop.\r\n    for ( k = 0; k < n; k++ ) {\r\n      // Compute 2-norm of k-th column without under/overflow.\r\n      var nrm = 0;\r\n      for ( i = k; i < m; i++ ) {\r\n        nrm = dot.Matrix.hypot( nrm, QR[ this.matrix.index( i, k ) ] );\r\n      }\r\n\r\n      if ( nrm !== 0.0 ) {\r\n        // Form k-th Householder vector.\r\n        if ( QR[ this.matrix.index( k, k ) ] < 0 ) {\r\n          nrm = -nrm;\r\n        }\r\n        for ( i = k; i < m; i++ ) {\r\n          QR[ this.matrix.index( i, k ) ] /= nrm;\r\n        }\r\n        QR[ this.matrix.index( k, k ) ] += 1.0;\r\n\r\n        // Apply transformation to remaining columns.\r\n        for ( j = k + 1; j < n; j++ ) {\r\n          var s = 0.0;\r\n          for ( i = k; i < m; i++ ) {\r\n            s += QR[ this.matrix.index( i, k ) ] * QR[ this.matrix.index( i, j ) ];\r\n          }\r\n          s = -s / QR[ this.matrix.index( k, k ) ];\r\n          for ( i = k; i < m; i++ ) {\r\n            QR[ this.matrix.index( i, j ) ] += s * QR[ this.matrix.index( i, k ) ];\r\n          }\r\n        }\r\n      }\r\n      this.Rdiag[ k ] = -nrm;\r\n    }\r\n  };\r\n  var QRDecomposition = dot.QRDecomposition;\r\n\r\n  QRDecomposition.prototype = {\r\n    constructor: QRDecomposition,\r\n\r\n    isFullRank: function() {\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        if ( this.Rdiag[ j ] === 0 ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    getH: function() {\r\n      var result = new dot.Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i >= j ) {\r\n            result.entries[ result.index( i, j ) ] = this.QR[ this.matrix.index( i, j ) ];\r\n          }\r\n          else {\r\n            result.entries[ result.index( i, j ) ] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getR: function() {\r\n      var result = new dot.Matrix( this.n, this.n );\r\n      for ( var i = 0; i < this.n; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          if ( i < j ) {\r\n            result.entries[ result.index( i, j ) ] = this.QR[ this.matrix.index( i, j ) ];\r\n          }\r\n          else if ( i === j ) {\r\n            result.entries[ result.index( i, j ) ] = this.Rdiag[ i ];\r\n          }\r\n          else {\r\n            result.entries[ result.index( i, j ) ] = 0.0;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getQ: function() {\r\n      var i, j, k;\r\n      var result = new dot.Matrix( this.m, this.n );\r\n      for ( k = this.n - 1; k >= 0; k-- ) {\r\n        for ( i = 0; i < this.m; i++ ) {\r\n          result.entries[ result.index( i, k ) ] = 0.0;\r\n        }\r\n        result.entries[ result.index( k, k ) ] = 1.0;\r\n        for ( j = k; j < this.n; j++ ) {\r\n          if ( this.QR[ this.matrix.index( k, k ) ] !== 0 ) {\r\n            var s = 0.0;\r\n            for ( i = k; i < this.m; i++ ) {\r\n              s += this.QR[ this.matrix.index( i, k ) ] * result.entries[ result.index( i, j ) ];\r\n            }\r\n            s = -s / this.QR[ this.matrix.index( k, k ) ];\r\n            for ( i = k; i < this.m; i++ ) {\r\n              result.entries[ result.index( i, j ) ] += s * this.QR[ this.matrix.index( i, k ) ];\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    solve: function( matrix ) {\r\n      if ( matrix.getRowDimension() !== this.m ) {\r\n        throw new Error( \"Matrix row dimensions must agree.\" );\r\n      }\r\n      if ( !this.isFullRank() ) {\r\n        throw new Error( \"Matrix is rank deficient.\" );\r\n      }\r\n\r\n      var i, j, k;\r\n\r\n      // Copy right hand side\r\n      var nx = matrix.getColumnDimension();\r\n      var X = matrix.getArrayCopy();\r\n\r\n      // Compute Y = transpose(Q)*matrix\r\n      for ( k = 0; k < this.n; k++ ) {\r\n        for ( j = 0; j < nx; j++ ) {\r\n          var s = 0.0;\r\n          for ( i = k; i < this.m; i++ ) {\r\n            s += this.QR[ this.matrix.index( i, k ) ] * X[ matrix.index( i, j ) ];\r\n          }\r\n          s = -s / this.QR[ this.matrix.index( k, k ) ];\r\n          for ( i = k; i < this.m; i++ ) {\r\n            X[ matrix.index( i, j ) ] += s * this.QR[ this.matrix.index( i, k ) ];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Solve R*X = Y;\r\n      for ( k = this.n - 1; k >= 0; k-- ) {\r\n        for ( j = 0; j < nx; j++ ) {\r\n          X[ matrix.index( k, j ) ] /= this.Rdiag[ k ];\r\n        }\r\n        for ( i = 0; i < k; i++ ) {\r\n          for ( j = 0; j < nx; j++ ) {\r\n            X[ matrix.index( i, j ) ] -= X[ matrix.index( k, j ) ] * this.QR[ this.matrix.index( i, k ) ];\r\n          }\r\n        }\r\n      }\r\n      return new dot.Matrix( X, this.n, nx ).getMatrix( 0, this.n - 1, 0, nx - 1 );\r\n    }\r\n  };\r\n\r\n  return QRDecomposition;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Arbitrary-dimensional matrix, based on Jama (http://math.nist.gov/javanumerics/jama/)\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Matrix',['require','DOT/dot','PHET_CORE/isArray','DOT/SingularValueDecomposition','DOT/LUDecomposition','DOT/QRDecomposition','DOT/EigenvalueDecomposition','DOT/Vector2','DOT/Vector3','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Float32Array = window.Float32Array || Array;\r\n\r\n  var isArray = require( 'PHET_CORE/isArray' );\r\n\r\n  require( 'DOT/SingularValueDecomposition' );\r\n  require( 'DOT/LUDecomposition' );\r\n  require( 'DOT/QRDecomposition' );\r\n  require( 'DOT/EigenvalueDecomposition' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Vector4' );\r\n\r\n  dot.Matrix = function Matrix( m, n, filler, fast ) {\r\n    this.m = m;\r\n    this.n = n;\r\n\r\n    var size = m * n;\r\n    this.size = size;\r\n    var i;\r\n\r\n    if ( fast ) {\r\n      this.entries = filler;\r\n    }\r\n    else {\r\n      if ( !filler ) {\r\n        filler = 0;\r\n      }\r\n\r\n      // entries stored in row-major format\r\n      this.entries = new Float32Array( size );\r\n\r\n      if ( isArray( filler ) ) {\r\n        assert && assert( filler.length === size );\r\n\r\n        for ( i = 0; i < size; i++ ) {\r\n          this.entries[ i ] = filler[ i ];\r\n        }\r\n      }\r\n      else {\r\n        for ( i = 0; i < size; i++ ) {\r\n          this.entries[ i ] = filler;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  var Matrix = dot.Matrix;\r\n\r\n  /** sqrt(a^2 + b^2) without under/overflow. **/\r\n  Matrix.hypot = function hypot( a, b ) {\r\n    var r;\r\n    if ( Math.abs( a ) > Math.abs( b ) ) {\r\n      r = b / a;\r\n      r = Math.abs( a ) * Math.sqrt( 1 + r * r );\r\n    }\r\n    else if ( b !== 0 ) {\r\n      r = a / b;\r\n      r = Math.abs( b ) * Math.sqrt( 1 + r * r );\r\n    }\r\n    else {\r\n      r = 0.0;\r\n    }\r\n    return r;\r\n  };\r\n\r\n  Matrix.prototype = {\r\n    constructor: Matrix,\r\n\r\n    copy: function() {\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.size; i++ ) {\r\n        result.entries[ i ] = this.entries[ i ];\r\n      }\r\n      return result;\r\n    },\r\n\r\n    getArray: function() {\r\n      return this.entries;\r\n    },\r\n\r\n    getArrayCopy: function() {\r\n      return new Float32Array( this.entries );\r\n    },\r\n\r\n    getRowDimension: function() {\r\n      return this.m;\r\n    },\r\n\r\n    getColumnDimension: function() {\r\n      return this.n;\r\n    },\r\n\r\n    // TODO: inline this places if we aren't using an inlining compiler! (check performance)\r\n    index: function( i, j ) {\r\n      return i * this.n + j;\r\n    },\r\n\r\n    get: function( i, j ) {\r\n      return this.entries[ this.index( i, j ) ];\r\n    },\r\n\r\n    set: function( i, j, s ) {\r\n      this.entries[ this.index( i, j ) ] = s;\r\n    },\r\n\r\n    getMatrix: function( i0, i1, j0, j1 ) {\r\n      var result = new Matrix( i1 - i0 + 1, j1 - j0 + 1 );\r\n      for ( var i = i0; i <= i1; i++ ) {\r\n        for ( var j = j0; j <= j1; j++ ) {\r\n          result.entries[ result.index( i - i0, j - j0 ) ] = this.entries[ this.index( i, j ) ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    // getMatrix (int[] r, int j0, int j1)\r\n    getArrayRowMatrix: function( r, j0, j1 ) {\r\n      var result = new Matrix( r.length, j1 - j0 + 1 );\r\n      for ( var i = 0; i < r.length; i++ ) {\r\n        for ( var j = j0; j <= j1; j++ ) {\r\n          result.entries[ result.index( i, j - j0 ) ] = this.entries[ this.index( r[ i ], j ) ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    // allow passing in a pre-constructed matrix\r\n    transpose: function( result ) {\r\n      result = result || new Matrix( this.n, this.m );\r\n      assert && assert( result.m === this.n );\r\n      assert && assert( result.n === this.m );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          result.entries[ result.index( j, i ) ] = this.entries[ this.index( i, j ) ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    norm1: function() {\r\n      var f = 0;\r\n      for ( var j = 0; j < this.n; j++ ) {\r\n        var s = 0;\r\n        for ( var i = 0; i < this.m; i++ ) {\r\n          s += Math.abs( this.entries[ this.index( i, j ) ] );\r\n        }\r\n        f = Math.max( f, s );\r\n      }\r\n      return f;\r\n    },\r\n\r\n    norm2: function() {\r\n      return (new dot.SingularValueDecomposition( this ).norm2());\r\n    },\r\n\r\n    normInf: function() {\r\n      var f = 0;\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        var s = 0;\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          s += Math.abs( this.entries[ this.index( i, j ) ] );\r\n        }\r\n        f = Math.max( f, s );\r\n      }\r\n      return f;\r\n    },\r\n\r\n    normF: function() {\r\n      var f = 0;\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          f = Matrix.hypot( f, this.entries[ this.index( i, j ) ] );\r\n        }\r\n      }\r\n      return f;\r\n    },\r\n\r\n    uminus: function() {\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          result.entries[ result.index( i, j ) ] = -this.entries[ this.index( i, j ) ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    plus: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = result.index( i, j );\r\n          result.entries[ index ] = this.entries[ index ] + matrix.entries[ index ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    plusEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = result.index( i, j );\r\n          this.entries[ index ] = this.entries[ index ] + matrix.entries[ index ];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    minus: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          result.entries[ index ] = this.entries[ index ] - matrix.entries[ index ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    minusEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[ index ] = this.entries[ index ] - matrix.entries[ index ];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    arrayTimes: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = result.index( i, j );\r\n          result.entries[ index ] = this.entries[ index ] * matrix.entries[ index ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    arrayTimesEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[ index ] = this.entries[ index ] * matrix.entries[ index ];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    arrayRightDivide: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          result.entries[ index ] = this.entries[ index ] / matrix.entries[ index ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    arrayRightDivideEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[ index ] = this.entries[ index ] / matrix.entries[ index ];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    arrayLeftDivide: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      var result = new Matrix( this.m, this.n );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          result.entries[ index ] = matrix.entries[ index ] / this.entries[ index ];\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n\r\n    arrayLeftDivideEquals: function( matrix ) {\r\n      this.checkMatrixDimensions( matrix );\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[ index ] = matrix.entries[ index ] / this.entries[ index ];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    times: function( matrixOrScalar ) {\r\n      var result;\r\n      var i, j, k, s;\r\n      var matrix;\r\n      if ( matrixOrScalar.isMatrix ) {\r\n        matrix = matrixOrScalar;\r\n        if ( matrix.m !== this.n ) {\r\n          throw new Error( \"Matrix inner dimensions must agree.\" );\r\n        }\r\n        result = new Matrix( this.m, matrix.n );\r\n        var matrixcolj = new Float32Array( this.n );\r\n        for ( j = 0; j < matrix.n; j++ ) {\r\n          for ( k = 0; k < this.n; k++ ) {\r\n            matrixcolj[ k ] = matrix.entries[ matrix.index( k, j ) ];\r\n          }\r\n          for ( i = 0; i < this.m; i++ ) {\r\n            s = 0;\r\n            for ( k = 0; k < this.n; k++ ) {\r\n              s += this.entries[ this.index( i, k ) ] * matrixcolj[ k ];\r\n            }\r\n            result.entries[ result.index( i, j ) ] = s;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      else {\r\n        s = matrixOrScalar;\r\n        result = new Matrix( this.m, this.n );\r\n        for ( i = 0; i < this.m; i++ ) {\r\n          for ( j = 0; j < this.n; j++ ) {\r\n            result.entries[ result.index( i, j ) ] = s * this.entries[ this.index( i, j ) ];\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n    },\r\n\r\n    timesEquals: function( s ) {\r\n      for ( var i = 0; i < this.m; i++ ) {\r\n        for ( var j = 0; j < this.n; j++ ) {\r\n          var index = this.index( i, j );\r\n          this.entries[ index ] = s * this.entries[ index ];\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    solve: function( matrix ) {\r\n      return (this.m === this.n ? (new dot.LUDecomposition( this )).solve( matrix ) :\r\n              (new dot.QRDecomposition( this )).solve( matrix ));\r\n    },\r\n\r\n    solveTranspose: function( matrix ) {\r\n      return this.transpose().solve( matrix.transpose() );\r\n    },\r\n\r\n    inverse: function() {\r\n      return this.solve( Matrix.identity( this.m, this.m ) );\r\n    },\r\n\r\n    det: function() {\r\n      return new dot.LUDecomposition( this ).det();\r\n    },\r\n\r\n    rank: function() {\r\n      return new dot.SingularValueDecomposition( this ).rank();\r\n    },\r\n\r\n    cond: function() {\r\n      return new dot.SingularValueDecomposition( this ).cond();\r\n    },\r\n\r\n    trace: function() {\r\n      var t = 0;\r\n      for ( var i = 0; i < Math.min( this.m, this.n ); i++ ) {\r\n        t += this.entries[ this.index( i, i ) ];\r\n      }\r\n      return t;\r\n    },\r\n\r\n    checkMatrixDimensions: function( matrix ) {\r\n      if ( matrix.m !== this.m || matrix.n !== this.n ) {\r\n        throw new Error( \"Matrix dimensions must agree.\" );\r\n      }\r\n    },\r\n\r\n    toString: function() {\r\n      var result = \"\";\r\n      result += \"dim: \" + this.getRowDimension() + \"x\" + this.getColumnDimension() + \"\\n\";\r\n      for ( var row = 0; row < this.getRowDimension(); row++ ) {\r\n        for ( var col = 0; col < this.getColumnDimension(); col++ ) {\r\n          result += this.get( row, col ) + \" \";\r\n        }\r\n        result += \"\\n\";\r\n      }\r\n      return result;\r\n    },\r\n\r\n    // returns a vector that is contained in the specified column\r\n    extractVector2: function( column ) {\r\n      assert && assert( this.m === 2 ); // rows should match vector dimension\r\n      return new dot.Vector2( this.get( 0, column ), this.get( 1, column ) );\r\n    },\r\n\r\n    // returns a vector that is contained in the specified column\r\n    extractVector3: function( column ) {\r\n      assert && assert( this.m === 3 ); // rows should match vector dimension\r\n      return new dot.Vector3( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ) );\r\n    },\r\n\r\n    // returns a vector that is contained in the specified column\r\n    extractVector4: function( column ) {\r\n      assert && assert( this.m === 4 ); // rows should match vector dimension\r\n      return new dot.Vector4( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ), this.get( 3, column ) );\r\n    },\r\n\r\n    // Sets the current matrix to the values of the listed column vectors (Vector3).\r\n    setVectors3: function( vectors ) {\r\n      var m = 3;\r\n      var n = vectors.length;\r\n\r\n      assert && assert( this.m === m );\r\n      assert && assert( this.n === n );\r\n\r\n      for ( var i = 0; i < n; i++ ) {\r\n        var vector = vectors[ i ];\r\n        this.entries[ i ] = vector.x;\r\n        this.entries[ i + n ] = vector.y;\r\n        this.entries[ i + 2 * n ] = vector.z;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    isMatrix: true\r\n  };\r\n\r\n  Matrix.identity = function( m, n ) {\r\n    var result = new Matrix( m, n );\r\n    for ( var i = 0; i < m; i++ ) {\r\n      for ( var j = 0; j < n; j++ ) {\r\n        result.entries[ result.index( i, j ) ] = (i === j ? 1.0 : 0.0);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  Matrix.rowVector2 = function( vector ) {\r\n    return new Matrix( 1, 2, [ vector.x, vector.y ] );\r\n  };\r\n\r\n  Matrix.rowVector3 = function( vector ) {\r\n    return new Matrix( 1, 3, [ vector.x, vector.y, vector.z ] );\r\n  };\r\n\r\n  Matrix.rowVector4 = function( vector ) {\r\n    return new Matrix( 1, 4, [ vector.x, vector.y, vector.z, vector.w ] );\r\n  };\r\n\r\n  Matrix.rowVector = function( vector ) {\r\n    if ( vector.isVector2 ) {\r\n      return Matrix.rowVector2( vector );\r\n    }\r\n    else if ( vector.isVector3 ) {\r\n      return Matrix.rowVector3( vector );\r\n    }\r\n    else if ( vector.isVector4 ) {\r\n      return Matrix.rowVector4( vector );\r\n    }\r\n    else {\r\n      throw new Error( \"undetected type of vector: \" + vector.toString() );\r\n    }\r\n  };\r\n\r\n  Matrix.columnVector2 = function( vector ) {\r\n    return new Matrix( 2, 1, [ vector.x, vector.y ] );\r\n  };\r\n\r\n  Matrix.columnVector3 = function( vector ) {\r\n    return new Matrix( 3, 1, [ vector.x, vector.y, vector.z ] );\r\n  };\r\n\r\n  Matrix.columnVector4 = function( vector ) {\r\n    return new Matrix( 4, 1, [ vector.x, vector.y, vector.z, vector.w ] );\r\n  };\r\n\r\n  Matrix.columnVector = function( vector ) {\r\n    if ( vector.isVector2 ) {\r\n      return Matrix.columnVector2( vector );\r\n    }\r\n    else if ( vector.isVector3 ) {\r\n      return Matrix.columnVector3( vector );\r\n    }\r\n    else if ( vector.isVector4 ) {\r\n      return Matrix.columnVector4( vector );\r\n    }\r\n    else {\r\n      throw new Error( \"undetected type of vector: \" + vector.toString() );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Create a Matrix where each column is a vector\r\n   */\r\n\r\n  Matrix.fromVectors2 = function( vectors ) {\r\n    var dimension = 2;\r\n    var n = vectors.length;\r\n    var data = new Float32Array( dimension * n );\r\n\r\n    for ( var i = 0; i < n; i++ ) {\r\n      var vector = vectors[ i ];\r\n      data[ i ] = vector.x;\r\n      data[ i + n ] = vector.y;\r\n    }\r\n\r\n    return new Matrix( dimension, n, data, true );\r\n  };\r\n\r\n  Matrix.fromVectors3 = function( vectors ) {\r\n    var dimension = 3;\r\n    var n = vectors.length;\r\n    var data = new Float32Array( dimension * n );\r\n\r\n    for ( var i = 0; i < n; i++ ) {\r\n      var vector = vectors[ i ];\r\n      data[ i ] = vector.x;\r\n      data[ i + n ] = vector.y;\r\n      data[ i + 2 * n ] = vector.z;\r\n    }\r\n\r\n    return new Matrix( dimension, n, data, true );\r\n  };\r\n\r\n  Matrix.fromVectors4 = function( vectors ) {\r\n    var dimension = 4;\r\n    var n = vectors.length;\r\n    var data = new Float32Array( dimension * n );\r\n\r\n    for ( var i = 0; i < n; i++ ) {\r\n      var vector = vectors[ i ];\r\n      data[ i ] = vector.x;\r\n      data[ i + n ] = vector.y;\r\n      data[ i + 2 * n ] = vector.z;\r\n      data[ i + 3 * n ] = vector.w;\r\n    }\r\n\r\n    return new Matrix( dimension, n, data, true );\r\n  };\r\n\r\n  return Matrix;\r\n} );\r\n\n","// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * An observable property, notifies registered observers when the value changes.\r\n *\r\n * Uses the 'Constructor' pattern for object creation, which has the downside that\r\n * all properties are created once for each instance. It would be nice if our functions\r\n * were shared. But since the only way to create private fields is in the constructor,\r\n * and the functions need access to those private fields, there doesn't seem to be\r\n * any choice but to define the functions in the constructor.\r\n *\r\n * @author Sam Reid\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'AXON/Property',['require','AXON/axon','PHET_CORE/inherit'],function( require ) {\r\n  'use strict';\r\n\r\n  // modules\r\n  var axon = require( 'AXON/axon' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  // Also requires Multilink and DerivedProperty but cannot reference them here or it will create a\r\n  // Circular dependency.  So they are loaded through axon.Multilink and axon.DerivedProperty\r\n\r\n  /**\r\n   * @param {*} value - the initial value of the property\r\n   * @param {object} [options] - optional values for the property, see below\r\n   * @constructor\r\n   */\r\n  axon.Property = function Property( value, options ) {\r\n\r\n    //Store the internal value and the initial value\r\n    this.storeValue( value );        // typically sets this._value\r\n    this.storeInitialValue( value ); // typically sets this._initialValue\r\n    this._observers = [];\r\n\r\n    //Model component ID for data studies, regression testing, etc\r\n    this.propertyID = options ? options.propertyID : null;\r\n\r\n    //By default, events can be logged for data analysis studies, but setSendPhetEvents can be set to false for events that should not be recorded (such as the passage of time).\r\n    this.sendPhetEvents = true;\r\n    this.delay = 0; //Seconds between messages (if throttled).  Zero means no throttling\r\n  };\r\n\r\n  return inherit( Object, axon.Property, {\r\n\r\n      /**\r\n       * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.\r\n       * @return {*}\r\n       */\r\n      get: function() {\r\n        return this._value;\r\n      },\r\n\r\n      /**\r\n       * Sets the value and notifies registered observers.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.\r\n       * If the value hasn't changed, this is a no-op.\r\n       *\r\n       * @param {*} value\r\n       */\r\n      set: function( value ) {\r\n        if ( !this.equalsValue( value ) ) {\r\n          this._setAndNotifyObservers( value );\r\n        }\r\n        return this;\r\n      },\r\n\r\n      // whether this property will not \"change\" when the passed-in value is set\r\n      equalsValue: function( value ) {\r\n        return value === this._value;\r\n      },\r\n\r\n      // store the current (new) value\r\n      storeValue: function( value ) {\r\n        this._value = value;\r\n      },\r\n\r\n      // store the initial value\r\n      storeInitialValue: function( value ) {\r\n        this._initialValue = value;\r\n      },\r\n\r\n      get initialValue() {\r\n        return this._initialValue;\r\n      },\r\n\r\n      _setAndNotifyObservers: function( value ) {\r\n        var oldValue = this.get();\r\n        this.storeValue( value );\r\n        this._notifyObservers( oldValue );\r\n      },\r\n\r\n      _notifyObservers: function( oldValue ) {\r\n\r\n        // Note the current value, since it will be sent to possibly multiple observers.\r\n        var value = this.get();\r\n\r\n        // If enabled, send a message to phet events.  Avoid as much work as possible if phet.arch is inactive.\r\n        var archID = arch && this.sendPhetEvents && arch.start( 'model', this.propertyID, 'Property', 'changed', { value: value } );\r\n\r\n        // TODO: JO: avoid slice() by storing observers array correctly\r\n        var observersCopy = this._observers.slice(); // make a copy, in case notification results in removeObserver\r\n        for ( var i = 0; i < observersCopy.length; i++ ) {\r\n          observersCopy[ i ]( value, oldValue );\r\n        }\r\n\r\n        // Send the end message to phet.arch\r\n        archID && this.sendPhetEvents && arch.end( archID );\r\n      },\r\n\r\n      //Use this method when mutating a value (not replacing with a new instance) and you want to send notifications about the change.\r\n      //This is different from the normal axon strategy, but may be necessary to prevent memory allocations.\r\n      //This method is unsafe for removing observers because it assumes the observer list not modified, to save another allocation\r\n      //Only provides the new reference as a callback (no oldvalue)\r\n      //See https://github.com/phetsims/axon/issues/6\r\n      notifyObserversStatic: function() {\r\n        var value = this.get();\r\n        for ( var i = 0; i < this._observers.length; i++ ) {\r\n          this._observers[ i ]( value );\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Resets the value to the initial value.\r\n       */\r\n      reset: function() {\r\n        this.set( this._initialValue );\r\n      },\r\n\r\n      /**\r\n       * This function returns a bound function that sets the specified value.  For use in creating closures e.g. with gui classes.\r\n       * For instance, to have a button that sets a property to true, instead of using\r\n       * button.click(function(){property.set(true);});\r\n       * you could use\r\n       * button.click(property._set(true));\r\n       * @param value the value to use when the setter is called.\r\n       * @return a function that can be used to set the specified value.\r\n       */\r\n      _set: function( value ) {\r\n        return this.set.bind( this, value );\r\n      },\r\n\r\n      get value() { return this.get(); },\r\n\r\n      set value( newValue ) { this.set( newValue ); },\r\n\r\n      /**\r\n       * Adds an observer and notifies it immediately.\r\n       * If observer is already registered, this is a no-op.\r\n       * The initial notification provides the current value for newValue and null for oldValue.\r\n       *\r\n       * @param {function} observer a function of the form observer(newValue,oldValue)\r\n       */\r\n      link: function( observer ) {\r\n        if ( this._observers.indexOf( observer ) === -1 ) {\r\n          this._observers.push( observer );\r\n          observer( this.get(), null ); // null should be used when an object is expected but unavailable\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Add an observer to the Property, without calling it back right away.  This is used when you need to register a observer without an immediate callback.\r\n       * @param {function} observer  a function with a single argument, which is the value of the property at the time the function is called.\r\n       */\r\n      lazyLink: function( observer ) {\r\n        if ( this._observers.indexOf( observer ) === -1 ) {\r\n          this._observers.push( observer );\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Removes an observer.\r\n       * If observer is not registered, this is a no-op.\r\n       *\r\n       * @param {function} observer\r\n       */\r\n      unlink: function( observer ) {\r\n        var index = this._observers.indexOf( observer );\r\n        if ( index !== -1 ) {\r\n          this._observers.splice( index, 1 );\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Links an object's named attribute to this property.  Returns a handle so it can be removed using Property.unlink();\r\n       * Example: modelVisibleProperty.linkAttribute(view,'visible');\r\n       *\r\n       * @param object\r\n       * @param attributeName\r\n       */\r\n      linkAttribute: function( object, attributeName ) {\r\n        var handle = function( value ) {object[ attributeName ] = value;};\r\n        this.link( handle );\r\n        return handle;\r\n      },\r\n\r\n      /**\r\n       * Unlink an observer added with linkAttribute.  Note: the args of linkAttribute do not match the args of\r\n       * unlinkAttribute: here, you must pass the observer handle returned by linkAttribute rather than object and attributeName\r\n       * @param observer\r\n       */\r\n      unlinkAttribute: function( observer ) {\r\n        this.unlink( observer );\r\n      },\r\n\r\n      //Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript\r\n      toString: function() {return 'Property{' + this.get() + '}'; },\r\n      valueOf: function() {return this.toString();},\r\n\r\n      /**\r\n       * Add an observer so that it will only fire once (and not on registration)\r\n       *\r\n       * I can see two ways to implement this:\r\n       * (a) add a field to the observer so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'\r\n       * (b) wrap the observer in a new function which will call the observer and then remove itself.  Disadvantage: cannot remove an observer added using 'once'\r\n       * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' observer must be removed before it is called once\r\n       *\r\n       * @param observer the observer which should be called back only for one property change (and not on registration)\r\n       * @returns {function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once\r\n       */\r\n      once: function( observer ) {\r\n        var property = this;\r\n        var wrapper = function( newValue, oldValue ) {\r\n          property.unlink( wrapper );\r\n          observer( newValue, oldValue );\r\n        };\r\n        this.lazyLink( wrapper );\r\n        return wrapper;\r\n      },\r\n\r\n      /**\r\n       * Returns a new axon.DerivedProperty which is true/false based on whether the value matches (based on ===) the passed in argument.\r\n       * @param value\r\n       * @returns {DerivedProperty}\r\n       */\r\n      valueEquals: function( value ) {\r\n        return new axon.DerivedProperty( [ this ], function( propertyValue ) { return propertyValue === value; } );\r\n      },\r\n\r\n      /**\r\n       * Returns a new boolean DerivedProperty which is true/false based on && operator.\r\n       * @param otherProperty\r\n       * @returns {DerivedProperty.<boolean>}\r\n       */\r\n      and: function( otherProperty ) {\r\n        return new axon.DerivedProperty( [ this, otherProperty ], function( thisValue, otherValue ) { return thisValue && otherValue; } );\r\n      },\r\n\r\n      /**\r\n       * Multiply this property's value by a constant scalar number, and return the derived property.\r\n       *\r\n       * @param scalar\r\n       * @returns {DerivedProperty}\r\n       */\r\n      times: function( scalar ) {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) { return thisValue * scalar; } );\r\n      },\r\n\r\n      /**\r\n       * Multiply this property's value by a constant scalar number, and return the derived property.\r\n       *\r\n       * @param number\r\n       * @returns {DerivedProperty}\r\n       */\r\n      plus: function( number ) {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) { return thisValue + number; } );\r\n      },\r\n\r\n      /**\r\n       * Return a derived property that is true if and only if this value is less than the specified number.\r\n       *\r\n       * @param number\r\n       * @returns {DerivedProperty}\r\n       */\r\n      lessThanNumber: function( number ) {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) { return thisValue < number; } );\r\n      },\r\n\r\n      /**\r\n       * Return a derived property that is true if and only if this value is greater than the specified number.\r\n       *\r\n       * @param number\r\n       * @returns {DerivedProperty}\r\n       */\r\n      greaterThanNumber: function( number ) {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) { return thisValue > number; } );\r\n      },\r\n\r\n      /**\r\n       * Not property, which does not propagate changes to dependents.\r\n       * @returns {DerivedProperty}\r\n       */\r\n      derivedNot: function() {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) { return !thisValue; } );\r\n      },\r\n\r\n      /**\r\n       * Two way communication for not, so you can set the value and have it come back to the parent\r\n       * Note that noting about the following code is specific to booleans, although this should probably be used mostly for booleans.\r\n       * To unlink both observers attached unlink a property created with not(), use detach()\r\n       */\r\n      not: function() {\r\n        var parentProperty = this;\r\n        var childProperty = new axon.Property( !this.value );\r\n\r\n        var setParentToChild = function( value ) {childProperty.set( !value );};\r\n        parentProperty.link( setParentToChild );\r\n\r\n        var setChildToParent = function( value ) {parentProperty.set( !value );};\r\n        childProperty.link( setChildToParent );\r\n\r\n        childProperty.detach = function() {\r\n          parentProperty.unlink( setParentToChild );\r\n          childProperty.unlink( setChildToParent );\r\n        };\r\n        return childProperty;\r\n      },\r\n\r\n      /**\r\n       * Convenience function for debugging a property values.  It prints the new value on registration and when changed.\r\n       * @param name debug name to be printed on the console\r\n       * @returns {function} the handle to the linked observer in case it needs to be removed later\r\n       */\r\n      debug: function( name ) {\r\n        var observer = function( value ) { console.log( name, value ); };\r\n        this.link( observer );\r\n        return observer;\r\n      },\r\n\r\n      //Returns a new Property that maps its values using the specified lookup table.\r\n      //If the parent property value does not appear as a key in the lookup table, the returned property value is undefined\r\n      mapValues: function( values ) {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) { return values[ thisValue ];} );\r\n      },\r\n\r\n      //Returns a new Property that maps its values using the specified function\r\n      //See https://github.com/phetsims/axon/issues/25\r\n      map: function( f ) {\r\n        return new axon.DerivedProperty( [ this ], function( thisValue ) {return f( thisValue );} );\r\n      },\r\n\r\n      /**\r\n       * Returns a function that can be used to toggle the property (using !)\r\n       * @returns {function}\r\n       */\r\n      get toggleFunction() {\r\n        return this.toggle.bind( this );\r\n      },\r\n\r\n      /**\r\n       * Modifies the value of this Property with the ! operator.  Works for booleans and non-booleans.\r\n       */\r\n      toggle: function() {\r\n        this.value = !this.value;\r\n      },\r\n\r\n      /**\r\n       * Adds an observer that is fired when the property takes the specified value.  If the property has the value already,\r\n       * the observer is called back immediately.  A reference to the observer is returned so that it can be removed.\r\n       *\r\n       * @param value the value to match\r\n       * @param observer the observer that is called when this Property\r\n       */\r\n      onValue: function( value, observer ) {\r\n        var onValueObserver = function( v ) {\r\n          if ( v === value ) {\r\n            observer();\r\n          }\r\n        };\r\n        this.link( onValueObserver );\r\n        return onValueObserver;\r\n      },\r\n\r\n      setSendPhetEvents: function( sendPhetEvents ) {\r\n        this.sendPhetEvents = sendPhetEvents;\r\n        return this;\r\n      },\r\n\r\n      throttle: function( delay ) {\r\n        this.delay = delay;\r\n        return this;\r\n      }\r\n    },\r\n\r\n    //statics\r\n    {\r\n\r\n      /**\r\n       * Registers an observer with multiple properties, then notifies the observer immediately.\r\n       * @param {Property[]} properties\r\n       * @param {function} observer no params, returns nothing\r\n       * @static\r\n       */\r\n      multilink: function( properties, observer ) {\r\n        return new axon.Multilink( properties, observer, false );\r\n      },\r\n\r\n      lazyMultilink: function( properties, observer ) {\r\n        return new axon.Multilink( properties, observer, true );\r\n      },\r\n\r\n      /**\r\n       * Removes the multilinked observer from this Property.\r\n       * Same as calling detach() on the handle (which happens to be a DerivedProperty instance)\r\n       * @param derivedProperty\r\n       */\r\n      unmultilink: function( derivedProperty ) {\r\n        derivedProperty.detach();\r\n      }\r\n    } );\r\n} );\r\n\n","// Copyright 2002-2013, University of Colorado Boulder\r\n\r\ndefine( 'AXON/axon',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  var axon = {};\r\n\r\n  // workaround for Axon, since it needs window.arch to be defined\r\n  window.arch = window.arch || null;\r\n\r\n  // store a reference on the PhET namespace if it exists\r\n  if ( window.phet ) {\r\n    window.phet.axon = axon;\r\n  }\r\n\r\n  // will be filled in by other modules\r\n  return axon;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Observable version of the basic 2-dimensional bounding box (Bounds2)\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/ObservableBounds2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/Poolable','AXON/Property','DOT/Bounds2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var extend = require( 'PHET_CORE/extend' );\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n  var Property = require( 'AXON/Property' );\r\n  require( 'DOT/Bounds2' );\r\n\r\n  dot.ObservableBounds2 = function ObservableBounds2( minX, minY, maxX, maxY ) {\r\n    dot.Bounds2.call( this, minX, minY, maxX, maxY );\r\n\r\n    this._oldValue = this.copy();\r\n    Property.call( this, this );\r\n  };\r\n  var ObservableBounds2 = dot.ObservableBounds2;\r\n\r\n  inherit( dot.Bounds2, ObservableBounds2, extend( {}, Property.prototype, {\r\n    // returns this value directly\r\n    get: function() {\r\n      return this;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Overriding the core mutable methods (any mutable operation should call one of these)\r\n     *----------------------------------------------------------------------------*/\r\n    setMinMax: function( minX, minY, maxX, maxY ) {\r\n      if ( this.minX !== minX || this.minY !== minY || this.maxX !== maxX || this.maxY !== maxY ) {\r\n        this._oldValue.minX = this.minX;\r\n        this._oldValue.minY = this.minY;\r\n        this._oldValue.maxX = this.maxX;\r\n        this._oldValue.maxY = this.maxY;\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    setMinX: function( minX ) {\r\n      if ( this.minX !== minX ) {\r\n        this._oldValue.minX = this.minX;\r\n        this.minX = minX;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    setMinY: function( minY ) {\r\n      if ( this.minY !== minY ) {\r\n        this._oldValue.minY = this.minY;\r\n        this.minY = minY;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    setMaxX: function( maxX ) {\r\n      if ( this.maxX !== maxX ) {\r\n        this._oldValue.maxX = this.maxX;\r\n        this.maxX = maxX;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    setMaxY: function( maxY ) {\r\n      if ( this.maxY !== maxY ) {\r\n        this._oldValue.maxY = this.maxY;\r\n        this.maxY = maxY;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    set: dot.Bounds2.prototype.set,\r\n\r\n    // override with vector equality instead of instance equality\r\n    equalsValue: function( value ) {\r\n      return this.equals( value );\r\n    },\r\n\r\n    // we are not storing a separate value field (_value), so we leave this blank\r\n    storeValue: function( value ) {\r\n    },\r\n\r\n    // to prevent a user from modifying the passed in initial value, we store the x/y here\r\n    storeInitialValue: function( value ) {\r\n      this._initialMinX = value.minX;\r\n      this._initialMinY = value.minY;\r\n      this._initialMaxX = value.maxX;\r\n      this._initialMaxY = value.maxY;\r\n    },\r\n\r\n    reset: function() {\r\n      this.setMinMax( this._initialMinX, this._initialMinY, this._initialMaxX, this._initialMaxY );\r\n    },\r\n\r\n    toString: function() {\r\n      return 'ObservableBounds2(' + this.minX + ', ' + this.minY + ', ' + this.maxX + ', ' + this.maxY + ')';\r\n    }\r\n  } ) );\r\n\r\n  Poolable.mixin( ObservableBounds2, {\r\n    defaultFactory: function() { return new ObservableBounds2(); },\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( minX, minY, maxX, maxY ) {\r\n        if ( pool.length ) {\r\n          return pool.pop().setMinMax( minX, minY, maxX, maxY );\r\n        }\r\n        else {\r\n          return new ObservableBounds2( minX, minY, maxX, maxY );\r\n        }\r\n      };\r\n    }\r\n  } );\r\n\r\n  return ObservableBounds2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Observable version of the basic 3-dimensional matrix (Matrix3)\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/ObservableMatrix3',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/Poolable','AXON/Property','DOT/Matrix3'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var extend = require( 'PHET_CORE/extend' );\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n  var Property = require( 'AXON/Property' );\r\n  require( 'DOT/Matrix3' );\r\n\r\n  dot.ObservableMatrix3 = function ObservableMatrix3( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n    dot.Matrix3.call( this, v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n\r\n    this._oldValue = this.copy();\r\n    this._skipChecks = false;\r\n    Property.call( this, this );\r\n  };\r\n  var ObservableMatrix3 = dot.ObservableMatrix3;\r\n\r\n  inherit( dot.Matrix3, ObservableMatrix3, extend( {}, Property.prototype, {\r\n    // returns this value directly\r\n    get: function() {\r\n      return this;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Overriding the core mutable methods (any mutable operation should call one of these)\r\n     *----------------------------------------------------------------------------*/\r\n    // every mutable method goes through rowMajor\r\n    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n      var skip = this._skipChecks;\r\n      var modified = skip ||\r\n                     v00 !== this.entries[ 0 ] ||\r\n                     v10 !== this.entries[ 1 ] ||\r\n                     v20 !== this.entries[ 2 ] ||\r\n                     v01 !== this.entries[ 3 ] ||\r\n                     v11 !== this.entries[ 4 ] ||\r\n                     v21 !== this.entries[ 5 ] ||\r\n                     v02 !== this.entries[ 6 ] ||\r\n                     v12 !== this.entries[ 7 ] ||\r\n                     v22 !== this.entries[ 8 ] ||\r\n                     type !== this.type;\r\n      if ( modified ) {\r\n\r\n        if ( !skip && this._oldValue ) {\r\n          this._oldValue.entries[ 0 ] = this.entries[ 0 ];\r\n          this._oldValue.entries[ 1 ] = this.entries[ 1 ];\r\n          this._oldValue.entries[ 2 ] = this.entries[ 2 ];\r\n          this._oldValue.entries[ 3 ] = this.entries[ 3 ];\r\n          this._oldValue.entries[ 4 ] = this.entries[ 4 ];\r\n          this._oldValue.entries[ 5 ] = this.entries[ 5 ];\r\n          this._oldValue.entries[ 6 ] = this.entries[ 6 ];\r\n          this._oldValue.entries[ 7 ] = this.entries[ 7 ];\r\n          this._oldValue.entries[ 8 ] = this.entries[ 8 ];\r\n          this._oldValue.type = this.type;\r\n        }\r\n\r\n        this.entries[ 0 ] = v00;\r\n        this.entries[ 1 ] = v10;\r\n        this.entries[ 2 ] = v20;\r\n        this.entries[ 3 ] = v01;\r\n        this.entries[ 4 ] = v11;\r\n        this.entries[ 5 ] = v21;\r\n        this.entries[ 6 ] = v02;\r\n        this.entries[ 7 ] = v12;\r\n        this.entries[ 8 ] = v22;\r\n\r\n        // TODO: consider performance of the affine check here\r\n        this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? dot.Matrix3.Types.AFFINE : dot.Matrix3.Types.OTHER ) : type;\r\n\r\n        // if this isn't initialization, fire off changes and update the old value\r\n        if ( this._observers ) {\r\n          this._notifyObservers( skip ? null : this._oldValue );\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    // override set, since it is overridden by property\r\n    set: dot.Matrix3.prototype.set,\r\n\r\n    // override with vector equality instead of instance equality\r\n    equalsValue: function( value ) {\r\n      return this.equals( value );\r\n    },\r\n\r\n    // we are not storing a separate value field (_value), so we leave this blank\r\n    storeValue: function( value ) {\r\n    },\r\n\r\n    // to prevent a user from modifying the passed in initial value, we store the x/y here\r\n    storeInitialValue: function( value ) {\r\n      this._initial00 = value.m00();\r\n      this._initial01 = value.m01();\r\n      this._initial02 = value.m02();\r\n      this._initial10 = value.m10();\r\n      this._initial11 = value.m11();\r\n      this._initial12 = value.m12();\r\n      this._initial20 = value.m20();\r\n      this._initial21 = value.m21();\r\n      this._initial22 = value.m22();\r\n      this._initialType = value.type;\r\n    },\r\n\r\n    reset: function() {\r\n      this.rowMajor(\r\n        this._initial00, this._initial01, this._initial02,\r\n        this._initial10, this._initial11, this._initial12,\r\n        this._initial20, this._initial21, this._initial22,\r\n        this._initialType );\r\n    },\r\n\r\n    toString: dot.Matrix3.prototype.toString\r\n  } ) );\r\n\r\n  Poolable.mixin( ObservableMatrix3, {\r\n    defaultFactory: function() { return new ObservableMatrix3(); },\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n        if ( pool.length ) {\r\n          return pool.pop().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n        }\r\n        else {\r\n          return new ObservableMatrix3( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n        }\r\n      };\r\n    }\r\n  } );\r\n\r\n  return ObservableMatrix3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Observable version of the basic 2-dimensional vector\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/ObservableVector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/Poolable','AXON/Property','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var extend = require( 'PHET_CORE/extend' );\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n  var Property = require( 'AXON/Property' );\r\n  require( 'DOT/Vector2' );\r\n\r\n  dot.ObservableVector2 = function ObservableVector2( x, y ) {\r\n    dot.Vector2.call( this, x, y );\r\n\r\n    this._oldValue = this.copy();\r\n    Property.call( this, this );\r\n  };\r\n  var ObservableVector2 = dot.ObservableVector2;\r\n\r\n  inherit( dot.Vector2, ObservableVector2, extend( {}, Property.prototype, {\r\n    // returns this value directly\r\n    get: function() {\r\n      return this;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Overriding the core mutable methods (any mutable operation should call one of these)\r\n     *----------------------------------------------------------------------------*/\r\n    setXY: function( x, y ) {\r\n      if ( this.x !== x || this.y !== y ) {\r\n        this._oldValue.x = this.x;\r\n        this._oldValue.y = this.y;\r\n        this.x = x;\r\n        this.y = y;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    setX: function( x ) {\r\n      if ( this.x !== x ) {\r\n        this._oldValue.x = this.x;\r\n        this.x = x;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    setY: function( y ) {\r\n      if ( this.y !== y ) {\r\n        this._oldValue.y = this.y;\r\n        this.y = y;\r\n        this._notifyObservers( this._oldValue );\r\n      }\r\n      return this;\r\n    },\r\n    set: dot.Vector2.prototype.set,\r\n\r\n    // override with vector equality instead of instance equality\r\n    equalsValue: function( value ) {\r\n      return this.equals( value );\r\n    },\r\n\r\n    // we are not storing a separate value field (_value), so we leave this blank\r\n    storeValue: function( value ) {\r\n    },\r\n\r\n    // to prevent a user from modifying the passed in initial value, we store the x/y here\r\n    storeInitialValue: function( value ) {\r\n      this._initialX = value.x;\r\n      this._initialY = value.y;\r\n    },\r\n\r\n    reset: function() {\r\n      this.setXY( this._initialX, this._initialY );\r\n    },\r\n\r\n    toString: function() {\r\n      return 'ObservableVector2(' + this.x + ', ' + this.y + ')';\r\n    }\r\n  } ) );\r\n\r\n  Poolable.mixin( ObservableVector2, {\r\n    defaultFactory: function() { return new ObservableVector2(); },\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( x, y ) {\r\n        if ( pool.length ) {\r\n          return pool.pop().setXY( x, y );\r\n        }\r\n        else {\r\n          return new ObservableVector2( x, y );\r\n        }\r\n      };\r\n    }\r\n  } );\r\n\r\n  return ObservableVector2;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * An immutable permutation that can permute an array\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Permutation',['require','DOT/dot','PHET_CORE/isArray','DOT/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var isArray = require( 'PHET_CORE/isArray' );\r\n  require( 'DOT/Util' ); // for rangeInclusive\r\n\r\n  // Creates a permutation that will rearrange a list so that newList[i] = oldList[permutation[i]]\r\n  var Permutation = dot.Permutation = function Permutation( indices ) {\r\n    this.indices = indices;\r\n  };\r\n\r\n  // An identity permutation with a specific number of elements\r\n  Permutation.identity = function( size ) {\r\n    assert && assert( size >= 0 );\r\n    var indices = new Array( size );\r\n    for ( var i = 0; i < size; i++ ) {\r\n      indices[ i ] = i;\r\n    }\r\n    return new Permutation( indices );\r\n  };\r\n\r\n  // lists all permutations that have a given size\r\n  Permutation.permutations = function( size ) {\r\n    var result = [];\r\n    Permutation.forEachPermutation( dot.rangeInclusive( 0, size - 1 ), function( integers ) {\r\n      result.push( new Permutation( integers ) );\r\n    } );\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Call our function with each permutation of the provided list PREFIXED by prefix, in lexicographic order\r\n   *\r\n   * @param array   List to generate permutations of\r\n   * @param prefix   Elements that should be inserted at the front of each list before each call\r\n   * @param callback Function to call\r\n   */\r\n  function recursiveForEachPermutation( array, prefix, callback ) {\r\n    if ( array.length === 0 ) {\r\n      callback.call( undefined, prefix );\r\n    }\r\n    else {\r\n      for ( var i = 0; i < array.length; i++ ) {\r\n        var element = array[ i ];\r\n\r\n        // remove the element from the array\r\n        var nextArray = array.slice( 0 );\r\n        nextArray.splice( i, 1 );\r\n\r\n        // add it into the prefix\r\n        var nextPrefix = prefix.slice( 0 );\r\n        nextPrefix.push( element );\r\n\r\n        recursiveForEachPermutation( nextArray, nextPrefix, callback );\r\n      }\r\n    }\r\n  }\r\n\r\n  Permutation.forEachPermutation = function( array, callback ) {\r\n    recursiveForEachPermutation( array, [], callback );\r\n  };\r\n\r\n  Permutation.prototype = {\r\n    constructor: Permutation,\r\n\r\n    size: function() {\r\n      return this.indices.length;\r\n    },\r\n\r\n    apply: function( arrayOrInt ) {\r\n      if ( isArray( arrayOrInt ) ) {\r\n        if ( arrayOrInt.length !== this.size() ) {\r\n          throw new Error( \"Permutation length \" + this.size() + \" not equal to list length \" + arrayOrInt.length );\r\n        }\r\n\r\n        // permute it as an array\r\n        var result = new Array( arrayOrInt.length );\r\n        for ( var i = 0; i < arrayOrInt.length; i++ ) {\r\n          result[ i ] = arrayOrInt[ this.indices[ i ] ];\r\n        }\r\n        return result;\r\n      }\r\n      else {\r\n        // permute a single index\r\n        return this.indices[ arrayOrInt ];\r\n      }\r\n    },\r\n\r\n    // The inverse of this permutation\r\n    inverted: function() {\r\n      var newPermutation = new Array( this.size() );\r\n      for ( var i = 0; i < this.size(); i++ ) {\r\n        newPermutation[ this.indices[ i ] ] = i;\r\n      }\r\n      return new Permutation( newPermutation );\r\n    },\r\n\r\n    withIndicesPermuted: function( indices ) {\r\n      var result = [];\r\n      var that = this;\r\n      Permutation.forEachPermutation( indices, function( integers ) {\r\n        var oldIndices = that.indices;\r\n        var newPermutation = oldIndices.slice( 0 );\r\n\r\n        for ( var i = 0; i < indices.length; i++ ) {\r\n          newPermutation[ indices[ i ] ] = oldIndices[ integers[ i ] ];\r\n        }\r\n        result.push( new Permutation( newPermutation ) );\r\n      } );\r\n      return result;\r\n    },\r\n\r\n    toString: function() {\r\n      return \"P[\" + this.indices.join( \", \" ) + \"]\";\r\n    }\r\n  };\r\n\r\n  Permutation.testMe = function( console ) {\r\n    var a = new Permutation( [ 1, 4, 3, 2, 0 ] );\r\n    console.log( a.toString() );\r\n\r\n    var b = a.inverted();\r\n    console.log( b.toString() );\r\n\r\n    console.log( b.withIndicesPermuted( [ 0, 3, 4 ] ).toString() );\r\n\r\n    console.log( Permutation.permutations( 4 ).toString() );\r\n  };\r\n\r\n  return Permutation;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A mathematical plane in 3 dimensions determined by a normal vector to the plane and the distance to the closest\r\n * point on the plane to the origin\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Plane3',['require','DOT/dot','DOT/Vector3'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n  var Vector3 = require( 'DOT/Vector3' );\r\n\r\n  /*\r\n   * @constructor\r\n   * @param {Vector3} normal - A normal vector (perpendicular) to the plane\r\n   * @param {number} distance - The signed distance to the plane from the origin, so that normal.times( distance )\r\n   *                            will be a point on the plane.\r\n   */\r\n  dot.Plane3 = function Plane3( normal, distance ) {\r\n    this.normal = normal;\r\n    this.distance = distance;\r\n\r\n    assert && assert( Math.abs( normal.magnitude() - 1 ) < 0.01 );\r\n\r\n    phetAllocation && phetAllocation( 'Plane3' );\r\n  };\r\n  var Plane3 = dot.Plane3;\r\n\r\n  Plane3.prototype = {\r\n    constructor: Plane3,\r\n\r\n    /*\r\n     * @param {Ray3} ray\r\n     * @returns The intersection {Vector3} of the ray with the plane\r\n     */\r\n    intersectWithRay: function( ray ) {\r\n      return ray.pointAtDistance( ray.distanceToPlane( this ) );\r\n    }\r\n  };\r\n\r\n  Plane3.XY = new Plane3( new Vector3( 0, 0, 1 ), 0 );\r\n  Plane3.XZ = new Plane3( new Vector3( 0, 1, 0 ), 0 );\r\n  Plane3.YZ = new Plane3( new Vector3( 1, 0, 0 ), 0 );\r\n\r\n  /*\r\n   * @param {Vector3} a - first point\r\n   * @param {Vector3} b - second point\r\n   * @param {Vector3} c - third point\r\n   */\r\n  Plane3.fromTriangle = function( a, b, c ) {\r\n    var normal = ( c.minus( a ) ).cross( b.minus( a ) );\r\n    if ( normal.magnitude() === 0 ) {\r\n      return null;\r\n    }\r\n    normal.normalize();\r\n\r\n    return new Plane3( normal, normal.dot( a ) );\r\n  };\r\n\r\n  return Plane3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Quaternion, see http://en.wikipedia.org/wiki/Quaternion\r\n *\r\n * TODO: convert from JME-style parameterization into classical mathematical description?\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Quaternion',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector3','DOT/Matrix3','DOT/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  var Poolable = require( 'PHET_CORE/Poolable' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Matrix3' );\r\n  require( 'DOT/Util' );\r\n\r\n  dot.Quaternion = function Quaternion( x, y, z, w ) {\r\n    this.setXYZW( x, y, z, w );\r\n\r\n    phetAllocation && phetAllocation( 'Quaternion' );\r\n  };\r\n  var Quaternion = dot.Quaternion;\r\n\r\n  Quaternion.prototype = {\r\n    constructor: Quaternion,\r\n\r\n    isQuaternion: true,\r\n\r\n    setXYZW: function( x, y, z, w ) {\r\n      this.x = x || 0;\r\n      this.y = y || 0;\r\n      this.z = z || 0;\r\n      this.w = w !== undefined ? w : 1;\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    plus: function( quat ) {\r\n      return new Quaternion( this.x + quat.x, this.y + quat.y, this.z + quat.z, this.w + quat.w );\r\n    },\r\n\r\n    timesScalar: function( s ) {\r\n      return new Quaternion( this.x * s, this.y * s, this.z * s, this.w * s );\r\n    },\r\n\r\n    // standard quaternion multiplication (hamilton product)\r\n    timesQuaternion: function( quat ) {\r\n      // TODO: note why this is the case? product noted everywhere is the other one mentioned!\r\n      // mathematica-style\r\n//        return new Quaternion(\r\n//                this.x * quat.x - this.y * quat.y - this.z * quat.z - this.w * quat.w,\r\n//                this.x * quat.y + this.y * quat.x + this.z * quat.w - this.w * quat.z,\r\n//                this.x * quat.z - this.y * quat.w + this.z * quat.x + this.w * quat.y,\r\n//                this.x * quat.w + this.y * quat.z - this.z * quat.y + this.w * quat.x\r\n//        );\r\n\r\n      // JME-style\r\n      return new Quaternion(\r\n        this.x * quat.w - this.z * quat.y + this.y * quat.z + this.w * quat.x,\r\n        -this.x * quat.z + this.y * quat.w + this.z * quat.x + this.w * quat.y,\r\n        this.x * quat.y - this.y * quat.x + this.z * quat.w + this.w * quat.z,\r\n        -this.x * quat.x - this.y * quat.y - this.z * quat.z + this.w * quat.w\r\n      );\r\n\r\n      /*\r\n       Mathematica!\r\n       In[13]:= Quaternion[-0.0, -0.0024999974, 0.0, 0.9999969] ** Quaternion[-0.9864071, 0.0016701065, -0.0050373166, 0.16423558]\r\n       Out[13]= Quaternion[-0.164231, 0.00750332, 0.00208069, -0.986391]\r\n\r\n       In[17]:= Quaternion[-0.0024999974, 0.0, 0.9999969, 0] ** Quaternion[0.0016701065, -0.0050373166, 0.16423558, -0.9864071]\r\n       Out[17]= Quaternion[-0.164239, -0.986391, 0.00125951, 0.00750332]\r\n\r\n       JME contains the rearrangement of what is typically called {w,x,y,z}\r\n       */\r\n    },\r\n\r\n    timesVector3: function( v ) {\r\n      if ( v.magnitude() === 0 ) {\r\n        return new dot.Vector3();\r\n      }\r\n\r\n      // TODO: optimization?\r\n      return new dot.Vector3(\r\n        this.w * this.w * v.x + 2 * this.y * this.w * v.z - 2 * this.z * this.w * v.y + this.x * this.x * v.x + 2 * this.y * this.x * v.y + 2 * this.z * this.x * v.z - this.z * this.z * v.x - this.y * this.y * v.x,\r\n        2 * this.x * this.y * v.x + this.y * this.y * v.y + 2 * this.z * this.y * v.z + 2 * this.w * this.z * v.x - this.z * this.z * v.y + this.w * this.w * v.y - 2 * this.x * this.w * v.z - this.x * this.x * v.y,\r\n        2 * this.x * this.z * v.x + 2 * this.y * this.z * v.y + this.z * this.z * v.z - 2 * this.w * this.y * v.x - this.y * this.y * v.z + 2 * this.w * this.x * v.y - this.x * this.x * v.z + this.w * this.w * v.z\r\n      );\r\n    },\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n    },\r\n\r\n    normalized: function() {\r\n      var magnitude = this.magnitude();\r\n      assert && assert( magnitude !== 0, 'Cannot normalize a zero-magnitude quaternion' );\r\n      return this.timesScalar( 1 / magnitude );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Quaternion( -this.x, -this.y, -this.z, -this.w );\r\n    },\r\n\r\n    toRotationMatrix: function() {\r\n      // see http://en.wikipedia.org/wiki/Rotation_matrix#Quaternion\r\n\r\n      var norm = this.magnitudeSquared();\r\n      var flip = ( norm === 1 ) ? 2 : ( norm > 0 ) ? 2 / norm : 0;\r\n\r\n      var xx = this.x * this.x * flip;\r\n      var xy = this.x * this.y * flip;\r\n      var xz = this.x * this.z * flip;\r\n      var xw = this.w * this.x * flip;\r\n      var yy = this.y * this.y * flip;\r\n      var yz = this.y * this.z * flip;\r\n      var yw = this.w * this.y * flip;\r\n      var zz = this.z * this.z * flip;\r\n      var zw = this.w * this.z * flip;\r\n\r\n      return dot.Matrix3.dirtyFromPool().columnMajor(\r\n        1 - ( yy + zz ),\r\n        ( xy + zw ),\r\n        ( xz - yw ),\r\n        ( xy - zw ),\r\n        1 - ( xx + zz ),\r\n        ( yz + xw ),\r\n        ( xz + yw ),\r\n        ( yz - xw ),\r\n        1 - ( xx + yy )\r\n      );\r\n    }\r\n  };\r\n\r\n  Quaternion.fromEulerAngles = function( yaw, roll, pitch ) {\r\n    var sinPitch = Math.sin( pitch * 0.5 );\r\n    var cosPitch = Math.cos( pitch * 0.5 );\r\n    var sinRoll = Math.sin( roll * 0.5 );\r\n    var cosRoll = Math.cos( roll * 0.5 );\r\n    var sinYaw = Math.sin( yaw * 0.5 );\r\n    var cosYaw = Math.cos( yaw * 0.5 );\r\n\r\n    var a = cosRoll * cosPitch;\r\n    var b = sinRoll * sinPitch;\r\n    var c = cosRoll * sinPitch;\r\n    var d = sinRoll * cosPitch;\r\n\r\n    return new Quaternion(\r\n      a * sinYaw + b * cosYaw,\r\n      d * cosYaw + c * sinYaw,\r\n      c * cosYaw - d * sinYaw,\r\n      a * cosYaw - b * sinYaw\r\n    );\r\n  };\r\n\r\n  Quaternion.fromRotationMatrix = function( matrix ) {\r\n    var v00 = matrix.m00();\r\n    var v01 = matrix.m01();\r\n    var v02 = matrix.m02();\r\n    var v10 = matrix.m10();\r\n    var v11 = matrix.m11();\r\n    var v12 = matrix.m12();\r\n    var v20 = matrix.m20();\r\n    var v21 = matrix.m21();\r\n    var v22 = matrix.m22();\r\n\r\n    // from graphics gems code\r\n    var trace = v00 + v11 + v22;\r\n    var sqt;\r\n\r\n    // we protect the division by s by ensuring that s>=1\r\n    if ( trace >= 0 ) {\r\n      sqt = Math.sqrt( trace + 1 );\r\n      return new Quaternion(\r\n        ( v21 - v12 ) * 0.5 / sqt,\r\n        ( v02 - v20 ) * 0.5 / sqt,\r\n        ( v10 - v01 ) * 0.5 / sqt,\r\n        0.5 * sqt\r\n      );\r\n    }\r\n    else if ( ( v00 > v11 ) && ( v00 > v22 ) ) {\r\n      sqt = Math.sqrt( 1 + v00 - v11 - v22 );\r\n      return new Quaternion(\r\n        sqt * 0.5,\r\n        ( v10 + v01 ) * 0.5 / sqt,\r\n        ( v02 + v20 ) * 0.5 / sqt,\r\n        ( v21 - v12 ) * 0.5 / sqt\r\n      );\r\n    }\r\n    else if ( v11 > v22 ) {\r\n      sqt = Math.sqrt( 1 + v11 - v00 - v22 );\r\n      return new Quaternion(\r\n        ( v10 + v01 ) * 0.5 / sqt,\r\n        sqt * 0.5,\r\n        ( v21 + v12 ) * 0.5 / sqt,\r\n        ( v02 - v20 ) * 0.5 / sqt\r\n      );\r\n    }\r\n    else {\r\n      sqt = Math.sqrt( 1 + v22 - v00 - v11 );\r\n      return new Quaternion(\r\n        ( v02 + v20 ) * 0.5 / sqt,\r\n        ( v21 + v12 ) * 0.5 / sqt,\r\n        sqt * 0.5,\r\n        ( v10 - v01 ) * 0.5 / sqt\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Find a quaternion that transforms a unit vector A into a unit vector B. There\r\n   * are technically multiple solutions, so this only picks one.\r\n   *\r\n   * @param a Unit vector A\r\n   * @param b Unit vector B\r\n   * @return A quaternion s.t. Q * A = B\r\n   */\r\n  Quaternion.getRotationQuaternion = function( a, b ) {\r\n    return Quaternion.fromRotationMatrix( dot.Matrix3.rotateAToB( a, b ) );\r\n  };\r\n\r\n  // spherical linear interpolation - blending two quaternions\r\n  Quaternion.slerp = function( a, b, t ) {\r\n    // if they are identical, just return one of them\r\n    if ( a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w ) {\r\n      return a;\r\n    }\r\n\r\n    var dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\r\n\r\n    if ( dot < 0 ) {\r\n      b = b.negated();\r\n      dot = -dot;\r\n    }\r\n\r\n    // how much of each quaternion should be contributed\r\n    var ratioA = 1 - t;\r\n    var ratioB = t;\r\n\r\n    // tweak them if necessary\r\n    if ( ( 1 - dot ) > 0.1 ) {\r\n      var theta = Math.acos( dot );\r\n      var invSinTheta = ( 1 / Math.sin( theta ) );\r\n\r\n      ratioA = ( Math.sin( ( 1 - t ) * theta ) * invSinTheta );\r\n      ratioB = ( Math.sin( ( t * theta ) ) * invSinTheta );\r\n    }\r\n\r\n    return new Quaternion(\r\n      ratioA * a.x + ratioB * b.x,\r\n      ratioA * a.y + ratioB * b.y,\r\n      ratioA * a.z + ratioB * b.z,\r\n      ratioA * a.w + ratioB * b.w\r\n    );\r\n  };\r\n\r\n  Poolable.mixin( Quaternion, {\r\n    defaultFactory: function() { return new Quaternion(); },\r\n    constructorDuplicateFactory: function( pool ) {\r\n      return function( x, y, z, w ) {\r\n        if ( pool.length ) {\r\n          return pool.pop().set( x, y, z, w );\r\n        }\r\n        else {\r\n          return new Quaternion( x, y, z, w );\r\n        }\r\n      };\r\n    }\r\n  } );\r\n\r\n  return Quaternion;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A 2D rectangle-shaped bounded area, with a convenience name and constructor. Totally functionally\r\n * equivalent to Bounds2, but with a different constructor.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Rectangle',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n\r\n  dot.Rectangle = function Rectangle( x, y, width, height ) {\r\n    assert && assert( height !== undefined, 'Rectangle requires 4 parameters' );\r\n    Bounds2.call( this, x, y, x + width, y + height );\r\n  };\r\n  var Rectangle = dot.Rectangle;\r\n\r\n  inherit( Bounds2, Rectangle );\r\n\r\n  return Rectangle;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * 3-dimensional ray\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Ray3',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  dot.Ray3 = function Ray3( pos, dir ) {\r\n    this.pos = pos;\r\n    this.dir = dir;\r\n  };\r\n  var Ray3 = dot.Ray3;\r\n\r\n  Ray3.prototype = {\r\n    constructor: Ray3,\r\n\r\n    shifted: function( distance ) {\r\n      return new Ray3( this.pointAtDistance( distance ), this.dir );\r\n    },\r\n\r\n    pointAtDistance: function( distance ) {\r\n      return this.pos.plus( this.dir.timesScalar( distance ) );\r\n    },\r\n\r\n    // @param {Plane3} plane\r\n    distanceToPlane: function( plane ) {\r\n      return ( plane.distance - this.pos.dot( plane.normal ) ) / this.dir.dot( plane.normal );\r\n    },\r\n\r\n    toString: function() {\r\n      return this.pos.toString() + \" => \" + this.dir.toString();\r\n    }\r\n  };\r\n\r\n  return Ray3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * A sphere in 3 dimensions (NOT a 3-sphere).\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Sphere3',['require','DOT/dot'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  /*\r\n   * @constructor\r\n   * @param {Vector3} center - The center of the sphere\r\n   * @param {number} radius - The radius of the sphere\r\n   */\r\n  dot.Sphere3 = function Sphere3( center, radius ) {\r\n    this.center = center;\r\n    this.radius = radius;\r\n\r\n    assert && assert( radius >= 0 );\r\n\r\n    phetAllocation && phetAllocation( 'Sphere3' );\r\n  };\r\n  var Sphere3 = dot.Sphere3;\r\n\r\n  Sphere3.prototype = {\r\n    constructor: Sphere3,\r\n\r\n    /*\r\n     * @param {Ray3} ray - The ray to intersect with the sphere\r\n     * @param {number} epsilon - A small varing-point value to be used to handle intersections tangent to the sphere\r\n     * @returns An intersection result { distance, hitPoint, normal, fromOutside }, or null if the sphere is behind the ray\r\n     */\r\n    intersect: function( ray, epsilon ) {\r\n      var raydir = ray.dir;\r\n      var pos = ray.pos;\r\n      var centerToRay = pos.minus( this.center );\r\n\r\n      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)\r\n      var tmp = raydir.dot( centerToRay );\r\n      var centerToRayDistSq = centerToRay.magnitudeSquared();\r\n      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this.radius * this.radius );\r\n      if ( det < epsilon ) {\r\n        // ray misses sphere entirely\r\n        return null;\r\n      }\r\n\r\n      var base = raydir.dot( this.center ) - raydir.dot( pos );\r\n      var sqt = Math.sqrt( det ) / 2;\r\n\r\n      // the \"first\" entry point distance into the sphere. if we are inside the sphere, it is behind us\r\n      var ta = base - sqt;\r\n\r\n      // the \"second\" entry point distance\r\n      var tb = base + sqt;\r\n\r\n      if ( tb < epsilon ) {\r\n        // sphere is behind ray, so don't return an intersection\r\n        return null;\r\n      }\r\n\r\n      var hitPositionB = ray.pointAtDistance( tb );\r\n      var normalB = hitPositionB.minus( this.center ).normalized();\r\n\r\n      if ( ta < epsilon ) {\r\n        // we are inside the sphere\r\n        // in => out\r\n        return {\r\n          distance: tb,\r\n          hitPoint: hitPositionB,\r\n          normal: normalB.negated(),\r\n          fromOutside: false\r\n        };\r\n      }\r\n      else {\r\n        // two possible hits\r\n        var hitPositionA = ray.pointAtDistance( ta );\r\n        var normalA = hitPositionA.minus( this.center ).normalized();\r\n\r\n        // close hit, we have out => in\r\n        return {\r\n          distance: ta,\r\n          hitPoint: hitPositionA,\r\n          normal: normalA,\r\n          fromOutside: true\r\n        };\r\n      }\r\n    },\r\n\r\n    /*\r\n     * @param {Ray3} ray - The ray to intersect with the sphere\r\n     * @param {number} epsilon - A small varing-point value to be used to handle intersections tangent to the sphere\r\n     * @returns An array of intersection results like { distance, hitPoint, normal, fromOutside }. Will be 0 or 2, with\r\n     *          the \"proper\" intersection first, if applicable (closest in front of the ray).\r\n     */\r\n    intersections: function( ray, epsilon ) {\r\n      var raydir = ray.dir;\r\n      var pos = ray.pos;\r\n      var centerToRay = pos.minus( this.center );\r\n\r\n      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)\r\n      var tmp = raydir.dot( centerToRay );\r\n      var centerToRayDistSq = centerToRay.magnitudeSquared();\r\n      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this.radius * this.radius );\r\n      if ( det < epsilon ) {\r\n        // ray misses sphere entirely\r\n        return [];\r\n      }\r\n\r\n      var base = raydir.dot( this.center ) - raydir.dot( pos );\r\n      var sqt = Math.sqrt( det ) / 2;\r\n\r\n      // the \"first\" entry point distance into the sphere. if we are inside the sphere, it is behind us\r\n      var ta = base - sqt;\r\n\r\n      // the \"second\" entry point distance\r\n      var tb = base + sqt;\r\n\r\n      if ( tb < epsilon ) {\r\n        // sphere is behind ray, so don't return an intersection\r\n        return [];\r\n      }\r\n\r\n      var hitPositionB = ray.pointAtDistance( tb );\r\n      var normalB = hitPositionB.minus( this.center ).normalized();\r\n\r\n      var hitPositionA = ray.pointAtDistance( ta );\r\n      var normalA = hitPositionA.minus( this.center ).normalized();\r\n\r\n      var resultB = {\r\n        distance: tb,\r\n        hitPoint: hitPositionB,\r\n        normal: normalB.negated(),\r\n        fromOutside: false\r\n      };\r\n      var resultA = {\r\n        distance: ta,\r\n        hitPoint: hitPositionA,\r\n        normal: normalA,\r\n        fromOutside: true\r\n      };\r\n      if ( ta < epsilon ) {\r\n        // we are inside the sphere\r\n        // in => out\r\n\r\n        return [ resultB, resultA ];\r\n      }\r\n      else {\r\n        // two possible hits\r\n\r\n        // close hit, we have out => in\r\n        return [ resultA, resultB ];\r\n      }\r\n    }\r\n  };\r\n\r\n  return Sphere3;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Forward and inverse transforms with 4x4 matrices, allowing flexibility including affine and perspective transformations.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'DOT/Transform4',['require','DOT/dot','DOT/Matrix4','DOT/Vector3','DOT/Ray3'],function( require ) {\r\n  'use strict';\r\n\r\n  var dot = require( 'DOT/dot' );\r\n\r\n  require( 'DOT/Matrix4' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Ray3' );\r\n\r\n  // takes a 4x4 matrix\r\n  dot.Transform4 = function Transform4( matrix ) {\r\n    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices\r\n    this.setMatrix( matrix === undefined ? dot.Matrix4.IDENTITY : matrix );\r\n  };\r\n  var Transform4 = dot.Transform4;\r\n\r\n  Transform4.prototype = {\r\n    constructor: Transform4,\r\n\r\n    setMatrix: function( matrix ) {\r\n      this.matrix = matrix;\r\n\r\n      // compute these lazily\r\n      this.inverse = null;\r\n      this.matrixTransposed = null; // since WebGL won't allow transpose == true\r\n      this.inverseTransposed = null;\r\n    },\r\n\r\n    getMatrix: function() {\r\n      return this.matrix;\r\n    },\r\n\r\n    getInverse: function() {\r\n      if ( this.inverse === null ) {\r\n        this.inverse = this.matrix.inverted();\r\n      }\r\n      return this.inverse;\r\n    },\r\n\r\n    getMatrixTransposed: function() {\r\n      if ( this.matrixTransposed === null ) {\r\n        this.matrixTransposed = this.matrix.transposed();\r\n      }\r\n      return this.matrixTransposed;\r\n    },\r\n\r\n    getInverseTransposed: function() {\r\n      if ( this.inverseTransposed === null ) {\r\n        this.inverseTransposed = this.getInverse().transposed();\r\n      }\r\n      return this.inverseTransposed;\r\n    },\r\n\r\n    prepend: function( matrix ) {\r\n      this.setMatrix( matrix.timesMatrix( this.matrix ) );\r\n    },\r\n\r\n    append: function( matrix ) {\r\n      this.setMatrix( this.matrix.timesMatrix( matrix ) );\r\n    },\r\n\r\n    prependTransform: function( transform ) {\r\n      this.prepend( transform.matrix );\r\n    },\r\n\r\n    appendTransform: function( transform ) {\r\n      this.append( transform.matrix );\r\n    },\r\n\r\n    isIdentity: function() {\r\n      return this.matrix.type === dot.Matrix4.Types.IDENTITY;\r\n    },\r\n\r\n    // applies the 2D affine transform part of the transformation\r\n    applyToCanvasContext: function( context ) {\r\n      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m03(), this.matrix.m13() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * forward transforms (for Vector3 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // transform a position (includes translation)\r\n    transformPosition3: function( vec3 ) {\r\n      return this.matrix.timesVector3( vec3 );\r\n    },\r\n\r\n    // transform a vector (exclude translation)\r\n    transformDelta3: function( vec3 ) {\r\n      return this.matrix.timesRelativeVector3( vec3 );\r\n    },\r\n\r\n    // transform a normal vector (different than a normal vector)\r\n    transformNormal3: function( vec3 ) {\r\n      return this.getInverse().timesTransposeVector3( vec3 );\r\n    },\r\n\r\n    transformDeltaX: function( x ) {\r\n      return this.transformDelta3( new dot.Vector3( x, 0, 0 ) ).x;\r\n    },\r\n\r\n    transformDeltaY: function( y ) {\r\n      return this.transformDelta3( new dot.Vector3( 0, y, 0 ) ).y;\r\n    },\r\n\r\n    transformDeltaZ: function( z ) {\r\n      return this.transformDelta3( new dot.Vector3( 0, 0, z ) ).z;\r\n    },\r\n\r\n    transformRay: function( ray ) {\r\n      return new dot.Ray3(\r\n        this.transformPosition3( ray.pos ),\r\n        this.transformPosition3( ray.pos.plus( ray.dir ) ).minus( this.transformPosition3( ray.pos ) ) );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * inverse transforms (for Vector3 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    inversePosition3: function( vec3 ) {\r\n      return this.getInverse().timesVector3( vec3 );\r\n    },\r\n\r\n    inverseDelta3: function( vec3 ) {\r\n      // inverse actually has the translation rolled into the other coefficients, so we have to make this longer\r\n      return this.inversePosition3( vec3 ).minus( this.inversePosition3( dot.Vector3.ZERO ) );\r\n    },\r\n\r\n    inverseNormal3: function( vec3 ) {\r\n      return this.matrix.timesTransposeVector3( vec3 );\r\n    },\r\n\r\n    inverseDeltaX: function( x ) {\r\n      return this.inverseDelta3( new dot.Vector3( x, 0, 0 ) ).x;\r\n    },\r\n\r\n    inverseDeltaY: function( y ) {\r\n      return this.inverseDelta3( new dot.Vector3( 0, y, 0 ) ).y;\r\n    },\r\n\r\n    inverseDeltaZ: function( z ) {\r\n      return this.inverseDelta3( new dot.Vector3( 0, 0, z ) ).z;\r\n    },\r\n\r\n    inverseRay: function( ray ) {\r\n      return new dot.Ray3(\r\n        this.inversePosition3( ray.pos ),\r\n        this.inversePosition3( ray.pos.plus( ray.dir ) ).minus( this.inversePosition3( ray.pos ) )\r\n      );\r\n    }\r\n  };\r\n\r\n  return Transform4;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Removes a single (the first) matching object from an Array.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/arrayRemove',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  /*\r\n   * @param {Array} arr\r\n   * @param {*} item - The item to remove from the array\r\n   */\r\n  core.arrayRemove = function arrayRemove( arr, item ) {\r\n    assert && assert( arr instanceof Array, 'arrayRemove either takes an Array' );\r\n\r\n    var index = _.indexOf( arr, item );\r\n    assert && assert( index >= 0, 'item not found in Array' );\r\n\r\n    arr.splice( index, 1 );\r\n  };\r\n\r\n  return core.arrayRemove;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\ndefine( 'DOT/main',[\r\n  'DOT/dot',\r\n  'DOT/Bounds2',\r\n  'DOT/Bounds3',\r\n  'DOT/Complex',\r\n  'DOT/ConvexHull2',\r\n  'DOT/Dimension2',\r\n  'DOT/EigenvalueDecomposition',\r\n  'DOT/LinearFunction',\r\n  'DOT/LUDecomposition',\r\n  'DOT/Matrix',\r\n  'DOT/Matrix3',\r\n  'DOT/Matrix4',\r\n  'DOT/ObservableBounds2',\r\n  'DOT/ObservableMatrix3',\r\n  'DOT/ObservableVector2',\r\n  'DOT/Permutation',\r\n  'DOT/Plane3',\r\n  'DOT/QRDecomposition',\r\n  'DOT/Quaternion',\r\n  'DOT/Ray2',\r\n  'DOT/Ray3',\r\n  'DOT/Rectangle',\r\n  'DOT/SingularValueDecomposition',\r\n  'DOT/Sphere3',\r\n  'DOT/Transform3',\r\n  'DOT/Transform4',\r\n  'DOT/Util',\r\n  'DOT/Vector2',\r\n  'DOT/Vector3',\r\n  'DOT/Vector4'\r\n], function( dot ) {\r\n  'use strict';\r\n  return dot;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * If given an Array, removes all of its elements and returns it. Otherwise, if given a falsy value\r\n * (null/undefined/etc.), it will create and return a fresh Array.\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/cleanArray',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.cleanArray = function cleanArray( arr ) {\r\n    assert && assert( !arr || ( arr instanceof Array ), 'cleanArray either takes an Array' );\r\n\r\n    if ( arr ) {\r\n      // fastest way to clear an array (http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript, http://jsperf.com/array-destroy/32)\r\n      // also, better than length=0, since it doesn't create significant garbage collection (like length=0), tested on Chrome 34.\r\n      while ( arr.length ) {\r\n        arr.pop();\r\n      }\r\n      return arr;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n  };\r\n\r\n  return core.cleanArray;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Creates an array of results from an iterator that takes a callback.\r\n *\r\n * For instance, if calling a function f( g ) will call g( 1 ), g( 2 ), and g( 3 ),\r\n * collect( function( callback ) { f( callback ); } );\r\n * will return [1,2,3].\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/collect',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.collect = function collect( iterate ) {\r\n    assert && assert( typeof iterate === 'function' );\r\n    var result = [];\r\n    iterate( function( ob ) {\r\n      result.push( ob );\r\n    } );\r\n    return result;\r\n  };\r\n  return core.collect;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Scans through potential properties on an object to detect prefixed forms, and returns the first match.\r\n *\r\n * E.g. currently:\r\n * core.detectPrefix( document.createElement( 'div' ).style, 'transform' ) === 'webkitTransform'\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/detectPrefix',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  // @returns the best String str where obj[str] !== undefined, or returns undefined if that is not available\r\n  core.detectPrefix = function detectPrefix( obj, name ) {\r\n    if ( obj[ name ] !== undefined ) { return name; }\r\n\r\n    // prepare for camelCase\r\n    name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );\r\n\r\n    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe\r\n    if ( obj[ 'moz' + name ] !== undefined ) { return 'moz' + name; }\r\n    if ( obj[ 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?\r\n    if ( obj[ 'webkit' + name ] !== undefined ) { return 'webkit' + name; }\r\n    if ( obj[ 'ms' + name ] !== undefined ) { return 'ms' + name; }\r\n    if ( obj[ 'o' + name ] !== undefined ) { return 'o' + name; }\r\n    return undefined;\r\n  };\r\n\r\n  return core.detectPrefix;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Scans through potential event properties on an object to detect prefixed forms, and returns the first match.\r\n *\r\n * E.g. currently:\r\n * core.detectPrefixEvent( document, 'fullscreenchange' ) === 'webkitfullscreenchange'\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/detectPrefixEvent',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  // @returns the best String str where obj['on'+str] !== undefined, or returns undefined if that is not available\r\n  core.detectPrefixEvent = function detectPrefixEvent( obj, name, isEvent ) {\r\n    if ( obj[ 'on' + name ] !== undefined ) { return name; }\r\n\r\n    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe\r\n    if ( obj[ 'on' + 'moz' + name ] !== undefined ) { return 'moz' + name; }\r\n    if ( obj[ 'on' + 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?\r\n    if ( obj[ 'on' + 'webkit' + name ] !== undefined ) { return 'webkit' + name; }\r\n    if ( obj[ 'on' + 'ms' + name ] !== undefined ) { return 'ms' + name; }\r\n    if ( obj[ 'on' + 'o' + name ] !== undefined ) { return 'o' + name; }\r\n    return undefined;\r\n  };\r\n\r\n  return core.detectPrefixEvent;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Escaping of HTML content that will be placed in the body, inside an element as a node.\r\n *\r\n * This is NOT for escaping something in other HTML contexts, for example as an attribute value\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\ndefine( 'PHET_CORE/escapeHTML',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.escapeHTML = function escapeHTML( str ) {\r\n    // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet\r\n    // HTML Entity Encoding\r\n    return str\r\n      .replace( /&/g, '&amp;' )\r\n      .replace( /</g, '&lt;' )\r\n      .replace( />/g, '&gt;' )\r\n      .replace( /\\\"/g, '&quot;' )\r\n      .replace( /\\'/g, '&#x27;' )\r\n      .replace( /\\//g, '&#x2F;' );\r\n  };\r\n  return core.escapeHTML;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Abstraction for timed-event series that helps with variable frame-rates. Useful for things that need to happen at a\r\n * specific rate real-time regardless of the frame-rate.\r\n *\r\n * An EventTimer is created with a specific event \"model\" that determines when events occur, and a callback that will\r\n * be triggered for each event (with its time elapsed since it should have occurred).\r\n *\r\n * To run the EventTimer, call step( realTimeElapsed ), and it will call your callback for every event that would have\r\n * occurred over that time-frame (possibly zero).\r\n *\r\n * For example, create a timer with a constant rate that it will fire events every 1 time units:\r\n *\r\n * var timer = new core.EventTimer( new core.EventTimer.ConstantEventModel( 1 ), function( timeElapsed ) {\r\n *   console.log( 'event with timeElapsed: ' + timeElapsed );\r\n * } );\r\n *\r\n * Stepping once for 1.5 time units will fire once (0.5 seconds since the \"end\" of the step), and will be 0.5 seconds\r\n * from the next step:\r\n *\r\n * timer.step( 1.5 );\r\n * > event with timeElapsed: 0.5\r\n *\r\n * Stepping for a longer time will result in more events:\r\n *\r\n * timer.step( 6 );\r\n * > event with timeElapsed: 5.5\r\n * > event with timeElapsed: 4.5\r\n * > event with timeElapsed: 3.5\r\n * > event with timeElapsed: 2.5\r\n * > event with timeElapsed: 1.5\r\n * > event with timeElapsed: 0.5\r\n *\r\n * A step with zero time will trigger no events:\r\n *\r\n * timer.step( 0 );\r\n *\r\n * The timer will fire an event once it reaches the exact point in time:\r\n *\r\n * timer.step( 1.5 );\r\n * > event with timeElapsed: 1\r\n * > event with timeElapsed: 0\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/EventTimer',['require','PHET_CORE/core','PHET_CORE/inherit'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n\r\n  /*\r\n   * Create an event timer with a specific model (determines the time between events), and a callback to be called\r\n   * for events.\r\n   *\r\n   * @param {Object with getPeriodBeforeNextEvent(): Number} eventModel: getPeriodBeforeNextEvent() will be called at\r\n   *    the start and after every event to determine the time required to pass by before the next event occurs.\r\n   * @param {function} eventCallback( timeElapsed ): Will be called for every event. The timeElapsed passed in as the\r\n   *    only argument denotes the time elapsed since the event would have occurred. E.g. if we step for 5 seconds and\r\n   *    our event would have occurred 1 second into that step, the timeElapsed will be 4 seconds, since after the end\r\n   *    of the 5 seconds the event would have happened 4 seconds ago.\r\n   */\r\n  core.EventTimer = function EventTimer( eventModel, eventCallback ) {\r\n    assert && assert( typeof eventCallback === 'function', 'EventTimer requires a callback' );\r\n\r\n    this.eventModel = eventModel;\r\n    this.eventCallback = eventCallback;\r\n\r\n    this.timeBeforeNextEvent = this.eventModel.getPeriodBeforeNextEvent();\r\n  };\r\n\r\n  inherit( Object, core.EventTimer, {\r\n    step: function( dt ) {\r\n      while ( dt >= this.timeBeforeNextEvent ) {\r\n        dt -= this.timeBeforeNextEvent;\r\n        this.timeBeforeNextEvent = this.eventModel.getPeriodBeforeNextEvent();\r\n\r\n        // how much time has elapsed since this event began\r\n        this.eventCallback( dt );\r\n      }\r\n\r\n      // use up the remaining DT\r\n      this.timeBeforeNextEvent -= dt;\r\n    }\r\n  } );\r\n\r\n  /*\r\n   * Event model that will fire events at a constant rate. An event will occur every 1/rate time units.\r\n   * @param {number} rate\r\n   */\r\n  core.EventTimer.ConstantEventModel = inherit( Object, function ConstantEventRate( rate ) {\r\n    assert && assert( typeof rate === 'number',\r\n      'The rate should be a number' );\r\n    assert && assert( rate > 0,\r\n      'We need to have a strictly positive rate in order to prevent infinite loops.' );\r\n\r\n    this.rate = rate;\r\n  }, {\r\n    getPeriodBeforeNextEvent: function() {\r\n      return 1 / this.rate;\r\n    }\r\n  } );\r\n\r\n  /*\r\n   * Event model that will fire events averaging a certain rate, but with the time between events being uniformly\r\n   * random.\r\n   * The pseudoRandomNumberSource, when called, should generate uniformly distributed random numbers in the range [0,1).\r\n   * @param {number} rate\r\n   * @param {function} pseudoRandomNumberSource() : Number\r\n   */\r\n  core.EventTimer.UniformEventModel = inherit( Object, function UniformEventModel( rate, pseudoRandomNumberSource ) {\r\n    assert && assert( typeof rate === 'number',\r\n      'The rate should be a number' );\r\n    assert && assert( typeof pseudoRandomNumberSource === 'function',\r\n      'The pseudo-random number source should be a function' );\r\n    assert && assert( rate > 0,\r\n      'We need to have a strictly positive rate in order to prevent infinite loops.' );\r\n\r\n    this.rate = rate;\r\n    this.pseudoRandomNumberSource = pseudoRandomNumberSource;\r\n  }, {\r\n    getPeriodBeforeNextEvent: function() {\r\n      var uniformRandomNumber = this.pseudoRandomNumberSource();\r\n      assert && assert( typeof uniformRandomNumber === 'number' &&\r\n                        uniformRandomNumber >= 0 && uniformRandomNumber < 1,\r\n        'Our uniform random number is outside of its expected range with a value of ' + uniformRandomNumber );\r\n\r\n      // sample the exponential distribution\r\n      return uniformRandomNumber * 2 / this.rate;\r\n    }\r\n  } );\r\n\r\n  /*\r\n   * Event model that will fire events corresponding to a Poisson process with the specified rate.\r\n   * The pseudoRandomNumberSource, when called, should generate uniformly distributed random numbers in the range [0,1).\r\n   * @param {number} rate\r\n   * @param {function} pseudoRandomNumberSource() : number\r\n   */\r\n  core.EventTimer.PoissonEventModel = inherit( Object, function PoissonEventModel( rate, pseudoRandomNumberSource ) {\r\n    assert && assert( typeof rate === 'number',\r\n      'The time between events should be a number' );\r\n    assert && assert( typeof pseudoRandomNumberSource === 'function',\r\n      'The pseudo-random number source should be a function' );\r\n    assert && assert( rate > 0,\r\n      'We need to have a strictly positive poisson rate in order to prevent infinite loops.' );\r\n\r\n    this.rate = rate;\r\n    this.pseudoRandomNumberSource = pseudoRandomNumberSource;\r\n  }, {\r\n    getPeriodBeforeNextEvent: function() {\r\n      // A poisson process can be described as having an independent exponential distribution for the time between\r\n      // consecutive events.\r\n      // see http://en.wikipedia.org/wiki/Exponential_distribution#Generating_exponential_variates and\r\n      // http://en.wikipedia.org/wiki/Poisson_process\r\n\r\n      var uniformRandomNumber = this.pseudoRandomNumberSource();\r\n      assert && assert( typeof uniformRandomNumber === 'number' &&\r\n                        uniformRandomNumber >= 0 && uniformRandomNumber < 1,\r\n        'Our uniform random number is outside of its expected range with a value of ' + uniformRandomNumber );\r\n\r\n      // sample the exponential distribution\r\n      return -Math.log( uniformRandomNumber ) / this.rate;\r\n    }\r\n  } );\r\n\r\n  return core.EventTimer;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Loads a script\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/loadScript',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  /*\r\n   * Load a script. The only required argument is src, and can be specified either as\r\n   * loadScript( \"<url>\" ) or loadScript( { src: \"<url>\", ... other options ... } ).\r\n   *\r\n   * Arguments:\r\n   *   src:         The source of the script to load\r\n   *   callback:    A callback to call (with no arguments) once the script is loaded and has been executed\r\n   *   async:       Whether the script should be loaded asynchronously. Defaults to true\r\n   *   cacheBuster: Whether the URL should have an appended query string to work around caches\r\n   */\r\n  core.loadScript = function loadScript( args ) {\r\n    // handle a string argument\r\n    if ( typeof args === 'string' ) {\r\n      args = { src: args };\r\n    }\r\n\r\n    var src = args.src;\r\n    var callback = args.callback;\r\n    var async = args.async === undefined ? true : args.async;\r\n    var cacheBuster = args.cacheBuster === undefined ? false : args.cacheBuster;\r\n\r\n    var called = false;\r\n\r\n    var script = document.createElement( 'script' );\r\n    script.type = 'text/javascript';\r\n    script.async = async;\r\n    script.onload = script.onreadystatechange = function() {\r\n      var state = this.readyState;\r\n      if ( state && state !== \"complete\" && state !== \"loaded\" ) {\r\n        return;\r\n      }\r\n\r\n      if ( !called ) {\r\n        called = true;\r\n\r\n        if ( callback ) {\r\n          callback();\r\n        }\r\n      }\r\n    };\r\n\r\n    // make sure things aren't cached, just in case\r\n    script.src = src + ( cacheBuster ? '?random=' + Math.random().toFixed( 10 ) : '' );\r\n\r\n    var other = document.getElementsByTagName( 'script' )[ 0 ];\r\n    other.parentNode.insertBefore( script, other );\r\n  };\r\n\r\n  return core.loadScript;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Partitions an array into two arrays: the first contains all elements that satisfy the predicate, and the second\r\n * contains all the (other) elements that do not satisfy the predicate.\r\n *\r\n * e.g. partition( [1,2,3,4], function( n ) { return n % 2 === 0; } ) will return [[2,4],[1,3]]\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/partition',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.partition = function partition( array, predicate ) {\r\n    assert && assert( array instanceof Array );\r\n    assert && assert( typeof predicate === 'function' );\r\n\r\n    var satisfied = [];\r\n    var unsatisfied = [];\r\n    var length = array.length;\r\n    for ( var i = 0; i < length; i++ ) {\r\n      if ( predicate( array[ i ] ) ) {\r\n        satisfied.push( array[ i ] );\r\n      }\r\n      else {\r\n        unsatisfied.push( array[ i ] );\r\n      }\r\n    }\r\n\r\n    return [ satisfied, unsatisfied ];\r\n  };\r\n  return core.partition;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Creates an array of arrays, which consists of pairs of objects from the input array without duplication.\r\n *\r\n * For example, core.pairs( [ 'a', 'b', 'c' ] ) will return:\r\n * [ [ 'a', 'b' ], [ 'a', 'c' ], [ 'b', 'c' ] ]\r\n *\r\n * @author Jonathan Olson <jonathan.olson@colorado.edu>\r\n */\r\n\r\ndefine( 'PHET_CORE/pairs',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  core.pairs = function pairs( array ) {\r\n    var result = [];\r\n    var length = array.length;\r\n    if ( length > 1 ) {\r\n      for ( var i = 0; i < length - 1; i++ ) {\r\n        var first = array[ i ];\r\n        for ( var j = i + 1; j < length; j++ ) {\r\n          result.push( [ first, array[ j ] ] );\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n  return core.pairs;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Code for testing which platform is running.  Use sparingly, if at all!\r\n *\r\n * Sample usage:\r\n * if (platform.firefox) {node.renderer = 'canvas';}\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'PHET_CORE/platform',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  var ua = navigator.userAgent;\r\n\r\n  // taken from HomeScreen\r\n  function isIE( version ) {\r\n    return getInternetExplorerVersion() === version;\r\n  }\r\n\r\n  //IE11 no longer reports MSIE in the user agent string, see https://github.com/phetsims/phet-core/issues/12\r\n  //This code is adapted from http://stackoverflow.com/questions/17907445/how-to-detect-ie11\r\n  function getInternetExplorerVersion() {\r\n    var rv = -1;\r\n    var re = null;\r\n    if ( navigator.appName === 'Microsoft Internet Explorer' ) {\r\n      re = new RegExp( 'MSIE ([0-9]{1,}[.0-9]{0,})' );\r\n      if ( re.exec( ua ) !== null ) {\r\n        rv = parseFloat( RegExp.$1 );\r\n      }\r\n    }\r\n    else if ( navigator.appName === 'Netscape' ) {\r\n      re = new RegExp( 'Trident/.*rv:([0-9]{1,}[.0-9]{0,})' );\r\n      if ( re.exec( ua ) !== null ) {\r\n        rv = parseFloat( RegExp.$1 );\r\n      }\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  core.platform = {\r\n    get firefox() { return ua.toLowerCase().indexOf( 'firefox' ) > -1; },\r\n\r\n    //see http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari\r\n    get mobileSafari() { return ua.match( /(iPod|iPhone|iPad)/ ) && ua.match( /AppleWebKit/ ); },\r\n    get safari5() { return ua.match( /Version\\/5\\./ ) && ua.match( /Safari\\// ) && ua.match( /AppleWebKit/ ); },\r\n    get safari6() { return ua.match( /Version\\/6\\./ ) && ua.match( /Safari\\// ) && ua.match( /AppleWebKit/ ); },\r\n    get safari7() { return ua.match( /Version\\/7\\./ ) && ua.match( /Safari\\// ) && ua.match( /AppleWebKit/ ); },\r\n\r\n    get ie9() { return isIE( 9 ); },\r\n    get ie10() { return isIE( 10 ); },\r\n    get ie11() { return isIE( 11 ); },\r\n    get ie() { return getInternetExplorerVersion() !== -1; },\r\n\r\n    // from HomeScreen\r\n    get android() { return ua.indexOf( 'Android' ) > 0; },\r\n\r\n    get chromium() { return (/chrom(e|ium)/).test( ua.toLowerCase() ); }\r\n  };\r\n\r\n  return core.platform;\r\n} );\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\n/**\r\n * Simple profiler which handles nested calls which provides a composite view, to help for micro-optimization.\r\n * Usage:\r\n * profiler.start('updateScene');\r\n * ...\r\n * profiler.start('moveObjects');\r\n * ...\r\n * profiler.stop();\r\n * ...\r\n * profiler.stop();\r\n * See testSelf() for a larger example. This could be used on ipad for instance.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'PHET_CORE/profiler',['require','PHET_CORE/core'],function( require ) {\r\n  'use strict';\r\n\r\n  var core = require( 'PHET_CORE/core' );\r\n\r\n  var stack = [];\r\n  var results = {};\r\n  var count = 0;\r\n  var listeners = [];\r\n  core.profiler = {\r\n    displayCount: 1000,\r\n    start: function( name ) {\r\n      var time = Date.now();\r\n      stack.push( { name: name, time: time } );\r\n    },\r\n    addListener: function( listener ) {\r\n      listeners.push( listener );\r\n    },\r\n    stop: function() {\r\n      var end = Date.now();\r\n      var top = stack.pop();\r\n      var elapsed = end - top.time;\r\n      if ( !results[ top.name ] ) {\r\n        results[ top.name ] = [];\r\n      }\r\n      //TODO: this may be a memory problem, consider coalescing (averaging or summing) values here\r\n      results[ top.name ].push( elapsed );\r\n      count++;\r\n      if ( count % this.displayCount === 0 ) {\r\n        var summary = JSON.stringify( this.toJSON() );\r\n\r\n        console.log( summary );\r\n\r\n        //Also notify listeners that a new result was obtained\r\n        for ( var i = 0; i < listeners.length; i++ ) {\r\n          listeners[ i ]( summary );\r\n        }\r\n        results = {};\r\n      }\r\n    },\r\n    toJSON: function() {\r\n      var summary = {};\r\n      var sum;\r\n      for ( var property in results ) {\r\n        sum = 0;\r\n        for ( var i = 0; i < results[ property ].length; i++ ) {\r\n          var time = results[ property ][ i ];\r\n          sum += time;\r\n        }\r\n        var average = sum / results[ property ].length;\r\n        summary[ property ] = { average: average, count: results[ property ].length };\r\n      }\r\n      return summary;\r\n    },\r\n\r\n    //sanity test\r\n    testSelf: function() {\r\n      var a, b;\r\n      var profiler = this;\r\n      this.displayCount = 10000000;//Only show final result\r\n      for ( var i = 0; i < 10; i++ ) {\r\n        profiler.start( 'physics' );\r\n        for ( var k = 0; k < 10000; k++ ) {\r\n          profiler.start( 'mloop' );\r\n          for ( var m = 0; m < 10000; m++ ) {\r\n            a = 100 * 200;\r\n          }\r\n          profiler.stop();\r\n          profiler.start( 'xloop' );\r\n          for ( var x = 0; x < 20000; x++ ) {\r\n            b = 100 * 200;\r\n          }\r\n          profiler.stop();\r\n        }\r\n        profiler.stop();\r\n      }\r\n\r\n      console.log( 'results: ', a, b );\r\n      console.log( JSON.stringify( this.toJSON() ) );\r\n\r\n      //sample correct output on chrome: {\"mloop\":{\"average\":0.01675,\"count\":100000},\"xloop\":{\"average\":0.03254,\"count\":100000},\"physics\":{\"average\":498.9,\"count\":10}}\r\n    }\r\n  };\r\n//  profiler.testSelf();\r\n  return core.profiler;\r\n} );\r\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\nrequire.config( {\r\n  deps: [ 'main', 'DOT/main', 'PHET_CORE/main' ],\r\n\r\n  paths: {\r\n    underscore: '../../sherpa/lodash-2.4.1',\r\n    KITE: '.',\r\n    DOT: '../../dot/js',\r\n    PHET_CORE: '../../phet-core/js',\r\n    AXON: '../../axon/js'\r\n  },\r\n\r\n  shim: {\r\n    underscore: { exports: '_' }\r\n  },\r\n\r\n  // optional cache buster to make browser refresh load all included scripts, can be disabled with ?cacheBuster=false\r\n  urlArgs: Date.now()\r\n} );\r\n\ndefine(\"config\", function(){});\n\n","// Copyright 2002-2014, University of Colorado Boulder\r\n\r\ndefine( 'PHET_CORE/main',[\r\n  'PHET_CORE/core',\r\n  'PHET_CORE/arrayRemove',\r\n  'PHET_CORE/cleanArray',\r\n  'PHET_CORE/collect',\r\n  'PHET_CORE/detectPrefix',\r\n  'PHET_CORE/detectPrefixEvent',\r\n  'PHET_CORE/escapeHTML',\r\n  'PHET_CORE/EventTimer',\r\n  'PHET_CORE/extend',\r\n  'PHET_CORE/inherit',\r\n  'PHET_CORE/isArray',\r\n  'PHET_CORE/loadScript',\r\n  'PHET_CORE/pairs',\r\n  'PHET_CORE/partition',\r\n  'PHET_CORE/phetAllocation',\r\n  'PHET_CORE/platform',\r\n  'PHET_CORE/Poolable',\r\n  'PHET_CORE/profiler'\r\n], function( core ) {\r\n  'use strict';\r\n  return core;\r\n} );\r\n\n"]}