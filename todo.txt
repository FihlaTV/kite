
Kite TODO  

Bugs:
  Transformed line segments seem to have intersection issues
  Arc:
    Shear transform broken
  EllipticalArc:
    Shear transform broken
    SVG-style ellipticalArcTo not implemented
  arc2/arc3 examples seem to trigger Chrome canvas bug? verify.
  Circle transform seems to break, probably not exactly 2pi anymore
  Stroking miterlimit on shear-transformed shape seems to not happen. normal-shear a rectangle
  Robustness:
    Finiteness checks a la WebKit?
    General usage of epsilon!
    Ray Intersections:
      Need general 'ambiguous' flag for intersection, so we can choose a new ray (or know that it's almost on a curve)
        Choose 2^-12 as Epsilon?
      Cases:
        Parallel and on top of line
        Endpoints (don't include start, but include end, if exactly equal)
        Cusps
    Reduction of things like Ellipse with zero-radius in one dimension into multiple line segments?
      Or handle crazy cases at the call-site?
    Degenerate segments - how to handle?
      Should they affect the stroking? Or just not exist?

Code:
  Segment 'points' are an annoyance except for when building the subpath. Thoughts on only keeping the last point instead?
  windingIntersection in segment base class?
  Move circle intersection to Dot (and any other particularly general-math parts)
  Testing:
    Visual shape test should allow switching to SVG output to verify?
    Create a simple way to do the comparisons that we already have in Scenery's tests
  Optimize parser or generated code to minimize file size

Performance:
  Consider eval to build a function that can render the shape to canvas, without all of the indirection, etc.
  Precise intersection with bounding box (not just intersection of bounds)
  Fast, possibly larger bounding box
  Sometimes a quick 'yes or unknown' or 'no or unknown' test will help significantly

Intersection:
  see http://cagd.cs.byu.edu/~557/text/ch7.pdf
  Sweep-line handling: http://www.lems.brown.edu/~wq/projects/cs252.html

Line Dash stroking

CSG:
  Will rely on region support + clipping algorithms
  Union / difference / intersection / XOR. consider a NOTHING and EVERYTHING shape like bounds?
  As a stop-gap, http://sourceforge.net/p/jsclipper/wiki/Home/ will handle polygons (but shapes will have many more segments)

Polygonalization
  Needed for WebGL, in addition to tesselation

Simplification
  Collapse "close" points
  Handling or removal of degenerate segments
  Remove self-intersection, group regions?
  Normalize winding order so it can be combined with other shape fills

Storing direction (undefined, CW, CCW) for each subpath
Storing invert flag for Shape (allow drawing or CSG for outside of shape?) - may be unnecessary with CSG operations

Adaptive bezier discretization / offset curves, see attached paper
  "Fast, precise ï¬‚attening of cubic Bezier path and offset curves" Hain, Ahmad
  Quadratic curve offsets need implementation improvement (32 sub-quadratics is too costly)
    Consider a more abstract segment like QuadraticOffset, CubicOffset, EllipticalArcOffset.
      Transforming + offsets are easy
      Can discretize later

Nonzero/evenodd support (not yet implemented in browsers)

Shape.polygon( vertices )

Region support:
  Edge cases (literally):
    Multiple curves intersect at same point with same tangent, but have different curvatures
    Overlapping segments (like a circle and a circular arc)
  Break into regions that can test for nonzero/evenodd, then combine adjacent ones so we can have efficient segments without the 'stroked region' overlap
  Fixes self-intersection in 'stroked' path
  Allows Constructive Solid Geometry
    Intersection of each type of segment - how to handle endpoint intersections in general
    
WebGL support? Probably just export a discretization with vertices. Region handling is important for this.

Consider bounding box handling for an arbitrary transform, for use with Node's isInGlobalBounds( globalBounds, currentTransform ).

Bezier:
  Degree elevation to Cubic
  Inflection points
  Split into monotonic segments. Bounds are easy (just from endpoints), should be ideal for intersection code

Segment:
  Find closest t for a given point

External:
  Dot: complex arithmetic
