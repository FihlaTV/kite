<!DOCTYPE html>
<html>
<!-- When run in the browser, this will load code into the global namespace so that it can be tested via the developer console -->
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Kite Playground</title>

  <script src="../../assert/js/assert.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <script data-main="../js/kite-config.js" src="../../sherpa/lib/require-2.1.11.js"></script>

</head>
<body>
<script>
  window.assertions.enableAssert();
  window.assertions.enableAssertSlow();

  require( [ 'kite-config' ], function() {
    require( [ 'main', 'AXON/main', 'DOT/main', 'PHET_CORE/main' ], function( kite, axon, dot, phetCore ) {
      window.kite = kite;
      window.axon = axon;
      window.dot = dot;
      window.phetCore = phetCore;

      console.log( 'loaded' );

      window.interTest = function() {
        window.a = new kite.Cubic( dot.v2( 0, 0 ), dot.v2( 10, 0 ), dot.v2( 10, 10 ), dot.v2( 20, 10 ) );
        window.b = new kite.Line( dot.v2( 0, -1 ), dot.v2( 20, 11 ) );
        setTimeout(function(){
          window.intersections = kite.Segment.boundsBasedIntersect( a, b );
          console.log( window.intersections );
          window.intersections2 = kite.BoundsIntersection.intersect( a, b );
          console.log( window.intersections2 );
        });
      };

      window.initTest = function() {
        window.a = new kite.Shape();
        window.b = new kite.Shape();

        a.moveTo( 10, 0 ).cubicCurveTo( 30, 10, 0, 10, 20, 0 ).close();
        b.rect( 0, 0, 5, 5 );

        window.graph = new kite.Graph();
        graph.addShape( 0, a );
        graph.addShape( 1, b );
        graph.computeSimplifiedFaces();
        graph.computeFaceInclusion( function( windingMap ) {
          return ( windingMap[ '0' ] !== 0 || windingMap[ '1' ] !== 0 ); // non-zero for first entry
        } );
        graph.debug();
        window.subgraph = graph.createFilledSubGraph();
        subgraph.debug();
        window.shape = subgraph.facesToShape();
        console.log( shape.getSVGPath() );

        // window.cubic = new kite.Cubic( dot.v2( 0 ,0 ), dot.v2( 0, 3 ), dot.v2( 10, 7 ), dot.v3( 10, 9 ) );
        // return kite.Cubic.getOverlaps( cubic.subdivided( 0.7 )[ 0 ], cubic.subdivided( 0.3 )[ 1 ] );
      };

      window.initLineTest = function() {
        // intersection with one ray returns a different result than another. need to add indeterminate intersection handling
        window.shape = new kite.Shape( 'M -100 -100 L -50 50 L 50 50 L 30 0' );
        window.ray1 = new dot.Ray2( dot.v2( 50, 267 ), dot.v2( 0, -1 ) );
        window.ray2 = new dot.Ray2( dot.v2( 50, 267 ), dot.v2( 1, 0 ) );
        console.log( 'ray1: ' + shape.windingIntersection( ray1 ) );
        console.log( 'ray2: ' + shape.windingIntersection( ray2 ) );
      }

      window.debugArcs = function() {
        var normalCircle = new kite.Arc( dot.v2( 0, 0 ), 40, 0, Math.PI * 2, false );
        var reversedCircle = new kite.Arc( dot.v2( 0, 0 ), 40, Math.PI * 2, 0, true );
        var rotatedCircle = new kite.Arc( dot.v2( 0, 0 ), 40, Math.PI, 3 * Math.PI, false );
        var normalArc = new kite.Arc( dot.v2( 0, 0 ), 40, Math.PI * 0.25, Math.PI * 0.75, false );
        var normalSecondArc = new kite.Arc( dot.v2( 0, 0 ), 40, Math.PI * 0.5, Math.PI * 1, false );
        var largeArc = new kite.Arc( dot.v2( 0, 0 ), 40, 0, Math.PI * 1.8, false );
        var largeSecondArc = new kite.Arc( dot.v2( 0, 0 ), 40, Math.PI * 1.6, Math.PI * 2.4, false );
        var largeMatchingArc = new kite.Arc( dot.v2( 0, 0 ), 40, Math.PI * 1.8, Math.PI * 2.4, false );
        var offsetCircle = new kite.Arc( dot.v2( 30, 0 ), 40, 0, Math.PI * 2, false );
        debugArcOverlap( normalCircle, normalArc );
        debugArcOverlap( normalCircle, reversedCircle );
        debugArcOverlap( normalArc, normalSecondArc );
        debugArcOverlap( largeArc, largeSecondArc );
        debugArcOverlap( largeArc, largeSecondArc.reversed() );
        debugArcOverlap( largeArc, largeMatchingArc );
        debugArcOverlap( normalCircle, rotatedCircle );
        debugArcOverlap( normalCircle, rotatedCircle.reversed() );
        debugArcOverlap( normalCircle, offsetCircle );
      };

      window.debugEllipticalArcs = function() {
        var normalEllipse = new kite.EllipticalArc( dot.v2( 0, 0 ), 40, 20, Math.PI * 0.1, 0, Math.PI * 2, false );
        var mirrorEllipse = new kite.EllipticalArc( dot.v2( 0, 0 ), 40, 20, Math.PI * 1.1, Math.PI, Math.PI * 3, false );
        var normalEllipticalArc = new kite.EllipticalArc( dot.v2( 0, 0 ), 40, 20, Math.PI * 0.1, 0, Math.PI / 4, false );
        debugEllipticalArcOverlap( normalEllipse, normalEllipticalArc );
        debugEllipticalArcOverlap( normalEllipse, mirrorEllipse );
      };

      function debugArcOverlap( arc1, arc2 ) {
        debugOverlap( arc1, arc2, kite.Arc.getOverlaps );
      }

      function debugEllipticalArcOverlap( arc1, arc2 ) {
        debugOverlap( arc1, arc2, kite.EllipticalArc.getOverlaps );
      }

      function debugOverlap( segment1, segment2, overlapFunction ) {
        var canvas = document.createElement( 'canvas' );
        canvas.width = 400;
        canvas.height = 100;
        document.body.appendChild( canvas );

        var context = canvas.getContext( '2d' );

        context.save();
        context.translate( 50, 50 );
        debugSegment( context, segment1, 'red' );
        context.restore();

        context.save();
        context.translate( 150, 50 );
        debugSegment( context, segment2, 'blue' );
        context.restore();

        var overlaps = overlapFunction( segment1, segment2 );

        function displayOverlap( x, overlap ) {
          var segment1Slice = segment1.slice( overlap.t0, overlap.t1 );
          var segment2Slice = segment2.slice( overlap.qt0, overlap.qt1 );

          context.save();
          context.translate( x, 50 );
          debugSegment( context, segment1Slice, 'rgba(255,0,0,0.4)' );
          debugSegment( context, segment2Slice, 'rgba(0,0,255,0.4)' );
          context.restore();
        }

        if ( overlaps[ 0 ] ) {
          displayOverlap( 250, overlaps[ 0 ] );
        }
        if ( overlaps[ 1 ] ) {
          displayOverlap( 350, overlaps[ 1 ] );
        }
      };

      function debugSegment( context, segment, color ) {
        context.beginPath();
        context.moveTo( segment.start.x, segment.start.y );
        segment.writeToContext( context );

        var t = 0.8;
        var t2 = 0.87;
        var halfPosition = segment.positionAt( t );
        var morePosition = segment.positionAt( t2 );
        var ext = halfPosition.distance( morePosition ) * 2 / 3;
        var halfTangent = segment.tangentAt( t ).normalized();
        context.moveTo( halfPosition.x - halfTangent.y * ext, halfPosition.y + halfTangent.x * ext );
        context.lineTo( halfPosition.x + halfTangent.y * ext, halfPosition.y - halfTangent.x * ext );
        context.lineTo( morePosition.x, morePosition.y );
        context.closePath();

        context.strokeStyle = color;
        context.lineWidth = 1;
        context.stroke();
      }
    } );
  } );
</script>
</body>
</html>
